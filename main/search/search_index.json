{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>coola</code> is a Python library that provides simple functions to check in a single line if two complex/nested objects are equal or not. <code>coola</code> was initially designed to work with PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>, but it is possible to extend it to support other data structures.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have the following dictionaries that contain both a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>. You want to check if the two dictionaries are equal or not. By default, Python does not provide an easy way to check if the two dictionaries are equal or not. It is not possible to use the default equality operator <code>==</code> because it will raise an error. The <code>coola</code> library was developed to fill this gap. <code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p><code>coola</code> also provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-6)\nFalse\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>coola</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>coola</code> to a new version will possibly break any code that was using the old version of <code>coola</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>coola</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"customization/","title":"Customization","text":"<p>Both <code>objects_are_equal</code> and <code>objects_are_allclose</code> functions can be easily customized.</p>"},{"location":"customization/#how-to-implement-a-custom-baseequalitytester","title":"How to implement a custom <code>BaseEqualityTester</code>","text":"<p>Internally, the <code>objects_are_equal</code> function uses a <code>BaseEqualityTester</code> object to check if two objects are equal. <code>coola</code> comes with a default <code>BaseEqualityTester</code> named <code>EqualityTester</code>, but it is possible to implement a custom <code>BaseEqualityTester</code> to check if two objects are equal. The following example shows how to use a custom <code>BaseEqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import BaseEqualityTester, objects_are_equal\n&gt;&gt;&gt; class MyCustomEqualityTester(BaseEqualityTester):\n...     def equal(self, object1: Any, object2: Any, show_difference: bool = False) -&gt; bool:\n...         return object1 is object2\n...\n&gt;&gt;&gt; objects_are_equal([1, 2, 3], (1, 2, 3), tester=MyCustomEqualityTester())\nFalse\n</code></pre> <p>Implemented a new <code>BaseEqualityTester</code> allows to customize the behavior of <code>objects_are_equal</code>.</p>"},{"location":"customization/#how-to-customize-equalitytester","title":"How to customize <code>EqualityTester</code>","text":"<p>Implementing a new <code>BaseEqualityTester</code> can be a lot of work, so it is not always a practical solution. For example if you want to support a new type, you do not want to reimplement everything. Instead of implementing a new <code>BaseEqualityTester</code>, it is possible to customize the default <code>EqualityTester</code>.</p>"},{"location":"customization/#overview","title":"Overview","text":"<p><code>EqualityTester</code> has a registry of equality operators with their associated types. An equality operator is an object that follows the <code>BaseEqualityOperator</code> API. <code>EqualityTester</code> uses the Method Resolution Order (MRO) of the first object to find the equality operator to use. It uses the most specific equality operator. For example, <code>EqualityTester</code> has an equality operator registered for <code>object</code> and another one <code>list</code>. If the first element to compare is a <code>list</code>, <code>EqualityTester</code> will use the equality operator associated to <code>list</code> to compare the two objects. You can use the following code to see the registered equality operators with their associated types.</p> <pre><code>&gt;&gt;&gt; from coola import EqualityTester\n&gt;&gt;&gt; EqualityTester.registry\n{&lt;class 'collections.abc.Mapping'&gt;: MappingEqualityOperator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityOperator(),\n &lt;class 'dict'&gt;: MappingEqualityOperator(),\n &lt;class 'list'&gt;: SequenceEqualityOperator(),\n &lt;class 'object'&gt;: DefaultEqualityOperator(),\n &lt;class 'tuple'&gt;: SequenceEqualityOperator(),\n ...}\n</code></pre> <p>An equality operator (<code>DefaultEqualityOperator</code>) is registered for <code>object</code> type, so this equality operator is considered like the default equality operator. For example, it will be used to compare <code>int</code> or <code>float</code> or <code>str</code> because there is no specific equality operator for these types. Note that the same equality operator can be used for multiple types. For example, by default, the same equality operator is used for <code>list</code>, <code>tuple</code>, and <code>collections.abc.Sequence</code>. The following sections explain how to customize this registry.</p>"},{"location":"customization/#add-an-equality-operator","title":"Add an equality operator","text":"<p>It is possible to add a new equality operator to the <code>EqualityTester</code>. The following example shows how to define a new behavior for strings. Instead of checking if two strings are the same (default behavior), the new behavior is that two strings are equal if the first string is a part of the second string. It is a two-steps process to add a new equality operator to <code>EqualityTester</code>. First, you need to implement a new <code>BaseEqualityOperator</code> with the expected behavior for the specific type (<code>str</code> for this example). Then, you need to add the <code>BaseEqualityOperator</code> to <code>EqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import BaseEqualityOperator, BaseEqualityTester, EqualityTester, objects_are_equal\n&gt;&gt;&gt; # Step 1: implementation of a new equality operator\n&gt;&gt;&gt; class MyCustomStrEqualityOperator(BaseEqualityOperator):\n...     def clone(self) -&gt; \"MyCustomStrEqualityOperator\":\n...         return self.__class__()\n...\n...     def equal(\n...         self,\n...         tester: BaseEqualityTester,\n...         object1: str,\n...         object2: Any,\n...         show_difference: bool = False,\n...     ) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return object1 in object2\n...\n&gt;&gt;&gt; # Step 2: add the new equality operator to EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_operator(str, MyCustomStrEqualityOperator())\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcde\", tester=tester)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"cba\", tester=tester)\nFalse\n&gt;&gt;&gt; tester.registry\n{&lt;class 'collections.abc.Mapping'&gt;: MappingEqualityOperator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityOperator(),\n &lt;class 'dict'&gt;: MappingEqualityOperator(),\n &lt;class 'list'&gt;: SequenceEqualityOperator(),\n &lt;class 'object'&gt;: DefaultEqualityOperator(),\n &lt;class 'tuple'&gt;: SequenceEqualityOperator(),\n ...\n &lt;class 'str'&gt;: MyCustomStrEqualityOperator()}\n</code></pre> <p>Once registered, the new equality operator is used automatically when you use the <code>objects_are_equal</code> function. You can use the <code>registry</code> attribute to check the registered equality operators. You should see the new added equality operator (last line for this example).</p>"},{"location":"customization/#update-the-equality-operator-for-a-given-type","title":"Update the equality operator for a given type","text":"<p>The previous section explains how to add a new equality operator to <code>EqualityTester</code>. This section explains how to update the equality operator for a specific type. To update an equality operator for a given type, you need to add the argument <code>exist_ok=True</code> when the new equality operator is added.</p> <pre><code>&gt;&gt;&gt; from collections.abc import Mapping\n&gt;&gt;&gt; from coola import BaseEqualityOperator, EqualityTester\n&gt;&gt;&gt; class MyCustomMappingEqualityOperator(BaseEqualityOperator):\n...     def clone(self) -&gt; \"MyCustomMappingEqualityOperator\":\n...         return self.__class__()\n...\n...     def equal(\n...         self,\n...         tester: BaseEqualityTester,\n...         object1: Mapping,\n...         object2: Any,\n...         show_difference: bool = False,\n...     ) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return object1 is object2\n...\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_operator(\n...     Mapping,\n...     MyCustomMappingEqualityOperator(),\n...     exist_ok=True,\n... )\n&gt;&gt;&gt; tester.registry\n{&lt;class 'collections.abc.Mapping'&gt;: MyCustomMappingEqualityOperator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityOperator(),\n &lt;class 'dict'&gt;: MappingEqualityOperator(),\n &lt;class 'list'&gt;: SequenceEqualityOperator(),\n &lt;class 'object'&gt;: DefaultEqualityOperator(),\n &lt;class 'tuple'&gt;: SequenceEqualityOperator(),\n ...}\n</code></pre>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install coola\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>coola</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'coola[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install coola numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>coola</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/coola.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate coola\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>coola</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"quickstart/","title":"coola quickstart","text":"<p> This page is a quick overview of the two main functions of <code>coola</code>: <code>objects_are_equal</code> and <code>objects_are_allclose</code>. These functions can be used to check if two complex/nested objects are equal or not. The motivation of the library is explained here. You should read this page if you want to learn how to use these functions. This page does not explain the internal behavior of these functions.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial. It is highly recommended to know a bit of NumPy or PyTorch.</p>"},{"location":"quickstart/#equal-or-not","title":"Equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not. It also works for simple objects like integer or string.</p>"},{"location":"quickstart/#first-example","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_equal</code> function. The objects to compare are dictionaries containing a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nTrue\n</code></pre> <p>In one line, it is possible to check two complex/nested objects are equal or not. Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function can check if two dictionaries containing PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>s are equal or not.</p>"},{"location":"quickstart/#finding-a-difference","title":"Finding a difference","text":"<p>When the objects are complex or nested, it is not obvious to know which elements are different. This function has an argument <code>show_difference</code> which shows the first difference found between the two objects. For example if you add <code>show_difference=True</code> when you compare the <code>data1</code> and <code>data2</code>, you will see at least one element that is different:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Log output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nobject1=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nobject2=\ntensor([[0., 0., 0.],\n        [0., 0., 0.]])\nINFO:coola.comparators.equality:The mappings have a different value for the key 'torch':\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[0., 0., 0.],\n        [0., 0., 0.]]), 'numpy': array([[1., 1., 1.],\n       [1., 1., 1.]])}\n</code></pre> <p>If you do not see this output, you may need to configure <code>logging</code> to show the <code>INFO</code> level (something like <code>logging.basicConfig(level=logging.INFO)</code>). The log shows a difference between <code>data1</code> and <code>data2</code>: the PyTorch <code>Tensor</code>s in key <code>'torch'</code> of the input dictionaries. The top of the log shows the element that fails the check, and then it shows the parent element, so it is easy to know where is the identified difference. Note that it only shows the first difference, not all the differences. Two objects are different if any of these elements are different. In the previous example, only the difference for key <code>'torch'</code> is shown in the log. No log is shown if the two objects are equal and <code>show_difference=True</code>.</p>"},{"location":"quickstart/#more-examples","title":"More examples","text":"<p>The previous examples use dictionary, but it is possible to use other types like list or tuple</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = [torch.ones(2, 3), numpy.zeros((2, 3))]\n&gt;&gt;&gt; data2 = [torch.zeros(2, 3), numpy.ones((2, 3))]\n&gt;&gt;&gt; data3 = (torch.ones(2, 3), numpy.zeros((2, 3)))\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>It is also possible to test more complex objects</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abcd\"},\n...     \"int\": 1,\n... }\n...\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p>Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"quickstart/#strict-type-checking","title":"Strict type checking","text":"<p> Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function requires two objects to be of the same type to be equal. For example, <code>1</code> (integer) is considered different from <code>1.0</code> (float) or <code>True</code> (boolean) which is different behavior that the native python equality operator <code>==</code>. You can take a look to the following example to see some differences.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, True)\nFalse\n&gt;&gt;&gt; 1 == 1\nTrue\n&gt;&gt;&gt; 1 == 1.0\nTrue\n&gt;&gt;&gt; 1 == True\nTrue\n</code></pre> <p>Similarly, the <code>objects_are_equal</code> function considers a <code>dict</code> and <code>collections.OrderedDict</code> as different objects even if they have the same keys and values.</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"key1\": 1, \"key2\": \"abc\"}, OrderedDict({\"key1\": 1, \"key2\": \"abc\"}))\nFalse\n&gt;&gt;&gt; {\"key1\": 1, \"key2\": \"abc\"} == OrderedDict({\"key1\": 1, \"key2\": \"abc\"})\nTrue\n</code></pre>"},{"location":"quickstart/#almost-equal-or-not","title":"Almost equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not. Due to numerical precision, it happens quite often that two numbers are not equal but the error is very tiny (<code>1.0</code> and <code>1.000000001</code>). The tolerance is mostly useful for numerical values. For a lot of types like string, the <code>objects_are_allclose</code> function behaves like the <code>objects_are_equal</code> function.</p>"},{"location":"quickstart/#first-example_1","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_allclose</code> function. The objects to compare are dictionaries containing a PyTorch Tensor and a NumPy ndarray.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose, objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3) + 1e-9, \"numpy\": numpy.zeros((2, 3)) - 1e-9}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data3)\nTrue\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>The difference between <code>data1</code> and <code>data2</code> is large so <code>objects_are_allclose</code> returns false like <code>objects_are_equal</code>. The difference between <code>data1</code> and <code>data3</code> is tiny so <code>objects_are_allclose</code> returns true, whereas <code>objects_are_equal</code> returns false.</p>"},{"location":"quickstart/#tolerance","title":"Tolerance","text":"<p>It is possible to control the tolerance with the arguments <code>atol</code> and <code>rtol</code>. <code>atol</code> controls the absolute tolerance and <code>rtol</code> controls the relative tolerance.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-3)\nTrue\n</code></pre> <p><code>objects_are_equal</code> and <code>objects_are_allclose</code> are very similar and should behave the same when <code>atol=0.0</code> and <code>rtol=0.0</code>.</p>"},{"location":"quickstart/#finding-a-difference_1","title":"Finding a difference","text":"<p>Like <code>objects_are_equal</code>, the <code>objects_are_allclose</code> function has an argument <code>show_difference</code> which shows the first difference found between the two objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nobject1=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nobject2=\ntensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]])\nINFO:coola.comparators.allclose:The mappings have a different value for the key torch:\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]]), 'numpy': array([[-0.0001, -0.0001, -0.0001],\n       [-0.0001, -0.0001, -0.0001]])}\n</code></pre>"},{"location":"quickstart/#more-examples_1","title":"More examples","text":"<p>Like the <code>objects_are_equal</code> function, the <code>objects_are_allclose</code> function can be used with complex/nested objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3)) + 1e-9],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nTrue\n</code></pre> <p><code>objects_are_allclose</code> supports a lot of types and nested structure. Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"quickstart/#not-a-number-nan","title":"Not A Number (NaN)","text":"<p>By default, <code>NaN</code> is not considered close to any other value, including <code>NaN</code>.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), 0.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> <p>By setting <code>equal_nan=True</code>, it is possible to change the above behavior and <code>NaN</code>s will be considered equal.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre> <p>In arrays or tensors, <code>NaN</code> are sometimes to indicate some values are not valid. However, it may be interested to check if the non-<code>NaN</code> values are equal. It is possible to use the <code>equal_nan=True</code> option to compare two tensors with <code>NaN</code> values.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n</code></pre> <p>Output:</p> <pre><code>False\nTrue\nFalse\nTrue\n</code></pre>"},{"location":"types/","title":"Supported Types","text":"<p> This page describes what types are currently supported and what rules are used to check if two objects are equal or not.</p> <p>The current supported types are:</p> <ul> <li><code>jax.numpy.ndarray</code></li> <li><code>numpy.ndarray</code></li> <li><code>pandas.DataFrame</code></li> <li><code>pandas.Series</code></li> <li><code>polars.DataFrame</code></li> <li><code>polars.Series</code></li> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> <li><code>xarray.Variable</code></li> </ul>"},{"location":"types/#equal","title":"Equal","text":""},{"location":"types/#object","title":"<code>object</code>","text":"<p>By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>object1 == object2</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(True, True)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"types/#collectionsabcmapping-dict","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal. The value associated to the key <code>k</code> in the first mapping has   to be equal to value associated to the key <code>k</code> in the second mapping.</li> </ul> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"types/#collectionsabcsequence-list-tuple","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal. The <code>i</code>-th element in the first sequence has to be   equal to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"types/#pytorch","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"types/#torchtensor","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>tensor1.equal(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"types/#torchnnutilsrnnpackedsequence","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal if:</p> <ul> <li>The <code>data</code> attributes are equal</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"types/#numpyndarray","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>numpy.array_equal(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"types/#xarray","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"types/#xarraydataarray","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal if:</p> <ul> <li>they have the same data values (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"]))\nTrue\n&gt;&gt;&gt; objects_are_equal(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"]))\nFalse\n</code></pre>"},{"location":"types/#xarraydataset","title":"<code>xarray.Dataset</code>","text":"<p>Two xarray <code>Dataset</code>s are equal if <code>xarray.Dataset.identical</code> returns <code>True</code>. In contrast to the standard usage in numpy, NaNs are compared like numbers, two <code>Dataset</code>s are equal if both objects have NaNs in the same positions.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; ds1 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds2 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds3 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1},\n... )\n&gt;&gt;&gt; objects_are_equal(ds1, ds2)\nTrue\n&gt;&gt;&gt; objects_are_equal(ds1, ds3)\nFalse\n</code></pre>"},{"location":"types/#equal-within-a-tolerance-allclose","title":"Equal within a tolerance (allclose)","text":""},{"location":"types/#object_1","title":"<code>object</code>","text":"<p>The concept of equal within a tolerance does not make sense for all <code>object</code>s. In general, the tolerance is not used for <code>object</code>s. The tolerance is only used for numbers (see below). By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>object1 == object2</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abc\")\nTrue\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"types/#numbers-bool-int-float","title":"Numbers: <code>bool</code> | <code>int</code> | <code>float</code>","text":"<p>Two numbers are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>the values are equal with a tolerance</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1, 2, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2.0, atol=1)\nFalse\n</code></pre> <p>Note that booleans are explicitly considered as integers in Python so the tolerance can be used with booleans:</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(True, False)\nFalse\n&gt;&gt;&gt; objects_are_allclose(True, False, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(True, False, rtol=1)\nTrue\n</code></pre>"},{"location":"types/#collectionsabcmapping-dict_1","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal within a tolerance. The value associated to the key <code>k</code> in the   first mapping has to be equal within the tolerance to value associated to the key <code>k</code> in the   second mapping.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"types/#collectionsabcsequence-list-tuple_1","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal within a tolerance. The <code>i</code>-th element in the first   sequence has to be equal within a tolerance to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"types/#pytorch_1","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal within a tolerance or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"types/#torchtensor_1","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>tensor1.allclose(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"types/#torchnnutilsrnnpackedsequence_1","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal within a tolerance if:</p> <ul> <li>The <code>data</code> attributes are equal within a tolerance</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float() + 1,\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     atol=2,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"types/#numpyndarray_1","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>numpy.allclose(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"types/#xarray_1","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"types/#xarraydataarray_1","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data values within the tolerance (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"]))\nTrue\n&gt;&gt;&gt; objects_are_allclose(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"]))\nFalse\n</code></pre>"},{"location":"refs/","title":"Main functions","text":""},{"location":"refs/#comparison","title":"Comparison","text":""},{"location":"refs/#coola.objects_are_allclose","title":"coola.objects_are_allclose","text":"<pre><code>objects_are_allclose(\n    object1: Any,\n    object2: Any,\n    *,\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>rtol</code> <code>float</code> <p>Specifies the relative tolerance parameter.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Specifies the absolute tolerance parameter.</p> <code>1e-08</code> <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>Specifies an equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are (element-wise) equal within a tolerance, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.ones(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3) + 1e-7, torch.ones(2)],\n...     [torch.ones(2, 3), torch.ones(2) - 1e-7],\n...     rtol=0,\n...     atol=1e-8,\n... )\nFalse\n</code></pre>"},{"location":"refs/#coola.objects_are_equal","title":"coola.objects_are_equal","text":"<pre><code>objects_are_equal(\n    object1: Any,\n    object2: Any,\n    *,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>Specifies an equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two nested data are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal([torch.ones(2, 3), torch.ones(2)], [torch.ones(2, 3), torch.zeros(2)])\nFalse\n</code></pre>"},{"location":"refs/#summary","title":"Summary","text":""},{"location":"refs/#coola.summary","title":"coola.summary","text":"<pre><code>summary(\n    value: Any,\n    max_depth: int = 1,\n    summarizer: BaseSummarizer | None = None,\n) -&gt; str\n</code></pre> <p>Summarize the input value in a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Specifies the value to summarize.</p> required <code>max_depth</code> <code>int</code> <p>Specifies the maximum depth to summarize if the input is nested.</p> <code>1</code> <code>summarizer</code> <code>BaseSummarizer | None</code> <p>Specifies the summarization strategy. If <code>None</code>, the default <code>Summarizer</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The summary as a string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summary\n&gt;&gt;&gt; print(summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/#coola.summarizer_options","title":"coola.summarizer_options","text":"<pre><code>summarizer_options(**kwargs: Any) -&gt; None\n</code></pre> <p>Context manager that temporarily changes the summarizer options.</p> <p>Accepted arguments are same as <code>set_summarizer_options</code>. The context manager temporary change the configuration of <code>Summarizer</code>. This context manager has no effect if <code>Summarizer</code> is not used.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Accepted arguments are same as <code>set_summarizer_options</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; with summarizer_options(max_characters=10):\n...     print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n...\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/#coola.set_summarizer_options","title":"coola.set_summarizer_options","text":"<pre><code>set_summarizer_options(\n    max_characters: int | None = None,\n    max_items: int | None = None,\n    num_spaces: int | None = None,\n) -&gt; None\n</code></pre> <p>Set the <code>Summarizer</code> options.</p> <p>Note: It is recommended to use <code>summarizer_options</code> rather than this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int | None</code> <p>Specifies the maximum number of characters to show. If <code>None</code>, the maximum number of characters is unchanged.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>Specifies the maximum number of items to show. If <code>None</code>, the maximum number of items is unchanged.</p> <code>None</code> <code>num_spaces</code> <code>int | None</code> <p>Specifies the number of spaces for indentation. If <code>None</code>, the number of  spaces for indentation is unchanged.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import set_summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; set_summarizer_options(max_characters=10)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; set_summarizer_options(max_characters=-1)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/comparators/","title":"Comparators","text":""},{"location":"refs/comparators/#coola.comparators","title":"coola.comparators","text":"<p>Contain the comparator implementations.</p>"},{"location":"refs/comparators/#coola.comparators.ArrayAllCloseOperator","title":"coola.comparators.ArrayAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[ndarray]</code></p> <p>Implement an allclose operator for <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_dtype</code> <code>bool</code> <p>If <code>True</code>, the data type of the arrays are checked, otherwise the data types are ignored.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.comparators import ArrayAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = ArrayAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, np.arange(21), np.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.ArrayEqualityOperator","title":"coola.comparators.ArrayEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[ndarray]</code></p> <p>Implement an equality operator for <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_dtype</code> <code>bool</code> <p>If <code>True</code>, the data type of the arrays are checked, otherwise the data types are ignored.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.comparators import ArrayEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = ArrayEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, np.arange(21), np.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseAllCloseOperator","title":"coola.comparators.BaseAllCloseOperator","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Defines the base class to implement an equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import DefaultAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = DefaultAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, 42, 42)\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseAllCloseOperator.allclose","title":"coola.comparators.BaseAllCloseOperator.allclose  <code>abstractmethod</code>","text":"<pre><code>allclose(\n    tester: BaseAllCloseTester,\n    object1: T,\n    object2: Any,\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>tester</code> <code>BaseAllCloseTester</code> <p>Specifies an equality tester.</p> required <code>object1</code> <code>T</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>rtol</code> <code>float</code> <p>Specifies the relative tolerance parameter.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Specifies the absolute tolerance  parameter.</p> <code>1e-08</code> <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal within a tolerance, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import DefaultAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = DefaultAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, 42, 42)\nTrue\n&gt;&gt;&gt; op.allclose(tester, \"meow\", \"meov\")\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseAllCloseOperator.clone","title":"coola.comparators.BaseAllCloseOperator.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseAllCloseOperator\n</code></pre> <p>Return a copy of the equality operator.</p> <p>Returns:</p> Type Description <code>BaseAllCloseOperator</code> <p>A copy of the equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import DefaultAllCloseOperator\n&gt;&gt;&gt; op = DefaultAllCloseOperator()\n&gt;&gt;&gt; op_cloned = op.clone()\n&gt;&gt;&gt; op_cloned\nDefaultAllCloseOperator()\n&gt;&gt;&gt; op is op_cloned\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseEqualityOperator","title":"coola.comparators.BaseEqualityOperator","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Defines the base class to implement an equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import DefaultEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = DefaultEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, 42, 42)\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseEqualityOperator.clone","title":"coola.comparators.BaseEqualityOperator.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseEqualityOperator\n</code></pre> <p>Return a copy of the equality operator.</p> <p>Returns:</p> Type Description <code>BaseEqualityOperator</code> <p>A copy of the equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import DefaultEqualityOperator\n&gt;&gt;&gt; op = DefaultEqualityOperator()\n&gt;&gt;&gt; op_cloned = op.clone()\n&gt;&gt;&gt; op_cloned\nDefaultEqualityOperator()\n&gt;&gt;&gt; op is op_cloned\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.BaseEqualityOperator.equal","title":"coola.comparators.BaseEqualityOperator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    tester: BaseEqualityTester,\n    object1: T,\n    object2: Any,\n    show_difference: bool = False,\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>tester</code> <code>BaseEqualityTester</code> <p>Specifies an equality tester.</p> required <code>object1</code> <code>T</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import DefaultEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = DefaultEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, 42, 42)\nTrue\n&gt;&gt;&gt; op.equal(tester, \"meow\", \"meov\")\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DataArrayAllCloseOperator","title":"coola.comparators.DataArrayAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[DataArray]</code></p> <p>Implement an allclose operator for <code>xarray.DataArray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import DataArrayAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = DataArrayAllCloseOperator()\n&gt;&gt;&gt; op.allclose(\n...     tester,\n...     xr.DataArray(np.arange(6)),\n...     xr.DataArray(np.arange(6)),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DataArrayEqualityOperator","title":"coola.comparators.DataArrayEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[DataArray]</code></p> <p>Implement an equality operator for <code>xarray.DataArray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import DataArrayEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = DataArrayEqualityOperator()\n&gt;&gt;&gt; op.equal(\n...     tester,\n...     xr.DataArray(np.arange(6)),\n...     xr.DataArray(np.arange(6)),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DatasetAllCloseOperator","title":"coola.comparators.DatasetAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Dataset]</code></p> <p>Implement an allclose operator for <code>xarray.Dataset</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import DatasetAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = DatasetAllCloseOperator()\n&gt;&gt;&gt; op.allclose(\n...     tester,\n...     xr.Dataset(\n...         {\n...             \"x\": xr.DataArray(np.arange(6), dims=[\"z\"]),\n...         },\n...         coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n...         attrs={\"global\": \"this is a global attribute\"},\n...     ),\n...     xr.Dataset(\n...         {\n...            \"x\": xr.DataArray(np.arange(6), dims=[\"z\"]),\n...         },\n...         coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n...         attrs={\"global\": \"this is a global attribute\"},\n...     ),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DatasetEqualityOperator","title":"coola.comparators.DatasetEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Dataset]</code></p> <p>Implement an equality operator for <code>xarray.Dataset</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import DatasetEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = DatasetEqualityOperator()\n&gt;&gt;&gt; op.equal(\n...     tester,\n...     xr.Dataset(\n...         {\n...             \"x\": xr.DataArray(np.arange(6), dims=[\"z\"]),\n...         },\n...         coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n...         attrs={\"global\": \"this is a global attribute\"},\n...     ),\n...     xr.Dataset(\n...         {\n...            \"x\": xr.DataArray(np.arange(6), dims=[\"z\"]),\n...         },\n...         coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n...         attrs={\"global\": \"this is a global attribute\"},\n...     ),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DefaultAllCloseOperator","title":"coola.comparators.DefaultAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Any]</code></p> <p>Implement a default allclose operator.</p> <p>The <code>==</code> operator is used to test the equality between the objects because it is not possible to define an allclose operator for all objects.</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import DefaultAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = DefaultAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, 42, 42)\nTrue\n&gt;&gt;&gt; DefaultAllCloseOperator().allclose(tester, \"meow\", \"meov\")\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.DefaultEqualityOperator","title":"coola.comparators.DefaultEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Any]</code></p> <p>Implement a default equality operator.</p> <p>The <code>==</code> operator is used to test the equality between the objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import DefaultEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = DefaultEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, 42, 42)\nTrue\n&gt;&gt;&gt; op.equal(tester, \"meow\", \"meov\")\nFalse\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.JaxArrayAllCloseOperator","title":"coola.comparators.JaxArrayAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[ndarray]</code></p> <p>Implement an allclose operator for <code>jax.Array</code>/<code>jax.numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_dtype</code> <code>bool</code> <p>If <code>True</code>, the data type of the arrays are checked, otherwise the data types are ignored.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.comparators import JaxArrayAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = JaxArrayAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, jnp.arange(21), jnp.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.JaxArrayEqualityOperator","title":"coola.comparators.JaxArrayEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[ndarray]</code></p> <p>Implement an equality operator for <code>jax.Array</code>/<code>jax.numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_dtype</code> <code>bool</code> <p>If <code>True</code>, the data type of the arrays are checked, otherwise the data types are ignored.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.comparators import JaxArrayEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = JaxArrayEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, jnp.arange(21), jnp.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.MappingAllCloseOperator","title":"coola.comparators.MappingAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Mapping]</code></p> <p>Implement an equality operator for mappings.</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import MappingAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = MappingAllCloseOperator()\n&gt;&gt;&gt; op.allclose(\n...     tester,\n...     {'key1': 42, 'key2': 1.2, \"key3\": \"abc\"},\n...     {'key1': 42, 'key2': 1.2, \"key3\": \"abc\"}\n... )\nTrue\n&gt;&gt;&gt; MappingAllCloseOperator().allclose(\n...     tester,\n...     {'key1': 42, 'key2': 1.2, \"key3\": \"abc\"},\n...     {'key1': 42, 'key2': 1.201, \"key3\": \"abc\"}\n... )\nFalse\n&gt;&gt;&gt; MappingAllCloseOperator().allclose(\n...     tester,\n...     {'key1': 42, 'key2': 1.2, \"key3\": \"abc\"},\n...     {'key1': 42, 'key2': 1.201, \"key3\": \"abc\"},\n...     atol=1e-2,\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.MappingEqualityOperator","title":"coola.comparators.MappingEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Mapping]</code></p> <p>Implement an equality operator for mappings.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import MappingEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = MappingEqualityOperator()\n&gt;&gt;&gt; op.equal(\n...     tester,\n...     {\"key1\": 42, \"key2\": 1.2, \"key3\": \"abc\"},\n...     {\"key1\": 42, \"key2\": 1.2, \"key3\": \"abc\"},\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.PackedSequenceAllCloseOperator","title":"coola.comparators.PackedSequenceAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[PackedSequence]</code></p> <p>Implement an allclose operator for <code>torch.nn.utils.rnn.PackedSequence</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.comparators import PackedSequenceAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = PackedSequenceAllCloseOperator()\n&gt;&gt;&gt; op.allclose(\n...     tester,\n...     torch.nn.utils.rnn.pack_padded_sequence(\n...         input=torch.arange(10, dtype=torch.float).view(2, 5),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     torch.nn.utils.rnn.pack_padded_sequence(\n...         input=torch.arange(10, dtype=torch.float).view(2, 5),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.PackedSequenceEqualityOperator","title":"coola.comparators.PackedSequenceEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[PackedSequence]</code></p> <p>Implement an equality operator for <code>torch.nn.utils.rnn.PackedSequence</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.comparators import PackedSequenceEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = PackedSequenceEqualityOperator()\n&gt;&gt;&gt; op.equal(\n...     tester,\n...     torch.nn.utils.rnn.pack_padded_sequence(\n...         input=torch.arange(10, dtype=torch.float).view(2, 5),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     torch.nn.utils.rnn.pack_padded_sequence(\n...         input=torch.arange(10, dtype=torch.float).view(2, 5),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.ScalarAllCloseOperator","title":"coola.comparators.ScalarAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Union[bool, int, float]]</code></p> <p>Implement an allclose operator for scalar values.</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import ScalarAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = ScalarAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, 42, 42)\nTrue\n&gt;&gt;&gt; op.allclose(tester, 42.0, 42.001)\nFalse\n&gt;&gt;&gt; op.allclose(tester, 42.0, 42.001, atol=1e-2)\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.SequenceAllCloseOperator","title":"coola.comparators.SequenceAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Sequence]</code></p> <p>Implement an equality operator for sequences.</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import SequenceAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = SequenceAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, [42, 1.2, \"abc\"], [42, 1.2, \"abc\"])\nTrue\n&gt;&gt;&gt; op.allclose(tester, [42, 1.2, \"abc\"], [42, 1.201, \"abc\"])\nFalse\n&gt;&gt;&gt; op.allclose(tester, [42, 1.2, \"abc\"], [42, 1.201, \"abc\"], atol=1e-2)\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.SequenceEqualityOperator","title":"coola.comparators.SequenceEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Sequence]</code></p> <p>Implement an equality operator for sequences.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.comparators import SequenceEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = SequenceEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, [42, 1.2, \"abc\"], [42, 1.2, \"abc\"])\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.TensorAllCloseOperator","title":"coola.comparators.TensorAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Tensor]</code></p> <p>Implement an allclose operator for <code>torch.Tensor</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.comparators import TensorAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = TensorAllCloseOperator()\n&gt;&gt;&gt; op.allclose(tester, torch.arange(21), torch.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.TensorEqualityOperator","title":"coola.comparators.TensorEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Tensor]</code></p> <p>Implement an equality operator for <code>torch.Tensor</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.comparators import TensorEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = TensorEqualityOperator()\n&gt;&gt;&gt; op.equal(tester, torch.arange(21), torch.arange(21))\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.VariableAllCloseOperator","title":"coola.comparators.VariableAllCloseOperator","text":"<p>             Bases: <code>BaseAllCloseOperator[Variable]</code></p> <p>Implement an allclose operator for <code>xarray.Variable</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import VariableAllCloseOperator\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; op = VariableAllCloseOperator()\n&gt;&gt;&gt; op.allclose(\n...     tester,\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     xr.Variable(dims=[\"z\"], data=np.arange(6))\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.VariableEqualityOperator","title":"coola.comparators.VariableEqualityOperator","text":"<p>             Bases: <code>BaseEqualityOperator[Variable]</code></p> <p>Implement an equality operator for <code>xarray.Variable</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.comparators import VariableEqualityOperator\n&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; op = VariableEqualityOperator()\n&gt;&gt;&gt; op.equal(\n...     tester,\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     xr.Variable(dims=[\"z\"], data=np.arange(6))\n... )\nTrue\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.get_mapping_allclose","title":"coola.comparators.get_mapping_allclose","text":"<pre><code>get_mapping_allclose() -&gt; (\n    dict[type[object], BaseAllCloseOperator]\n)\n</code></pre> <p>Get a default mapping between the types and the allclose operators.</p> <p>Returns:</p> Type Description <code>dict[type[object], BaseAllCloseOperator]</code> <p>The mapping between the types and the allclose operators.</p> <pre><code>&gt;&gt;&gt; from coola.comparators import get_mapping_allclose\n&gt;&gt;&gt; get_mapping_allclose()\n{&lt;class 'collections.abc.Mapping'&gt;: MappingAllCloseOperator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceAllCloseOperator(),\n &lt;class 'bool'&gt;: ScalarAllCloseOperator(),\n &lt;class 'dict'&gt;: MappingAllCloseOperator(),\n &lt;class 'float'&gt;: ScalarAllCloseOperator(),\n &lt;class 'int'&gt;: ScalarAllCloseOperator(),\n &lt;class 'list'&gt;: SequenceAllCloseOperator(),\n &lt;class 'object'&gt;: DefaultAllCloseOperator(),\n &lt;class 'tuple'&gt;: SequenceAllCloseOperator(),\n &lt;class 'jax.Array'&gt;: JaxArrayAllCloseOperator(check_dtype=True),\n &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;: JaxArrayAllCloseOperator(check_dtype=True),\n &lt;class 'numpy.ndarray'&gt;: ArrayAllCloseOperator(check_dtype=True),\n &lt;class 'pandas.core.frame.DataFrame'&gt;: DataFrameAllCloseOperator(),\n &lt;class 'pandas.core.series.Series'&gt;: SeriesAllCloseOperator(),\n &lt;class 'polars.dataframe.frame.DataFrame'&gt;: DataFrameAllCloseOperator(),\n &lt;class 'polars.series.series.Series'&gt;: SeriesAllCloseOperator(),\n &lt;class 'torch.Tensor'&gt;: TensorAllCloseOperator(),\n &lt;class 'torch.nn.utils.rnn.PackedSequence'&gt;: PackedSequenceAllCloseOperator(),\n &lt;class 'xarray.core.dataset.Dataset'&gt;: DatasetAllCloseOperator(),\n &lt;class 'xarray.core.dataarray.DataArray'&gt;: DataArrayAllCloseOperator(),\n &lt;class 'xarray.core.variable.Variable'&gt;: VariableAllCloseOperator()}\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.get_mapping_equality","title":"coola.comparators.get_mapping_equality","text":"<pre><code>get_mapping_equality() -&gt; (\n    dict[type[object], BaseEqualityOperator]\n)\n</code></pre> <p>Get a default mapping between the types and the equality operators.</p> <p>Returns:</p> Type Description <code>dict[type[object], BaseEqualityOperator]</code> <p>The mapping between the types and the equality operators.</p> <pre><code>&gt;&gt;&gt; from coola.comparators import get_mapping_equality\n&gt;&gt;&gt; get_mapping_equality()\n{&lt;class 'collections.abc.Mapping'&gt;: MappingEqualityOperator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityOperator(),\n &lt;class 'dict'&gt;: MappingEqualityOperator(),\n &lt;class 'list'&gt;: SequenceEqualityOperator(),\n &lt;class 'object'&gt;: DefaultEqualityOperator(),\n &lt;class 'tuple'&gt;: SequenceEqualityOperator(),\n &lt;class 'jax.Array'&gt;: JaxArrayEqualityOperator(check_dtype=True),\n &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;: JaxArrayEqualityOperator(check_dtype=True),\n &lt;class 'numpy.ndarray'&gt;: ArrayEqualityOperator(check_dtype=True),\n &lt;class 'pandas.core.frame.DataFrame'&gt;: DataFrameEqualityOperator(nulls_compare_equal=False),\n &lt;class 'pandas.core.series.Series'&gt;: SeriesEqualityOperator(nulls_compare_equal=False),\n &lt;class 'polars.dataframe.frame.DataFrame'&gt;: DataFrameEqualityOperator(),\n &lt;class 'polars.series.series.Series'&gt;: SeriesEqualityOperator(),\n &lt;class 'torch.Tensor'&gt;: TensorEqualityOperator(),\n &lt;class 'torch.nn.utils.rnn.PackedSequence'&gt;: PackedSequenceEqualityOperator(),\n &lt;class 'xarray.core.dataset.Dataset'&gt;: DatasetEqualityOperator(),\n &lt;class 'xarray.core.dataarray.DataArray'&gt;: DataArrayEqualityOperator(),\n &lt;class 'xarray.core.variable.Variable'&gt;: VariableEqualityOperator()}\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.register_allclose","title":"coola.comparators.register_allclose","text":"<pre><code>register_allclose() -&gt; None\n</code></pre> <p>Register allclose operators to <code>AllCloseTester</code>.</p> <pre><code>&gt;&gt;&gt; from coola.comparators import register_allclose\n&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; register_allclose()\n&gt;&gt;&gt; tester = AllCloseTester()\n&gt;&gt;&gt; tester\nAllCloseTester(\n  (&lt;class 'collections.abc.Mapping'&gt;): MappingAllCloseOperator()\n  (&lt;class 'collections.abc.Sequence'&gt;): SequenceAllCloseOperator()\n  (&lt;class 'bool'&gt;): ScalarAllCloseOperator()\n  (&lt;class 'dict'&gt;): MappingAllCloseOperator()\n  (&lt;class 'float'&gt;): ScalarAllCloseOperator()\n  (&lt;class 'int'&gt;): ScalarAllCloseOperator()\n  (&lt;class 'list'&gt;): SequenceAllCloseOperator()\n  (&lt;class 'object'&gt;): DefaultAllCloseOperator()\n  (&lt;class 'tuple'&gt;): SequenceAllCloseOperator()\n  (&lt;class 'jax.Array'&gt;): JaxArrayAllCloseOperator(check_dtype=True)\n  (&lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;): JaxArrayAllCloseOperator(check_dtype=True)\n  (&lt;class 'numpy.ndarray'&gt;): ArrayAllCloseOperator(check_dtype=True)\n  (&lt;class 'pandas.core.frame.DataFrame'&gt;): DataFrameAllCloseOperator()\n  (&lt;class 'pandas.core.series.Series'&gt;): SeriesAllCloseOperator()\n  (&lt;class 'polars.dataframe.frame.DataFrame'&gt;): DataFrameAllCloseOperator()\n  (&lt;class 'polars.series.series.Series'&gt;): SeriesAllCloseOperator()\n  (&lt;class 'torch.Tensor'&gt;): TensorAllCloseOperator()\n  (&lt;class 'torch.nn.utils.rnn.PackedSequence'&gt;): PackedSequenceAllCloseOperator()\n  (&lt;class 'xarray.core.dataset.Dataset'&gt;): DatasetAllCloseOperator()\n  (&lt;class 'xarray.core.dataarray.DataArray'&gt;): DataArrayAllCloseOperator()\n  (&lt;class 'xarray.core.variable.Variable'&gt;): VariableAllCloseOperator()\n)\n</code></pre>"},{"location":"refs/comparators/#coola.comparators.register_equality","title":"coola.comparators.register_equality","text":"<pre><code>register_equality() -&gt; None\n</code></pre> <p>Register equality operators to <code>EqualityTester</code>.</p> <p>from coola.comparators import register_equality from coola.testers import EqualityTester register_equality() tester = EqualityTester() tester EqualityTester(   (): MappingEqualityOperator()   (): SequenceEqualityOperator()   (): MappingEqualityOperator()   (): SequenceEqualityOperator()   (): DefaultEqualityOperator()   (): SequenceEqualityOperator()   (): JaxArrayEqualityOperator(check_dtype=True)   (): JaxArrayEqualityOperator(check_dtype=True)   (): ArrayEqualityOperator(check_dtype=True)   (): DataFrameEqualityOperator(nulls_compare_equal=False)   (): SeriesEqualityOperator(nulls_compare_equal=False)   (): DataFrameEqualityOperator()   (): SeriesEqualityOperator()   (): TensorEqualityOperator()   (): PackedSequenceEqualityOperator()   (): DatasetEqualityOperator()   (): DataArrayEqualityOperator()   (): VariableEqualityOperator() ) <p>```</p>"},{"location":"refs/formatters/","title":"Formatters","text":""},{"location":"refs/formatters/#coola.formatters","title":"coola.formatters","text":"<p>Contain the formatter implementations.</p>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter","title":"coola.formatters.BaseFormatter","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a formatter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.clone","title":"coola.formatters.BaseFormatter.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseFormatter\n</code></pre> <p>Return a copy of the formatter.</p> <p>Returns:</p> Type Description <code>BaseFormatter</code> <p>A copy of the formatter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter2 = formatter.clone()\n&gt;&gt;&gt; formatter.set_max_characters(10)\n&gt;&gt;&gt; formatter\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; formatter2\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.equal","title":"coola.formatters.BaseFormatter.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if the other object is equal to the self object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>Specifies the other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.equal(DefaultFormatter())\nTrue\n&gt;&gt;&gt; formatter.equal(DefaultFormatter(max_characters=10))\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.format","title":"coola.formatters.BaseFormatter.format  <code>abstractmethod</code>","text":"<pre><code>format(\n    summarizer: BaseSummarizer,\n    value: T,\n    depth: int,\n    max_depth: int,\n) -&gt; str\n</code></pre> <p>Format a value.</p> <p>Parameters:</p> Name Type Description Default <code>summarizer</code> <code>BaseSummarizer</code> <p>Specifies the summarizer.</p> required <code>value</code> <code>T</code> <p>Specifies the value to summarize.</p> required <code>depth</code> <code>int</code> <p>Specifies the current depth.</p> required <code>max_depth</code> <code>int</code> <p>Specifies the maximum depth.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.load_state_dict","title":"coola.formatters.BaseFormatter.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict</code> <p>a dict with parameters</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; # Please take a look to the implementation of the state_dict\n&gt;&gt;&gt; # function to know the expected structure\n&gt;&gt;&gt; formatter.load_state_dict({\"max_characters\": 10})\n&gt;&gt;&gt; formatter\nDefaultFormatter(max_characters=10)\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.state_dict","title":"coola.formatters.BaseFormatter.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict\n</code></pre> <p>Return a dictionary containing state values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.state_dict()\n{'max_characters': -1}\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter","title":"coola.formatters.DefaultFormatter","text":"<p>             Bases: <code>BaseFormatter[Any]</code></p> <p>Implement the default formatter.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>Specifies the maximum number of characters to show. If a negative value is provided, all the characters are shown.</p> <code>-1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter.get_max_characters","title":"coola.formatters.DefaultFormatter.get_max_characters","text":"<pre><code>get_max_characters() -&gt; int\n</code></pre> <p>Get the maximum number of characters to show.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum number of characters to show.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.get_max_characters()\n-1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter.set_max_characters","title":"coola.formatters.DefaultFormatter.set_max_characters","text":"<pre><code>set_max_characters(max_characters: int) -&gt; None\n</code></pre> <p>Set the maximum number of characters to show.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>Specifies the maximum number of characters to show.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>max_characters</code> is not an integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.set_max_characters(10)\n&gt;&gt;&gt; formatter.get_max_characters()\n10\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.MappingFormatter","title":"coola.formatters.MappingFormatter","text":"<p>             Bases: <code>BaseCollectionFormatter[Mapping]</code></p> <p>Implement a formatter for <code>Mapping</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import MappingFormatter\n&gt;&gt;&gt; formatter = MappingFormatter()\n&gt;&gt;&gt; print(formatter.format(Summarizer(), {'key1': 1.2, 'key2': 'abc', 'key3': 42}))\n&lt;class 'dict'&gt; (length=3)\n  (key1): 1.2\n  (key2): abc\n  (key3): 42\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter","title":"coola.formatters.NDArrayFormatter","text":"<p>             Bases: <code>BaseFormatter[ndarray]</code></p> <p>Implement a formatter for <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, the returned string is the default string representation (<code>repr</code>). If <code>False</code>, the returned string only contains the tensor metadata.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), np.arange(21))\n&lt;class 'numpy.ndarray'&gt; | shape=(21,) | dtype=int64\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter.get_show_data","title":"coola.formatters.NDArrayFormatter.get_show_data","text":"<pre><code>get_show_data() -&gt; bool\n</code></pre> <p>Indicate if the array data or metadata are shown.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the array data are shown, <code>False</code> if the array metadata are shown.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.get_show_data()\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter.set_show_data","title":"coola.formatters.NDArrayFormatter.set_show_data","text":"<pre><code>set_show_data(show_data: bool) -&gt; None\n</code></pre> <p>Set if the array data or metadata are shown.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p><code>True</code> if the array data are shown, <code>False</code> if the array metadata are shown.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>show_data</code> is not a boolean.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.set_show_data(True)\n&gt;&gt;&gt; formatter.get_show_data()\nTrue\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.SequenceFormatter","title":"coola.formatters.SequenceFormatter","text":"<p>             Bases: <code>BaseCollectionFormatter[Sequence]</code></p> <p>Implement a formatter for <code>Sequence</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import SequenceFormatter\n&gt;&gt;&gt; formatter = SequenceFormatter()\n&gt;&gt;&gt; print(formatter.format(Summarizer(), [1, 2, 3]))\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.SetFormatter","title":"coola.formatters.SetFormatter","text":"<p>             Bases: <code>BaseCollectionFormatter[set]</code></p> <p>Implement a formatter for <code>set</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import SetFormatter\n&gt;&gt;&gt; formatter = SetFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), {1})\n&lt;class 'set'&gt; (length=1)\\n  (0): 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter","title":"coola.formatters.TensorFormatter","text":"<p>             Bases: <code>BaseFormatter[Tensor]</code></p> <p>Implement a formatter for <code>torch.Tensor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, the returned string is the default string representation (<code>repr</code>). If <code>False</code>, the returned string only contains the tensor metadata.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), torch.arange(21))\n&lt;class 'torch.Tensor'&gt; | shape=torch.Size([21]) | dtype=torch.int64 | device=cpu\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter.get_show_data","title":"coola.formatters.TensorFormatter.get_show_data","text":"<pre><code>get_show_data() -&gt; bool\n</code></pre> <p>Indicate if the tensor data or metadata are shown.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the tensor data are shown, <code>False</code> if the tensor metadata are shown.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.get_show_data()\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter.set_show_data","title":"coola.formatters.TensorFormatter.set_show_data","text":"<pre><code>set_show_data(show_data: bool) -&gt; None\n</code></pre> <p>Set if the tensor data or metadata are shown.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p><code>True</code> if the tensor data are shown, <code>False</code> if the tensor metadata are shown.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>show_data</code> is not an boolean.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.set_show_data(True)\n&gt;&gt;&gt; formatter.get_show_data()\nTrue\n</code></pre>"},{"location":"refs/reducers/","title":"Reducers","text":""},{"location":"refs/reducers/#coola.reducers","title":"coola.reducers","text":"<p>Contain the reducer implementations.</p>"},{"location":"refs/reducers/#coola.reducers.BaseBasicReducer","title":"coola.reducers.BaseBasicReducer","text":"<p>             Bases: <code>BaseReducer</code></p> <p>Extension of <code>BaseReducer</code> to check if the input sequence is empty before to call the reduction methods.</p>"},{"location":"refs/reducers/#coola.reducers.BaseReducer","title":"coola.reducers.BaseReducer","text":"<p>             Bases: <code>ABC</code></p> <p>Define the base class to implement a reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.max","title":"coola.reducers.BaseReducer.max  <code>abstractmethod</code>","text":"<pre><code>max(values: Sequence[int | float]) -&gt; int | float\n</code></pre> <p>Compute the maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The maximum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.mean","title":"coola.reducers.BaseReducer.mean  <code>abstractmethod</code>","text":"<pre><code>mean(values: Sequence[int | float]) -&gt; float\n</code></pre> <p>Compute the mean value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.mean([-2, -1, 0, 1, 2])\n0.0\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.median","title":"coola.reducers.BaseReducer.median  <code>abstractmethod</code>","text":"<pre><code>median(values: Sequence[int | float]) -&gt; int | float\n</code></pre> <p>Compute the median value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The median value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.min","title":"coola.reducers.BaseReducer.min  <code>abstractmethod</code>","text":"<pre><code>min(values: Sequence[int | float]) -&gt; int | float\n</code></pre> <p>Compute the minimum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The minimum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.min([-2, -1, 0, 1, 2])\n-2\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.quantile","title":"coola.reducers.BaseReducer.quantile  <code>abstractmethod</code>","text":"<pre><code>quantile(\n    values: Sequence[int | float],\n    quantiles: Sequence[float],\n) -&gt; list[float]\n</code></pre> <p>Compute the quantiles.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <code>quantiles</code> <code>sequence of float</code> <p>Specifies the quantile values in the range <code>[0, 1]</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The quantiles.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.quantile([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (0.2, 0.5, 0.9))\n[2.0, 5.0, 9.0]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.sort","title":"coola.reducers.BaseReducer.sort  <code>abstractmethod</code>","text":"<pre><code>sort(\n    values: Sequence[int | float], descending: bool = False\n) -&gt; list[int | float]\n</code></pre> <p>Sorts the values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <code>descending</code> <code>bool</code> <p>Specifies the sorting order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int | float]</code> <p>The sorted values.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0], descending=True)\n[3, 2, 1, 0, -2]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.std","title":"coola.reducers.BaseReducer.std  <code>abstractmethod</code>","text":"<pre><code>std(values: Sequence[int | float]) -&gt; float\n</code></pre> <p>Compute the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[int | float]</code> <p>Specifies the values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.std([-2, -1, 0, 1, 2])\n1.581138...\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BasicReducer","title":"coola.reducers.BasicReducer","text":"<p>             Bases: <code>BaseBasicReducer</code></p> <p>Implement a basic reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import BasicReducer\n&gt;&gt;&gt; reducer = BasicReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.EmptySequenceError","title":"coola.reducers.EmptySequenceError","text":"<p>             Bases: <code>Exception</code></p> <p>Raise when the sequence is empty because it is not possible to reduce an empty sequence.</p>"},{"location":"refs/reducers/#coola.reducers.NumpyReducer","title":"coola.reducers.NumpyReducer","text":"<p>             Bases: <code>BaseBasicReducer</code></p> <p>Implement a reducer based on NumPy functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>numpy</code> is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry","title":"coola.reducers.ReducerRegistry","text":"<p>Implement the reducer registry.</p> <p>The registry is a class variable, so it is shared with all the instances of this class.</p>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.add_reducer","title":"coola.reducers.ReducerRegistry.add_reducer  <code>classmethod</code>","text":"<pre><code>add_reducer(\n    name: str, reducer: BaseReducer, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Add a reducer to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name of the reducer.</p> required <code>reducer</code> <code>BaseReducer</code> <p>Specifies the reducer.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the name already exists. This parameter should be set to <code>True</code> to overwrite the existing reducer.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a reducer is already registered for the name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry, BasicReducer\n&gt;&gt;&gt; ReducerRegistry.add_reducer(\"basic\", BasicReducer(), exist_ok=True)\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.available_reducers","title":"coola.reducers.ReducerRegistry.available_reducers  <code>classmethod</code>","text":"<pre><code>available_reducers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available reducers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available reducers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry\n&gt;&gt;&gt; ReducerRegistry.available_reducers()\n('basic', 'numpy', 'torch')\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.has_reducer","title":"coola.reducers.ReducerRegistry.has_reducer  <code>classmethod</code>","text":"<pre><code>has_reducer(name: str) -&gt; bool\n</code></pre> <p>Indicate if a reducer is registered for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Specifies the name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a reducer is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry\n&gt;&gt;&gt; ReducerRegistry.has_reducer(\"basic\")\nTrue\n&gt;&gt;&gt; ReducerRegistry.has_reducer(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.TorchReducer","title":"coola.reducers.TorchReducer","text":"<p>             Bases: <code>BaseBasicReducer</code></p> <p>Implement a reducer based on torch functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.auto_reducer","title":"coola.reducers.auto_reducer","text":"<pre><code>auto_reducer() -&gt; BaseReducer\n</code></pre> <p>Find the \"best\" reducer to used based on the installed packages.</p> <p>The \"best\" reducer is found by using the following rules:     - If <code>torch</code> is available, use <code>TorchReducer</code>     - If <code>numpy</code> is available, use <code>NumpyReducer</code>     - Otherwise, use <code>BasicReducer</code></p> <p>Returns:</p> Type Description <code>BaseReducer</code> <p>The \"best\" reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import auto_reducer\n&gt;&gt;&gt; reducer = auto_reducer()\n</code></pre>"},{"location":"refs/summarizers/","title":"Summarizers","text":""},{"location":"refs/summarizers/#coola.summarizers","title":"coola.summarizers","text":"<p>Contain the summarizer implementations.</p>"},{"location":"refs/summarizers/#coola.summarizers.BaseSummarizer","title":"coola.summarizers.BaseSummarizer","text":"<p>             Bases: <code>ABC</code></p> <p>Define the base class to implement a summarizer.</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer\nSummarizer(\n  (&lt;class 'collections.abc.Mapping'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'collections.abc.Sequence'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'dict'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'list'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'object'&gt;): DefaultFormatter(max_characters=-1)\n  (&lt;class 'set'&gt;): SetFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'tuple'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'numpy.ndarray'&gt;): NDArrayFormatter(show_data=False)\n  (&lt;class 'torch.Tensor'&gt;): TensorFormatter(show_data=False)\n)\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.BaseSummarizer.summary","title":"coola.summarizers.BaseSummarizer.summary  <code>abstractmethod</code>","text":"<pre><code>summary(\n    value: Any, depth: int = 0, max_depth: int = 1\n) -&gt; str\n</code></pre> <p>Summarize the input value in a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Specifies the value to summarize.</p> required <code>depth</code> <code>int</code> <p>Specifies the current depth.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>Specifies the maximum depth to summarize if the input is nested.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The summary as a string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer","title":"coola.summarizers.Summarizer","text":"<p>             Bases: <code>BaseSummarizer</code></p> <p>Implement the default summarizer.</p> <p>The registry is a class variable, so it is shared with all the instances of this class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer\nSummarizer(\n  (&lt;class 'collections.abc.Mapping'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'collections.abc.Sequence'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'dict'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'list'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'object'&gt;): DefaultFormatter(max_characters=-1)\n  (&lt;class 'set'&gt;): SetFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'tuple'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'numpy.ndarray'&gt;): NDArrayFormatter(show_data=False)\n  (&lt;class 'torch.Tensor'&gt;): TensorFormatter(show_data=False)\n)\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.add_formatter","title":"coola.summarizers.Summarizer.add_formatter  <code>classmethod</code>","text":"<pre><code>add_formatter(\n    data_type: type[object],\n    formatter: BaseFormatter,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a formatter for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type for this test.</p> required <code>formatter</code> <code>BaseFormatter</code> <p>Specifies the formatter to use for the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the formatter for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a formatter is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import MappingFormatter\n&gt;&gt;&gt; Summarizer.add_formatter(dict, MappingFormatter(), exist_ok=True)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.find_formatter","title":"coola.summarizers.Summarizer.find_formatter  <code>classmethod</code>","text":"<pre><code>find_formatter(data_type: Any) -&gt; BaseFormatter\n</code></pre> <p>Find the formatter associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>Specifies the data type to get.</p> required <p>Returns:</p> Type Description <code>BaseFormatter</code> <p>The formatter associated to the data type.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if a formatter cannot be found for this data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.find_formatter(list)\nSequenceFormatter(max_items=5, num_spaces=2)\n&gt;&gt;&gt; Summarizer.find_formatter(str)\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.has_formatter","title":"coola.summarizers.Summarizer.has_formatter  <code>classmethod</code>","text":"<pre><code>has_formatter(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if a formatter is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a formatter is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.has_formatter(list)\nTrue\n&gt;&gt;&gt; Summarizer.has_formatter(str)\nFalse\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.load_state_dict","title":"coola.summarizers.Summarizer.load_state_dict  <code>classmethod</code>","text":"<pre><code>load_state_dict(state: dict) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict</code> <p>A dictionary with state values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.load_state_dict({object: {\"max_characters\": 10}})\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; Summarizer.load_state_dict({object: {\"max_characters\": -1}})\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_max_characters","title":"coola.summarizers.Summarizer.set_max_characters  <code>classmethod</code>","text":"<pre><code>set_max_characters(max_characters: int) -&gt; None\n</code></pre> <p>Set the maximum of characters for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_max_characters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>Specifies the maximum of characters.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_max_characters(10)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; Summarizer.set_max_characters(-1)\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_max_items","title":"coola.summarizers.Summarizer.set_max_items  <code>classmethod</code>","text":"<pre><code>set_max_items(max_items: int) -&gt; None\n</code></pre> <p>Set the maximum number of items for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_max_items</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>Specifies the maximum number of items to show.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_max_items(10)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=10, num_spaces=2)\n&gt;&gt;&gt; Summarizer.set_max_items(5)\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=2)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_num_spaces","title":"coola.summarizers.Summarizer.set_num_spaces  <code>classmethod</code>","text":"<pre><code>set_num_spaces(num_spaces: int) -&gt; None\n</code></pre> <p>Set the maximum of items for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_num_spaces</code>.</p> <p>Parameters:</p> Name Type Description Default <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces for indentation.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_num_spaces(4)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=4)\n&gt;&gt;&gt; Summarizer.set_num_spaces(2)\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=2)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.state_dict","title":"coola.summarizers.Summarizer.state_dict  <code>classmethod</code>","text":"<pre><code>state_dict() -&gt; dict\n</code></pre> <p>Return a dictionary containing state values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.state_dict()\n{&lt;class 'collections.abc.Mapping'&gt;: {'max_items': 5, 'num_spaces': 2},...}\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.set_summarizer_options","title":"coola.summarizers.set_summarizer_options","text":"<pre><code>set_summarizer_options(\n    max_characters: int | None = None,\n    max_items: int | None = None,\n    num_spaces: int | None = None,\n) -&gt; None\n</code></pre> <p>Set the <code>Summarizer</code> options.</p> <p>Note: It is recommended to use <code>summarizer_options</code> rather than this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int | None</code> <p>Specifies the maximum number of characters to show. If <code>None</code>, the maximum number of characters is unchanged.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>Specifies the maximum number of items to show. If <code>None</code>, the maximum number of items is unchanged.</p> <code>None</code> <code>num_spaces</code> <code>int | None</code> <p>Specifies the number of spaces for indentation. If <code>None</code>, the number of  spaces for indentation is unchanged.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import set_summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; set_summarizer_options(max_characters=10)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; set_summarizer_options(max_characters=-1)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.summarizer_options","title":"coola.summarizers.summarizer_options","text":"<pre><code>summarizer_options(**kwargs: Any) -&gt; None\n</code></pre> <p>Context manager that temporarily changes the summarizer options.</p> <p>Accepted arguments are same as <code>set_summarizer_options</code>. The context manager temporary change the configuration of <code>Summarizer</code>. This context manager has no effect if <code>Summarizer</code> is not used.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Accepted arguments are same as <code>set_summarizer_options</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; with summarizer_options(max_characters=10):\n...     print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n...\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/testers/","title":"Testers","text":""},{"location":"refs/testers/#coola.testers","title":"coola.testers","text":"<p>Contain the tester implementations.</p>"},{"location":"refs/testers/#coola.testers.AllCloseTester","title":"coola.testers.AllCloseTester","text":"<p>             Bases: <code>BaseAllCloseTester</code></p> <p>Implement the default allclose tester.</p> <p>By default, this tester uses the following mapping to test the objects:</p> <pre><code>- ``PackedSequence``: ``PackedSequenceAllCloseOperator``\n- ``Tensor``: ``TensorAllCloseOperator``\n- ``bool``: ``ScalarAllCloseOperator``\n- ``dict``: ``MappingAllCloseOperator``\n- ``float``: ``ScalarAllCloseOperator``\n- ``int``: ``ScalarAllCloseOperator``\n- ``list``: ``SequenceAllCloseOperator``\n- ``np.ndarray``: ``NDArrayAllCloseOperator``\n- ``object``: ``DefaultAllCloseOperator``\n- ``tuple``: ``SequenceAllCloseOperator``\n</code></pre>"},{"location":"refs/testers/#coola.testers.AllCloseTester.add_operator","title":"coola.testers.AllCloseTester.add_operator  <code>classmethod</code>","text":"<pre><code>add_operator(\n    data_type: type[object],\n    operator: BaseAllCloseOperator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an allclose operator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type for this test.</p> required <code>operator</code> <code>BaseAllCloseOperator</code> <p>Specifies the operator used to test the allclose equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the operator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an operator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import SequenceAllCloseOperator\n&gt;&gt;&gt; AllCloseTester.add_operator(list, SequenceAllCloseOperator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.testers.AllCloseTester.find_operator","title":"coola.testers.AllCloseTester.find_operator  <code>classmethod</code>","text":"<pre><code>find_operator(data_type: Any) -&gt; BaseAllCloseOperator\n</code></pre> <p>Find the allclose operator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>Specifies the data type to get.</p> required <p>Returns:</p> Type Description <code>BaseAllCloseOperator</code> <p>The allclose operator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; AllCloseTester.find_operator(list)\nSequenceAllCloseOperator()\n&gt;&gt;&gt; AllCloseTester.find_operator(str)\nDefaultAllCloseOperator()\n</code></pre>"},{"location":"refs/testers/#coola.testers.AllCloseTester.has_operator","title":"coola.testers.AllCloseTester.has_operator  <code>classmethod</code>","text":"<pre><code>has_operator(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if an allclose operator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an allclose operator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; AllCloseTester.has_operator(list)\nTrue\n&gt;&gt;&gt; AllCloseTester.has_operator(str)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.testers.AllCloseTester.local_copy","title":"coola.testers.AllCloseTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalAllCloseTester\n</code></pre> <p>Return a copy of <code>AllCloseTester</code> that can easily be customized without changind <code>AllCloseTester</code>.</p> <p>Returns:</p> Type Description <code>LocalAllCloseTester</code> <p>A \"local\" copy of <code>AllCloseTester</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; AllCloseTester.local_copy()\nLocalAllCloseTester(...)\n</code></pre>"},{"location":"refs/testers/#coola.testers.BaseAllCloseTester","title":"coola.testers.BaseAllCloseTester","text":"<p>             Bases: <code>ABC</code></p> <p>Define the base class to implement an allclose tester.</p>"},{"location":"refs/testers/#coola.testers.BaseAllCloseTester.allclose","title":"coola.testers.BaseAllCloseTester.allclose  <code>abstractmethod</code>","text":"<pre><code>allclose(\n    object1: Any,\n    object2: Any,\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>rtol</code> <p>Specifies the relative tolerance parameter.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Specifies the absolute tolerance parameter.</p> <code>1e-08</code> <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal within a tolerance, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import AllCloseTester, BaseAllCloseTester\n&gt;&gt;&gt; tester: BaseAllCloseTester = AllCloseTester()\n&gt;&gt;&gt; tester.allclose(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; tester.allclose(\n...     [torch.ones(2, 3), torch.ones(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nFalse\n&gt;&gt;&gt; tester.allclose(\n...     [torch.ones(2, 3) + 1e-7, torch.ones(2)],\n...     [torch.ones(2, 3), torch.ones(2) - 1e-7],\n...     rtol=0,\n...     atol=1e-8,\n... )\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.testers.BaseEqualityTester","title":"coola.testers.BaseEqualityTester","text":"<p>             Bases: <code>ABC</code></p> <p>Defines the base class to implement an equality tester.</p>"},{"location":"refs/testers/#coola.testers.BaseEqualityTester.equal","title":"coola.testers.BaseEqualityTester.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    object1: Any,\n    object2: Any,\n    show_difference: bool = False,\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>Specifies the first object to compare.</p> required <code>object2</code> <code>Any</code> <p>Specifies the second object to compare.</p> required <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import BaseEqualityTester, EqualityTester\n&gt;&gt;&gt; tester: BaseEqualityTester = EqualityTester()\n&gt;&gt;&gt; tester.equal(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; tester.equal([torch.ones(2, 3), torch.ones(2)], [torch.ones(2, 3), torch.zeros(2)])\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.testers.EqualityTester","title":"coola.testers.EqualityTester","text":"<p>             Bases: <code>BaseEqualityTester</code></p> <p>Implement the default equality tester.</p>"},{"location":"refs/testers/#coola.testers.EqualityTester.add_operator","title":"coola.testers.EqualityTester.add_operator  <code>classmethod</code>","text":"<pre><code>add_operator(\n    data_type: type[object],\n    operator: BaseEqualityOperator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality operator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type for this test.</p> required <code>operator</code> <code>BaseEqualityOperator</code> <p>Specifies the operator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the operator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an operator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; from coola.comparators import SequenceEqualityOperator\n&gt;&gt;&gt; EqualityTester.add_operator(list, SequenceEqualityOperator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.testers.EqualityTester.find_operator","title":"coola.testers.EqualityTester.find_operator  <code>classmethod</code>","text":"<pre><code>find_operator(data_type: Any) -&gt; BaseEqualityOperator\n</code></pre> <p>Find the equality operator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>Specifies the data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityOperator</code> <p>The equality operator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.find_operator(list)\nSequenceEqualityOperator()\n&gt;&gt;&gt; EqualityTester.find_operator(str)\nDefaultEqualityOperator()\n</code></pre>"},{"location":"refs/testers/#coola.testers.EqualityTester.has_operator","title":"coola.testers.EqualityTester.has_operator  <code>classmethod</code>","text":"<pre><code>has_operator(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if an equality operator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality operator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.has_operator(list)\nTrue\n&gt;&gt;&gt; EqualityTester.has_operator(str)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.testers.EqualityTester.local_copy","title":"coola.testers.EqualityTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalEqualityTester\n</code></pre> <p>Return a copy of <code>EqualityTester</code> that can easily be customized without changind <code>EqualityTester</code>.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A \"local\" copy of <code>EqualityTester</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester\nLocalEqualityTester(...)\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalAllCloseTester","title":"coola.testers.LocalAllCloseTester","text":"<p>             Bases: <code>BaseAllCloseTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type[object], BaseAllCloseOperator] | None</code> <p>Specifies the initial registry with the equality operators.</p> <code>None</code>"},{"location":"refs/testers/#coola.testers.LocalAllCloseTester.add_operator","title":"coola.testers.LocalAllCloseTester.add_operator","text":"<pre><code>add_operator(\n    data_type: type[object],\n    operator: BaseAllCloseOperator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an allclose operator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type for this test.</p> required <code>operator</code> <code>BaseAllCloseOperator</code> <p>Specifies the operator used to test the allclose equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the operator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an operator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; from coola.comparators import SequenceAllCloseOperator\n&gt;&gt;&gt; tester = AllCloseTester.local_copy()\n&gt;&gt;&gt; tester.add_operator(list, SequenceAllCloseOperator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalAllCloseTester.clone","title":"coola.testers.LocalAllCloseTester.clone","text":"<pre><code>clone() -&gt; LocalAllCloseTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalAllCloseTester</code> <p>A deep copy of the current tester.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester.local_copy()\n&gt;&gt;&gt; tester_cloned = tester.clone()\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalAllCloseTester.find_operator","title":"coola.testers.LocalAllCloseTester.find_operator","text":"<pre><code>find_operator(data_type: Any) -&gt; BaseAllCloseOperator\n</code></pre> <p>Find the allclose operator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>Specifies the data type to get.</p> required <p>Returns:</p> Type Description <code>BaseAllCloseOperator</code> <p>The allclose operator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester.local_copy()\n&gt;&gt;&gt; tester.find_operator(list)\nSequenceAllCloseOperator()\n&gt;&gt;&gt; tester.find_operator(str)\nDefaultAllCloseOperator()\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalAllCloseTester.has_operator","title":"coola.testers.LocalAllCloseTester.has_operator","text":"<pre><code>has_operator(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if an allclose operator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an allclose operator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import AllCloseTester\n&gt;&gt;&gt; tester = AllCloseTester.local_copy()\n&gt;&gt;&gt; tester.has_operator(list)\nTrue\n&gt;&gt;&gt; tester.has_operator(str)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalEqualityTester","title":"coola.testers.LocalEqualityTester","text":"<p>             Bases: <code>BaseEqualityTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type[object], BaseEqualityOperator] | None</code> <p>Specifies the initial registry with the equality operators.</p> <code>None</code>"},{"location":"refs/testers/#coola.testers.LocalEqualityTester.add_operator","title":"coola.testers.LocalEqualityTester.add_operator","text":"<pre><code>add_operator(\n    data_type: type[object],\n    operator: BaseEqualityOperator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality operator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type for this test.</p> required <code>operator</code> <code>BaseEqualityOperator</code> <p>Specifies the operator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the operator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an operator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; from coola.comparators import DefaultEqualityOperator\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_operator(str, DefaultEqualityOperator())\n&gt;&gt;&gt; tester.add_operator(str, DefaultEqualityOperator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalEqualityTester.clone","title":"coola.testers.LocalEqualityTester.clone","text":"<pre><code>clone() -&gt; LocalEqualityTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A deep copy of the current tester.</p> <p>Example usage:</p> <p>```pycon</p> <p>import torch from coola.testers import EqualityTester tester = EqualityTester.local_copy() tester_cloned = tester.clone()</p> <p>```</p>"},{"location":"refs/testers/#coola.testers.LocalEqualityTester.find_operator","title":"coola.testers.LocalEqualityTester.find_operator","text":"<pre><code>find_operator(data_type: Any) -&gt; BaseEqualityOperator\n</code></pre> <p>Find the equality operator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>Specifies the data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityOperator</code> <p>The equality operator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.find_operator(list)\nSequenceEqualityOperator()\n&gt;&gt;&gt; tester.find_operator(str)\nDefaultEqualityOperator()\n</code></pre>"},{"location":"refs/testers/#coola.testers.LocalEqualityTester.has_operator","title":"coola.testers.LocalEqualityTester.has_operator","text":"<pre><code>has_operator(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if an equality operator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>Specifies the data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality operator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.has_operator(list)\nTrue\n&gt;&gt;&gt; tester.has_operator(str)\nFalse\n</code></pre>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#coola.utils","title":"coola.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#coola.utils.check_numpy","title":"coola.utils.check_numpy","text":"<pre><code>check_numpy() -&gt; None\n</code></pre> <p>Check if the <code>numpy</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>numpy</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_numpy\n&gt;&gt;&gt; check_numpy()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_pandas","title":"coola.utils.check_pandas","text":"<pre><code>check_pandas() -&gt; None\n</code></pre> <p>Check if the <code>pandas</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pandas</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_pandas\n&gt;&gt;&gt; check_pandas()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_polars","title":"coola.utils.check_polars","text":"<pre><code>check_polars() -&gt; None\n</code></pre> <p>Check if the <code>polars</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>polars</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_polars\n&gt;&gt;&gt; check_polars()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_torch","title":"coola.utils.check_torch","text":"<pre><code>check_torch() -&gt; None\n</code></pre> <p>Check if the <code>torch</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>torch</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_torch\n&gt;&gt;&gt; check_torch()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_xarray","title":"coola.utils.check_xarray","text":"<pre><code>check_xarray() -&gt; None\n</code></pre> <p>Check if the <code>xarray</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>xarray</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_xarray\n&gt;&gt;&gt; check_xarray()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_jax_available","title":"coola.utils.is_jax_available","text":"<pre><code>is_jax_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>jax</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>jax</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_jax_available\n&gt;&gt;&gt; is_jax_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_numpy_available","title":"coola.utils.is_numpy_available","text":"<pre><code>is_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>numpy</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>numpy</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_numpy_available\n&gt;&gt;&gt; is_numpy_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_pandas_available","title":"coola.utils.is_pandas_available","text":"<pre><code>is_pandas_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pandas</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pandas</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_pandas_available\n&gt;&gt;&gt; is_pandas_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_polars_available","title":"coola.utils.is_polars_available","text":"<pre><code>is_polars_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>polars</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>polars</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_polars_available\n&gt;&gt;&gt; is_polars_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_torch_available","title":"coola.utils.is_torch_available","text":"<pre><code>is_torch_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>torch</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>torch</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_torch_available\n&gt;&gt;&gt; is_torch_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_xarray_available","title":"coola.utils.is_xarray_available","text":"<pre><code>is_xarray_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>xarray</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>xarray</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_xarray_available\n&gt;&gt;&gt; is_xarray_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_indent","title":"coola.utils.repr_indent","text":"<pre><code>repr_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>Specifies the original string. If the inputis not a string, it will be converted to a string with the function <code>repr</code>.</p> required <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_mapping","title":"coola.utils.repr_mapping","text":"<pre><code>repr_mapping(\n    mapping: Mapping,\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>Specifies the mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>Specifies if the key of the dict are sorted or not.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_mapping\n&gt;&gt;&gt; print(repr_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_sequence","title":"coola.utils.repr_sequence","text":"<pre><code>repr_sequence(\n    sequence: Sequence, num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>Specifies the sequence.</p> required <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_indent","title":"coola.utils.str_indent","text":"<pre><code>str_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>Specifies the original string. If the inputis not a string, it will be converted to a string with the function <code>str</code>.</p> required <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_indent\n&gt;&gt;&gt; print(str_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_mapping","title":"coola.utils.str_mapping","text":"<pre><code>str_mapping(\n    mapping: Mapping,\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>Specifies the mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>Specifies if the key of the dict are sorted or not.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_mapping\n&gt;&gt;&gt; print(str_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_sequence","title":"coola.utils.str_sequence","text":"<pre><code>str_sequence(\n    sequence: Sequence, num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>Specifies the sequence.</p> required <code>num_spaces</code> <code>int</code> <p>Specifies the number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_sequence\n&gt;&gt;&gt; print(str_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"upgrade/0.3/","title":"0.2 to 0.3","text":"<p>This page explains how to migrate from <code>coola</code> 0.2 to 0.3 because <code>coola</code> 0.3 introduces several major non-backward compatible changes:</p> <ul> <li>signature of <code>objects_are_equal/allclose</code></li> <li><code>objects_are_equal</code></li> <li>The equality mechanism was fully redesigned in <code>coola</code> 0.3.</li> </ul>"},{"location":"upgrade/0.3/#objects_are_equalallclose","title":"<code>objects_are_equal/allclose</code>","text":"<p>The signature of the <code>objects_are_equal</code> and <code>objects_are_allclose</code> function were updated and only the first two arguments can be provided as positional arguments. All the other arguments had to be provided as keyword arguments. Both functions take a <code>BaseEqualityTester</code> as <code>tester</code> argument.</p>"},{"location":"upgrade/0.3/#objects_are_equal","title":"<code>objects_are_equal</code>","text":"<p><code>coola</code> 0.3 also introduces a new parameter <code>equal_nan</code> to <code>objects_are_equal</code> to indicate whether to compare NaN\u2019s as equal. To keep the behavior similar as <code>coola</code> 0.2, the default value of <code>equal_nan</code> is <code>False</code>.</p> coola 0.2 (old)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> coola 0.3 (new)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre>"},{"location":"upgrade/0.3/#equality-mechanism","title":"Equality mechanism","text":"<p>The equality mechanism was fully redesigned in <code>coola</code> 0.3 to merge the two existing equality mechanisms. In <code>coola</code> 0.2, there were two equality mechanisms:</p> <ul> <li>a mechanism to check if two objects are equal (mechanism behind <code>objects_are_equal</code>)</li> <li>a mechanism to check if two objects are equal within tolerance (mechanism   behind <code>objects_are_allclose</code>)</li> </ul> <p>This approach was not scalable because there were a lot of overlap and duplicate code between the two mechanisms. For each new type to support, it was necessary to implement two comparators: one inheriting from <code>BaseEqualityOperator</code> and another one inheriting from <code>BaseAllCloseOperator</code>. In the long term, fusing the two mechanisms will make the code easier to maintain and extend. The new equality mechanism combines two previous equality mechanisms in a single equality mechanism so it is necessary to implement only a single comparator for each type.</p> <p><code>BaseEqualityOperator</code> has a new interface which is similar but not directly compatible with the old interface. The new interface introduces a new data structure <code>EqualityConfig</code> to keep the interface simpler and to make the fusion easier. <code>EqualityConfig</code> stores all the parameters that controls the equality mechanism, like the absolute or relative tolerance thresholds. Below is a simplified version of the interface. Please check the code to see all the details.</p> coola 0.3 (new interface)<pre><code>from abc import ABC, abstractmethod\nfrom typing import Any, Generic, TypeVar\n\nfrom coola.equality.config import EqualityConfig\n\nT = TypeVar(\"T\")\n\n\nclass BaseEqualityComparator(ABC, Generic[T]):\n    @abstractmethod\n    def equal(self, object1: T, object2: Any, config: EqualityConfig) -&gt; bool:\n        pass\n</code></pre> <p>Note that in most of the cases, it will not be necessary to change the overall logic inside the <code>equal</code> method.</p> <p>The redesign of the equality mechanism introduces the following main changes:</p> <ul> <li>The class <code>BaseAllCloseOperator</code> has been removed as well as all its child classes.</li> <li><code>coola.comparators</code> has been removed and an equivalent package has been   added <code>coola.equality.comparators</code>. Please note that <code>coola.equality.comparators</code> is not a direct   replacement of <code>coola.comparators</code> because <code>BaseEqualityOperator</code> has new interface.</li> <li><code>coola.testers</code> has been removed and an equivalent package has been   added <code>coola.equality.testers</code>. Please note that <code>coola.equality.testers</code> is not a direct   replacement of <code>coola.testers</code> because <code>BaseEqualityOperator</code> has new interface.</li> </ul>"}]}