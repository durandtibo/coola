{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>coola</code> is a Python library that provides simple functions to check in a single line if two complex/nested objects are equal or not. <code>coola</code> was initially designed to work with PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>, but it is possible to extend it to support other data structures.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have the following dictionaries that contain both a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>. You want to check if the two dictionaries are equal or not. By default, Python does not provide an easy way to check if the two dictionaries are equal or not. It is not possible to use the default equality operator <code>==</code> because it will raise an error. The <code>coola</code> library was developed to fill this gap. <code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p><code>coola</code> also provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-6)\nFalse\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>coola</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>coola</code> to a new version will possibly break any code that was using the old version of <code>coola</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>coola</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"customization/","title":"Customization","text":"<p>Both <code>objects_are_equal</code> and <code>objects_are_allclose</code> functions can be easily customized.</p>"},{"location":"customization/#how-to-implement-a-custom-baseequalitytester","title":"How to implement a custom <code>BaseEqualityTester</code>","text":"<p>Internally, the <code>objects_are_equal</code> function uses a <code>BaseEqualityTester</code> object to check if two objects are equal. <code>coola</code> comes with a default <code>BaseEqualityTester</code> named <code>EqualityTester</code>, but it is possible to implement a custom <code>BaseEqualityTester</code> to check if two objects are equal. The following example shows how to use a custom <code>BaseEqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import BaseEqualityTester\n&gt;&gt;&gt; class MyCustomEqualityTester(BaseEqualityTester):\n...     def equal(self, actual: Any, expected: Any, config: EqualityConfig) -&gt; bool:\n...         return actual is expected\n...\n&gt;&gt;&gt; objects_are_equal([1, 2, 3], (1, 2, 3), tester=MyCustomEqualityTester())\nFalse\n</code></pre> <p>Implementing a new <code>BaseEqualityTester</code> allows to customize the behavior of <code>objects_are_equal</code>.</p>"},{"location":"customization/#how-to-customize-equalitytester","title":"How to customize <code>EqualityTester</code>","text":"<p>Implementing a new <code>BaseEqualityTester</code> can be a lot of work, so it is not always a practical solution. For example if you want to support a new type, you do not want to reimplement everything. Instead of implementing a new <code>BaseEqualityTester</code>, it is possible to customize the default <code>EqualityTester</code>.</p>"},{"location":"customization/#overview","title":"Overview","text":"<p><code>EqualityTester</code> has a registry of equality comparators with their associated types. An equality comparator is an object that follows the <code>BaseEqualityComparator</code> interface. <code>EqualityTester</code> uses the Method Resolution Order (MRO) of the first object to find the equality comparator to use. It uses the most specific equality comparator. For example, <code>EqualityTester</code> has an equality comparator registered for <code>object</code> and another one <code>list</code>. If the first element to compare is a <code>list</code>, <code>EqualityTester</code> will use the equality comparator associated to <code>list</code> to compare the two objects. You can use the following code to see the registered equality comparators with their associated types.</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.registry\n{&lt;class 'object'&gt;: DefaultEqualityComparator(),\n &lt;class 'collections.abc.Mapping'&gt;: MappingEqualityComparator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityComparator(),\n &lt;class 'collections.deque'&gt;: SequenceEqualityComparator(),\n &lt;class 'dict'&gt;: MappingEqualityComparator(),\n &lt;class 'list'&gt;: SequenceEqualityComparator(),\n &lt;class 'tuple'&gt;: SequenceEqualityComparator(),\n ...}\n</code></pre> <p>An equality comparator (<code>DefaultEqualityOperator</code>) is registered for <code>object</code> type, so this equality comparator is considered like the default equality comparator. For example, it will be used to compare <code>int</code> or <code>float</code> or <code>str</code> because there is no specific equality comparator for these types. Note that the same equality comparator can be used for multiple types. For example, by default, the same equality comparator is used for <code>list</code>, <code>tuple</code>, and <code>collections.abc.Sequence</code>. The following sections explain how to customize this registry.</p>"},{"location":"customization/#add-an-equality-comparator","title":"Add an equality comparator","text":"<p>It is possible to add a new equality comparator to the <code>EqualityTester</code>. The following example shows how to define a new behavior for strings. Instead of checking if two strings are the same (default behavior), the new behavior is that two strings are equal if the first string is a part of the second string. It is a two-steps process to add a new equality comparator to <code>EqualityTester</code>. First, you need to implement a new <code>BaseEqualityComparator</code> with the expected behavior for the specific type (<code>str</code> for this example). Then, you need to add the <code>BaseEqualityComparator</code> to <code>EqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; from coola.equality.comparators import BaseEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import BaseEqualityTester, EqualityTester\n&gt;&gt;&gt; # Step 1: implementation of a new equality comparator\n&gt;&gt;&gt; class MyCustomStrEqualityOperator(BaseEqualityComparator):\n...     def clone(self) -&gt; \"MyCustomStrEqualityOperator\":\n...         return self.__class__()\n...\n...     def equal(self, actual: str, expected: Any, config: EqualityConfig) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return actual in expected\n...\n&gt;&gt;&gt; # Step 2: add the new equality comparator to EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, MyCustomStrEqualityOperator())\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcde\", tester=tester)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"cba\", tester=tester)\nFalse\n&gt;&gt;&gt; tester.registry[str]\nMyCustomStrEqualityOperator()\n</code></pre> <p>Once registered, the new equality comparator is used automatically when you use the <code>objects_are_equal</code> function. You can use the <code>registry</code> attribute to check the registered equality comparators. You should see the new added equality comparator (last line for this example).</p>"},{"location":"customization/#update-the-equality-comparator-for-a-given-type","title":"Update the equality comparator for a given type","text":"<p>The previous section explains how to add a new equality comparator to <code>EqualityTester</code>. This section explains how to update the equality comparator for a specific type. To update an equality comparator for a given type, you need to add the argument <code>exist_ok=True</code> when the new equality comparator is added.</p> <pre><code>&gt;&gt;&gt; from collections.abc import Mapping\n&gt;&gt;&gt; from coola.equality.comparators import BaseEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyCustomMappingEqualityComparator(BaseEqualityComparator):\n...     def clone(self) -&gt; \"MyCustomMappingEqualityComparator\":\n...         return self.__class__()\n...\n...     def equal(self, actual: Mapping, expected: Any, config: EqualityConfig) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return actual is expected\n...\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(\n...     Mapping,\n...     MyCustomMappingEqualityComparator(),\n...     exist_ok=True,\n... )\n&gt;&gt;&gt; tester.registry[Mapping]\nMyCustomMappingEqualityComparator()\n</code></pre>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install coola\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>coola</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'coola[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install coola numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>coola</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/coola.git\n</code></pre> <p>It is recommended to create a Python 3.9+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate coola\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>coola</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"get_started/#testing","title":"Testing","text":"<p>The last version of <code>coola</code> is tested for the following package versions:</p> package tested versions <code>jax</code> <code>&gt;=0.4,&lt;0.5</code> <code>numpy</code> <code>&gt;=1.21,&lt;1.27</code> <code>pandas</code> <code>&gt;=1.3,&lt;2.3</code> <code>polars</code> <code>&gt;=0.18.3,&lt;0.21</code> <code>torch</code> <code>&gt;=1.10,&lt;2.3</code> <code>xarray</code> <code>&gt;=2023.2,&lt;2024.3</code> <ul> <li>More information can be found in the CI workflow configuration.</li> <li><code>coola</code> relies on the semantic versioning (SemVer) of the packages to test the range of versions.</li> <li><code>xarray</code> uses calendar versioning (CalVer) and <code>coola</code> is tested on the   versions for the last year.</li> </ul>"},{"location":"quickstart/","title":"coola quickstart","text":"<p> This page is a quick overview of the two main functions of <code>coola</code>: <code>objects_are_equal</code> and <code>objects_are_allclose</code>. These functions can be used to check if two complex/nested objects are equal or not. The motivation of the library is explained here. You should read this page if you want to learn how to use these functions. This page does not explain the internal behavior of these functions.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial. It is highly recommended to know a bit of NumPy or PyTorch.</p>"},{"location":"quickstart/#equal-or-not","title":"Equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not. It also works for simple objects like integer or string.</p>"},{"location":"quickstart/#first-example","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_equal</code> function. The objects to compare are dictionaries containing a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nTrue\n</code></pre> <p>In one line, it is possible to check two complex/nested objects are equal or not. Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function can check if two dictionaries containing PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>s are equal or not.</p>"},{"location":"quickstart/#finding-a-difference","title":"Finding a difference","text":"<p>When the objects are complex or nested, it is not obvious to know which elements are different. This function has an argument <code>show_difference</code> which shows the first difference found between the two objects. For example if you add <code>show_difference=True</code> when you compare the <code>data1</code> and <code>data2</code>, you will see at least one element that is different:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Log output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nactual=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nexpected=\ntensor([[0., 0., 0.],\n        [0., 0., 0.]])\nINFO:coola.comparators.equality:The mappings have a different value for the key 'torch':\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[0., 0., 0.],\n        [0., 0., 0.]]), 'numpy': array([[1., 1., 1.],\n       [1., 1., 1.]])}\n</code></pre> <p>If you do not see this output, you may need to configure <code>logging</code> to show the <code>INFO</code> level (something like <code>logging.basicConfig(level=logging.INFO)</code>). The log shows a difference between <code>data1</code> and <code>data2</code>: the PyTorch <code>Tensor</code>s in key <code>'torch'</code> of the input dictionaries. The top of the log shows the element that fails the check, and then it shows the parent element, so it is easy to know where is the identified difference. Note that it only shows the first difference, not all the differences. Two objects are different if any of these elements are different. In the previous example, only the difference for key <code>'torch'</code> is shown in the log. No log is shown if the two objects are equal and <code>show_difference=True</code>.</p>"},{"location":"quickstart/#more-examples","title":"More examples","text":"<p>The previous examples use dictionary, but it is possible to use other types like list or tuple</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = [torch.ones(2, 3), numpy.zeros((2, 3))]\n&gt;&gt;&gt; data2 = [torch.zeros(2, 3), numpy.ones((2, 3))]\n&gt;&gt;&gt; data3 = (torch.ones(2, 3), numpy.zeros((2, 3)))\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>It is also possible to test more complex objects</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abcd\"},\n...     \"int\": 1,\n... }\n...\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p>Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"quickstart/#strict-type-checking","title":"Strict type checking","text":"<p> Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function requires two objects to be of the same type to be equal. For example, <code>1</code> (integer) is considered different from <code>1.0</code> (float) or <code>True</code> (boolean) which is different behavior that the native python equality operator <code>==</code>. You can take a look to the following example to see some differences.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, True)\nFalse\n&gt;&gt;&gt; 1 == 1\nTrue\n&gt;&gt;&gt; 1 == 1.0\nTrue\n&gt;&gt;&gt; 1 == True\nTrue\n</code></pre> <p>Similarly, the <code>objects_are_equal</code> function considers a <code>dict</code> and <code>collections.OrderedDict</code> as different objects even if they have the same keys and values.</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"key1\": 1, \"key2\": \"abc\"}, OrderedDict({\"key1\": 1, \"key2\": \"abc\"}))\nFalse\n&gt;&gt;&gt; {\"key1\": 1, \"key2\": \"abc\"} == OrderedDict({\"key1\": 1, \"key2\": \"abc\"})\nTrue\n</code></pre>"},{"location":"quickstart/#almost-equal-or-not","title":"Almost equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not. Due to numerical precision, it happens quite often that two numbers are not equal but the error is very tiny (<code>1.0</code> and <code>1.000000001</code>). The tolerance is mostly useful for numerical values. For a lot of types like string, the <code>objects_are_allclose</code> function behaves like the <code>objects_are_equal</code> function.</p>"},{"location":"quickstart/#first-example_1","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_allclose</code> function. The objects to compare are dictionaries containing a PyTorch Tensor and a NumPy ndarray.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose, objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3) + 1e-9, \"numpy\": numpy.zeros((2, 3)) - 1e-9}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data3)\nTrue\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>The difference between <code>data1</code> and <code>data2</code> is large so <code>objects_are_allclose</code> returns false like <code>objects_are_equal</code>. The difference between <code>data1</code> and <code>data3</code> is tiny so <code>objects_are_allclose</code> returns true, whereas <code>objects_are_equal</code> returns false.</p>"},{"location":"quickstart/#tolerance","title":"Tolerance","text":"<p>It is possible to control the tolerance with the arguments <code>atol</code> and <code>rtol</code>. <code>atol</code> controls the absolute tolerance and <code>rtol</code> controls the relative tolerance.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-3)\nTrue\n</code></pre> <p><code>objects_are_equal</code> and <code>objects_are_allclose</code> are very similar and should behave the same when <code>atol=0.0</code> and <code>rtol=0.0</code>.</p>"},{"location":"quickstart/#finding-a-difference_1","title":"Finding a difference","text":"<p>Like <code>objects_are_equal</code>, the <code>objects_are_allclose</code> function has an argument <code>show_difference</code> which shows the first difference found between the two objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nactual=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nexpected=\ntensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]])\nINFO:coola.comparators.allclose:The mappings have a different value for the key torch:\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]]), 'numpy': array([[-0.0001, -0.0001, -0.0001],\n       [-0.0001, -0.0001, -0.0001]])}\n</code></pre>"},{"location":"quickstart/#more-examples_1","title":"More examples","text":"<p>Like the <code>objects_are_equal</code> function, the <code>objects_are_allclose</code> function can be used with complex/nested objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3)) + 1e-9],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nTrue\n</code></pre> <p><code>objects_are_allclose</code> supports a lot of types and nested structure. Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"quickstart/#not-a-number-nan","title":"Not A Number (NaN)","text":"<p>By default, <code>NaN</code> is not considered close to any other value, including <code>NaN</code>.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), 0.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> <p>By setting <code>equal_nan=True</code>, it is possible to change the above behavior and <code>NaN</code>s will be considered equal.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre> <p>In arrays or tensors, <code>NaN</code> are sometimes to indicate some values are not valid. However, it may be interested to check if the non-<code>NaN</code> values are equal. It is possible to use the <code>equal_nan=True</code> option to compare two tensors with <code>NaN</code> values.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n</code></pre> <p>Output:</p> <pre><code>False\nTrue\nFalse\nTrue\n</code></pre>"},{"location":"quickstart/#connection-with-similar-tools","title":"Connection with similar tools","text":"<p><code>coola</code> is not the first tool to provide functions to compare nested objects. If you are a PyTorch user, you probably know the <code>torch.testing.assert_close</code> function. If you are a NumPy user, you probably know the <code>numpy.testing.assert_equal</code> function. However, most of these functions work in a fix scope and are difficult to extend or customize. On the opposite side, <code>coola</code> is flexible and easy to customize.</p> <p>Let's take a look to <code>torch</code>. <code>torch.testing.assert_close</code> allows to easily compare <code>torch.Tensor</code>s objects:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(torch.ones(2, 3), torch.ones(2, 3))\n</code></pre> <p>It can also be used on mappings or sequences:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(\n...     [torch.ones(2, 3), torch.zeros(3)],\n...     [torch.ones(2, 3), torch.zeros(3)],\n... )\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3)},\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3)},\n... )\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {'key1': torch.ones(2, 3), 'key2': {'key3': torch.zeros(3), 'key4': [torch.arange(5)]}},\n...     {'key1': torch.ones(2, 3), 'key2': {'key3': torch.zeros(3), 'key4': [torch.arange(5)]}},\n... )\n</code></pre> <p>It also works on tensor like objects like NumPy arrays:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; torch.testing.assert_close(\n...     [torch.ones(2, 3), np.zeros(3)],\n...     [torch.ones(2, 3), np.zeros(3)],\n... )\n&gt;&gt;&gt; torch.testing.assert_close([torch.ones(2, 3), 42], [torch.ones(2, 3), 42])\n</code></pre> <p>However, it does not work if the data structure contains a string:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3), \"key3\": \"abc\"},\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3), \"key3\": \"abc\"},\n... )\nTraceback (most recent call last):\n...\nTypeError: No comparison pair was able to handle inputs of type &lt;class 'str'&gt; and &lt;class 'str'&gt;.\nThe failure occurred for item ['key3']\n</code></pre> <p><code>coola</code> can compare these objects:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import coola\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3), \"key3\": \"abc\"},\n...     {'key1': torch.ones(2, 3), 'key2': torch.zeros(3), \"key3\": \"abc\"},\n... )\nTrue\n</code></pre> <p>Internally, <code>torch.testing.assert_close</code> tries to convert some values to tensors to compare them, which can lead to surprising results like:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close((1, 2, 3), [1, 2, 3])\n</code></pre> <p>The inputs have different types: the left input is a tuple, whereas the right is a list. <code>coola</code> has a strict type checking and will indicate the two inputs are different:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import coola\n&gt;&gt;&gt; coola.objects_are_equal((1, 2, 3), [1, 2, 3])\nFalse\n</code></pre> <p><code>numpy.testing.assert_equal</code> has different limitations. For example, it can work with strings but can handle only simple sequence and mapping objects</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; np.testing.assert_equal(\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3)},\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3)},\n... )\n&gt;&gt;&gt; np.testing.assert_equal(\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3), \"key3\": \"abc\"},\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3), \"key3\": \"abc\"},\n... )\n&gt;&gt;&gt; np.testing.assert_equal(\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n... )\nTraceback (most recent call last):\n...\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n</code></pre> <p><code>coola</code> can compare these objects:</p> <pre><code>&gt;&gt;&gt; import coola\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3)},\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3)},\n... )\nTrue\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3), \"key3\": \"abc\"},\n...     {'key1': np.ones((2, 3)), 'key2': np.zeros(3), \"key3\": \"abc\"},\n... )\nTrue\n&gt;&gt;&gt; coola.objects_are_equal(\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n... )\nTrue\n</code></pre>"},{"location":"types/","title":"Supported Types","text":"<p> This page describes what types are currently supported and what rules are used to check if two objects are equal or not.</p> <p>The current supported types are:</p> <ul> <li><code>jax.numpy.ndarray</code></li> <li><code>numpy.ndarray</code></li> <li><code>numpy.ma.MaskedArray</code></li> <li><code>pandas.DataFrame</code></li> <li><code>pandas.Series</code></li> <li><code>polars.DataFrame</code></li> <li><code>polars.Series</code></li> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> <li><code>xarray.Variable</code></li> </ul>"},{"location":"types/#equal","title":"Equal","text":""},{"location":"types/#object","title":"<code>object</code>","text":"<p>By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>actual == expected</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(True, True)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"types/#collectionsabcmapping-dict","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal. The value associated to the key <code>k</code> in the first mapping has   to be equal to value associated to the key <code>k</code> in the second mapping.</li> </ul> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"types/#collectionsabcsequence-list-tuple","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal. The <code>i</code>-th element in the first sequence has to be   equal to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"types/#pytorch","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"types/#torchtensor","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>tensor1.equal(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"types/#torchnnutilsrnnpackedsequence","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal if:</p> <ul> <li>The <code>data</code> attributes are equal</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"types/#numpyndarray","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>numpy.array_equal(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"types/#xarray","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"types/#xarraydataarray","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal if:</p> <ul> <li>they have the same data values (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"]))\nTrue\n&gt;&gt;&gt; objects_are_equal(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"]))\nFalse\n</code></pre>"},{"location":"types/#xarraydataset","title":"<code>xarray.Dataset</code>","text":"<p>Two xarray <code>Dataset</code>s are equal if <code>xarray.Dataset.identical</code> returns <code>True</code>. In contrast to the standard usage in numpy, NaNs are compared like numbers, two <code>Dataset</code>s are equal if both objects have NaNs in the same positions.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; ds1 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds2 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds3 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1},\n... )\n&gt;&gt;&gt; objects_are_equal(ds1, ds2)\nTrue\n&gt;&gt;&gt; objects_are_equal(ds1, ds3)\nFalse\n</code></pre>"},{"location":"types/#equal-within-a-tolerance-allclose","title":"Equal within a tolerance (allclose)","text":""},{"location":"types/#object_1","title":"<code>object</code>","text":"<p>The concept of equal within a tolerance does not make sense for all <code>object</code>s. In general, the tolerance is not used for <code>object</code>s. The tolerance is only used for numbers (see below). By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>actual == expected</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abc\")\nTrue\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"types/#numbers-bool-int-float","title":"Numbers: <code>bool</code> | <code>int</code> | <code>float</code>","text":"<p>Two numbers are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>the values are equal with a tolerance</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1, 2, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2.0, atol=1)\nFalse\n</code></pre> <p>Note that booleans are explicitly considered as integers in Python so the tolerance can be used with booleans:</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(True, False)\nFalse\n&gt;&gt;&gt; objects_are_allclose(True, False, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(True, False, rtol=1)\nTrue\n</code></pre>"},{"location":"types/#collectionsabcmapping-dict_1","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal within a tolerance. The value associated to the key <code>k</code> in the   first mapping has to be equal within the tolerance to value associated to the key <code>k</code> in the   second mapping.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"types/#collectionsabcsequence-list-tuple_1","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal within a tolerance. The <code>i</code>-th element in the first   sequence has to be equal within a tolerance to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"types/#pytorch_1","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal within a tolerance or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"types/#torchtensor_1","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>tensor1.allclose(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"types/#torchnnutilsrnnpackedsequence_1","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal within a tolerance if:</p> <ul> <li>The <code>data</code> attributes are equal within a tolerance</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float() + 1,\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     atol=2,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"types/#numpyndarray_1","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>numpy.allclose(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"types/#xarray_1","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"types/#xarraydataarray_1","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data values within the tolerance (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"]))\nTrue\n&gt;&gt;&gt; objects_are_allclose(xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"]))\nFalse\n</code></pre>"},{"location":"refs/","title":"Main functions","text":""},{"location":"refs/#comparison","title":"Comparison","text":""},{"location":"refs/#coola.objects_are_allclose","title":"coola.objects_are_allclose","text":"<pre><code>objects_are_allclose(\n    actual: Any,\n    expected: Any,\n    *,\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>The equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are (element-wise) equal within a tolerance, otherwise <code>False</code></p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.ones(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3) + 1e-7, torch.ones(2)],\n...     [torch.ones(2, 3), torch.ones(2) - 1e-7],\n...     rtol=0,\n...     atol=1e-8,\n... )\nFalse\n</code></pre>"},{"location":"refs/#coola.objects_are_equal","title":"coola.objects_are_equal","text":"<pre><code>objects_are_equal(\n    actual: Any,\n    expected: Any,\n    *,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>The equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two nested data are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal([torch.ones(2, 3), torch.ones(2)], [torch.ones(2, 3), torch.zeros(2)])\nFalse\n</code></pre>"},{"location":"refs/#summary","title":"Summary","text":""},{"location":"refs/#coola.summary","title":"coola.summary","text":"<pre><code>summary(\n    value: Any,\n    max_depth: int = 1,\n    summarizer: BaseSummarizer | None = None,\n) -&gt; str\n</code></pre> <p>Summarize the input value in a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to summarize.</p> required <code>max_depth</code> <code>int</code> <p>The maximum depth to summarize if the input is nested.</p> <code>1</code> <code>summarizer</code> <code>BaseSummarizer | None</code> <p>The summarization strategy. If <code>None</code>, the default <code>Summarizer</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The summary as a string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summary\n&gt;&gt;&gt; print(summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/#coola.summarizer_options","title":"coola.summarizer_options","text":"<pre><code>summarizer_options(**kwargs: Any) -&gt; None\n</code></pre> <p>Context manager that temporarily changes the summarizer options.</p> <p>Accepted arguments are same as <code>set_summarizer_options</code>. The context manager temporary change the configuration of <code>Summarizer</code>. This context manager has no effect if <code>Summarizer</code> is not used.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Accepted arguments are same as <code>set_summarizer_options</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; with summarizer_options(max_characters=10):\n...     print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n...\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/#coola.set_summarizer_options","title":"coola.set_summarizer_options","text":"<pre><code>set_summarizer_options(\n    max_characters: int | None = None,\n    max_items: int | None = None,\n    num_spaces: int | None = None,\n) -&gt; None\n</code></pre> <p>Set the <code>Summarizer</code> options.</p> <p>Note: It is recommended to use <code>summarizer_options</code> rather than this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int | None</code> <p>The maximum number of characters to show. If <code>None</code>, the maximum number of characters is unchanged.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>The maximum number of items to show. If <code>None</code>, the maximum number of items is unchanged.</p> <code>None</code> <code>num_spaces</code> <code>int | None</code> <p>The number of spaces for indentation. If <code>None</code>, the number of  spaces for indentation is unchanged.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import set_summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; set_summarizer_options(max_characters=10)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; set_summarizer_options(max_characters=-1)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/equality/","title":"Equality","text":""},{"location":"refs/equality/#coola.equality.comparators","title":"coola.equality.comparators","text":"<p>Contain the comparators to check if two objects are equal or not.</p>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator","title":"coola.equality.comparators.BaseEqualityComparator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement an equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator.clone","title":"coola.equality.comparators.BaseEqualityComparator.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseEqualityComparator\n</code></pre> <p>Return a copy of the equality operator.</p> <p>Returns:</p> Type Description <code>BaseEqualityComparator</code> <p>A copy of the equality operator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; op = DefaultEqualityComparator()\n&gt;&gt;&gt; op_cloned = op.clone()\n&gt;&gt;&gt; op_cloned\nDefaultEqualityComparator()\n&gt;&gt;&gt; op is op_cloned\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator.equal","title":"coola.equality.comparators.BaseEqualityComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: T, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>T</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.DefaultEqualityComparator","title":"coola.equality.comparators.DefaultEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Any]</code></p> <p>Implement a default equality comparator.</p> <p>The <code>==</code> operator is used to test the equality between the objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.JaxArrayEqualityComparator","title":"coola.equality.comparators.JaxArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[ndarray]</code></p> <p>Implement an equality comparator for <code>jax.numpy.ndarray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import JaxArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = JaxArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(jnp.ones((2, 3)), jnp.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; comparator.equal(jnp.ones((2, 3)), jnp.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.MappingEqualityComparator","title":"coola.equality.comparators.MappingEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Mapping]</code></p> <p>Implement a sequence equality comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import MappingEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = MappingEqualityComparator()\n&gt;&gt;&gt; comparator.equal({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2}, config)\nTrue\n&gt;&gt;&gt; comparator.equal({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 4}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.NumpyArrayEqualityComparator","title":"coola.equality.comparators.NumpyArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[ndarray]</code></p> <p>Implement an equality comparator for <code>numpy.ndarray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import NumpyArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = NumpyArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; comparator.equal(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.NumpyMaskedArrayEqualityComparator","title":"coola.equality.comparators.NumpyMaskedArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[MaskedArray]</code></p> <p>Implement an equality comparator for <code>numpy.ndarray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import NumpyMaskedArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = NumpyMaskedArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]), np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]), config,)\nTrue\n&gt;&gt;&gt; comparator.equal(np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]), np.ma.array(data=[0.0, 1.0, 2.0], mask=[0, 1, 0]), config,)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PandasDataFrameEqualityComparator","title":"coola.equality.comparators.PandasDataFrameEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataFrame]</code></p> <p>Implement an equality comparator for <code>pandas.DataFrame</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PandasDataFrameEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PandasDataFrameEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     pd.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PandasSeriesEqualityComparator","title":"coola.equality.comparators.PandasSeriesEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Series]</code></p> <p>Implement an equality comparator for <code>pandas.Series</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PandasSeriesEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PandasSeriesEqualityComparator()\n&gt;&gt;&gt; comparator.equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; comparator.equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PolarsDataFrameEqualityComparator","title":"coola.equality.comparators.PolarsDataFrameEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataFrame]</code></p> <p>Implement an equality comparator for <code>polars.DataFrame</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PolarsDataFrameEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PolarsDataFrameEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     polars.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PolarsSeriesEqualityComparator","title":"coola.equality.comparators.PolarsSeriesEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Series]</code></p> <p>Implement an equality comparator for <code>polars.Series</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PolarsSeriesEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PolarsSeriesEqualityComparator()\n&gt;&gt;&gt; comparator.equal(polars.Series([1, 2, 3]), polars.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; comparator.equal(polars.Series([1, 2, 3]), polars.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.ScalarEqualityComparator","title":"coola.equality.comparators.ScalarEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Any]</code></p> <p>Implement a default equality comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import ScalarEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = ScalarEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42.0, 42.0, config)\nTrue\n&gt;&gt;&gt; comparator.equal(42.0, 1.0, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.SequenceEqualityComparator","title":"coola.equality.comparators.SequenceEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Sequence]</code></p> <p>Implement a sequence equality comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = SequenceEqualityComparator()\n&gt;&gt;&gt; comparator.equal([1, 2, 3], [1, 2, 3], config)\nTrue\n&gt;&gt;&gt; comparator.equal([1, 2, 3], [1, 2, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.TorchPackedSequenceEqualityComparator","title":"coola.equality.comparators.TorchPackedSequenceEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[PackedSequence]</code></p> <p>Implement an equality comparator for <code>torch.Tensor</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import TorchPackedSequenceEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = TorchTensorEqualityComparator()\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.TorchTensorEqualityComparator","title":"coola.equality.comparators.TorchTensorEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Tensor]</code></p> <p>Implement an equality comparator for <code>torch.Tensor</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import TorchTensorEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = TorchTensorEqualityComparator()\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayDataArrayEqualityComparator","title":"coola.equality.comparators.XarrayDataArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataArray]</code></p> <p>Implement an equality comparator for <code>xarray.DataArray</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayDataArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayDataArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]),\n...     xr.DataArray(np.arange(6), dims=[\"z\"]),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.DataArray(np.ones(6), dims=[\"z\"]),\n...     xr.DataArray(np.zeros(6), dims=[\"z\"]),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayDatasetEqualityComparator","title":"coola.equality.comparators.XarrayDatasetEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Dataset]</code></p> <p>Implement an equality comparator for <code>xarray.Dataset</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayDatasetEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayDatasetEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.Dataset({ \"x\": xr.DataArray(np.arange(6), dims=[\"z\"])}),\n...     xr.Dataset({ \"x\": xr.DataArray(np.arange(6), dims=[\"z\"])}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.Dataset({ \"x\": xr.DataArray(np.zeros(6), dims=[\"z\"])}),\n...     xr.Dataset({ \"x\": xr.DataArray(np.ones(6), dims=[\"z\"])}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayVariableEqualityComparator","title":"coola.equality.comparators.XarrayVariableEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Variable]</code></p> <p>Implement an equality comparator for <code>xarray.Variable</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayVariableEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayVariableEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.Variable(dims=[\"z\"], data=np.zeros(6)),\n...     xr.Variable(dims=[\"z\"], data=np.ones(6)),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.get_type_comparator_mapping","title":"coola.equality.comparators.get_type_comparator_mapping","text":"<pre><code>get_type_comparator_mapping() -&gt; (\n    dict[type, BaseEqualityComparator]\n)\n</code></pre> <p>Get a default mapping between the types and the equality comparators.</p> <p>Returns:</p> Type Description <code>dict[type, BaseEqualityComparator]</code> <p>The mapping between the types and the equality comparators.</p> <pre><code>&gt;&gt;&gt; from coola.equality.comparators import get_type_comparator_mapping\n&gt;&gt;&gt; get_type_comparator_mapping()\n{&lt;class 'object'&gt;: DefaultEqualityComparator(),\n &lt;class 'collections.abc.Mapping'&gt;: MappingEqualityComparator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityComparator(), ...}\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers","title":"coola.equality.handlers","text":"<p>Contain the handlers to help to check if two objects are equal or not.</p> <p>The handlers are designed to work with Chain of Responsibility pattern.</p>"},{"location":"refs/equality/#coola.equality.handlers.AbstractEqualityHandler","title":"coola.equality.handlers.AbstractEqualityHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a base class with the default chaining behavior.</p> <p>A child class needs to implement the following method: <code>handle</code>.</p>"},{"location":"refs/equality/#coola.equality.handlers.AbstractEqualityHandler.next_handler","title":"coola.equality.handlers.AbstractEqualityHandler.next_handler  <code>property</code>","text":"<pre><code>next_handler: BaseEqualityHandler | None\n</code></pre> <p>The next handler.</p>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler","title":"coola.equality.handlers.BaseEqualityHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality handler.</p> <p>A child class needs to implement the following methods:</p> <ul> <li><code>handle</code></li> <li><code>set_next_handler</code></li> </ul> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler, FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.set_next_handler(FalseHandler())\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.chain","title":"coola.equality.handlers.BaseEqualityHandler.chain","text":"<pre><code>chain(handler: BaseEqualityHandler) -&gt; BaseEqualityHandler\n</code></pre> <p>Chain a handler to the current handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>BaseEqualityHandler</code> <p>The handler to chain.</p> required <p>Returns:</p> Type Description <code>BaseEqualityHandler</code> <p>The input handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler, SameTypeHandler, ObjectEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.chain(SameTypeHandler()).chain(ObjectEqualHandler())\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3], config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.handle","title":"coola.equality.handlers.BaseEqualityHandler.handle  <code>abstractmethod</code>","text":"<pre><code>handle(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Return the equality result between the two input objects.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input objects are equal, and <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.set_next_handler","title":"coola.equality.handlers.BaseEqualityHandler.set_next_handler  <code>abstractmethod</code>","text":"<pre><code>set_next_handler(handler: BaseEqualityHandler) -&gt; None\n</code></pre> <p>Set the next handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>BaseEqualityHandler</code> <p>The next handler.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler, TrueHandler\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.set_next_handler(TrueHandler())\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.EqualHandler","title":"coola.equality.handlers.EqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects are different data, otherwise it returns <code>True</code>. The first object must have a <code>equal</code> attribute which indicates if the two objects are equal or not.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import EqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyFloat:\n...     def __init__(self, value: float) -&gt; None:\n...         self._value = value\n...     def equal(self, other: float) -&gt; bool:\n...         return self._value == other\n...\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = EqualHandler()\n&gt;&gt;&gt; handler.handle(MyFloat(42), 42, config)\nTrue\n&gt;&gt;&gt; handler.handle(MyFloat(42), float(\"nan\"), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.EqualNanHandler","title":"coola.equality.handlers.EqualNanHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects are different data, otherwise it returns <code>True</code>. The first object must have a <code>equal</code> attribute which indicates if the two objects are equal or not.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import EqualNanHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyFloat:\n...     def __init__(self, value: float) -&gt; None:\n...         self._value = value\n...     def equal(self, other: float, equal_nan: bool = False) -&gt; bool:\n...         if equal_nan and math.isnan(self._value) and math.isnan(other):\n...             return True\n...         return self._value == other\n...\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = EqualNanHandler()\n&gt;&gt;&gt; handler.handle(MyFloat(42), 42, config)\nTrue\n&gt;&gt;&gt; handler.handle(MyFloat(float(\"nan\")), float(\"nan\"), config)\nFalse\n&gt;&gt;&gt; config.equal_nan = True\n&gt;&gt;&gt; handler.handle(MyFloat(float(\"nan\")), float(\"nan\"), config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.FalseHandler","title":"coola.equality.handlers.FalseHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a handler that always return <code>False</code>.</p> <p>This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = FalseHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nFalse\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.JaxArrayEqualHandler","title":"coola.equality.handlers.JaxArrayEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two JAX arrays are equal.</p> <p>This handler returns <code>True</code> if the two arrays are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import JaxArrayEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = JaxArrayEqualHandler()\n&gt;&gt;&gt; handler.handle(jnp.ones((2, 3)), jnp.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(jnp.ones((2, 3)), jnp.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.MappingSameKeysHandler","title":"coola.equality.handlers.MappingSameKeysHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same keys.</p> <p>This handler returns <code>False</code> if the two objects have different keys, otherwise it passes the inputs to the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import MappingSameKeysHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = MappingSameKeysHandler()\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2, \"c\": 1}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.MappingSameValuesHandler","title":"coola.equality.handlers.MappingSameValuesHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the key-value pairs in the first mapping are in the second mapping.</p> <p>This handler returns <code>False</code> if the one of the key-value pair in the first mapping is not in the second mapping, otherwise it passes the inputs to the next handler.</p> Notes <p>This handler assumes that all the keys in the first mapping are also in the second mapping. The second mapping can have more keys. To check if two mappings are equal, you can combine this handler with <code>MappingSameKeysHandler</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import MappingSameValuesHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = MappingSameValuesHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2}, config)\nTrue\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 3}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.NanEqualHandler","title":"coola.equality.handlers.NanEqualHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two NaNs are equal.</p> <p>This handler returns <code>True</code> if the two numbers are NaNs, otherwise it passes the inputs to the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import NanEqualHandler, FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = NanEqualHandler(next_handler=FalseHandler())\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nFalse\n&gt;&gt;&gt; config.equal_nan = True\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.NumpyArrayEqualHandler","title":"coola.equality.handlers.NumpyArrayEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two NumPy arrays are equal.</p> <p>This handler returns <code>True</code> if the two arrays are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import NumpyArrayEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = NumpyArrayEqualHandler()\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.ObjectEqualHandler","title":"coola.equality.handlers.ObjectEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects are equal using the default equality operator <code>==</code>.</p> <p>This handler returns <code>True</code> if the two objects are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import ObjectEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = ObjectEqualHandler()\n&gt;&gt;&gt; handler.handle(1, 1, config)\nTrue\n&gt;&gt;&gt; handler.handle(1, \"abc\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PandasDataFrameEqualHandler","title":"coola.equality.handlers.PandasDataFrameEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>pandas.DataFrame</code> are equal.</p> <p>This handler returns <code>True</code> if the two <code>pandas.DataFrame</code>s equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PandasDataFrameEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PandasDataFrameEqualHandler()\n&gt;&gt;&gt; handler.handle(\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; handler.handle(\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     pandas.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PandasSeriesEqualHandler","title":"coola.equality.handlers.PandasSeriesEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>pandas.Series</code> are equal.</p> <p>This handler returns <code>True</code> if the two arrays <code>pandas.Series</code> equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PandasSeriesEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PandasSeriesEqualHandler()\n&gt;&gt;&gt; handler.handle(pandas.Series([1, 2, 3]), pandas.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; handler.handle(pandas.Series([1, 2, 3]), pandas.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PolarsDataFrameEqualHandler","title":"coola.equality.handlers.PolarsDataFrameEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>polars.DataFrame</code> are equal.</p> <p>This handler returns <code>True</code> if the two <code>polars.DataFrame</code>s equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PolarsDataFrameEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PolarsDataFrameEqualHandler()\n&gt;&gt;&gt; handler.handle(\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; handler.handle(\n...     polars.DataFrame({\"col\": [1, 2, 3]}),\n...     polars.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PolarsSeriesEqualHandler","title":"coola.equality.handlers.PolarsSeriesEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>polars.Series</code> are equal.</p> <p>This handler returns <code>True</code> if the two arrays <code>polars.Series</code> equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PolarsSeriesEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PolarsSeriesEqualHandler()\n&gt;&gt;&gt; handler.handle(polars.Series([1, 2, 3]), polars.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; handler.handle(polars.Series([1, 2, 3]), polars.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameAttributeHandler","title":"coola.equality.handlers.SameAttributeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same attribute.</p> <p>This handler returns <code>False</code> if the two objects have different attributes, otherwise it passes the inputs to the next handler. The objects must have the attribute.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameAttributeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameAttributeHandler(name=\"shape\", next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((3, 2)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameDTypeHandler","title":"coola.equality.handlers.SameDTypeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same data type.</p> <p>This handler returns <code>False</code> if the two objects have different data types, otherwise it passes the inputs to the next handler. The objects must have a <code>dtype</code> attribute (e.g. <code>object.dtype</code>) which returns the shape of the object. This handler works on <code>numpy.ndarray</code>s and <code>torch.Tensor</code>s objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameDTypeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameDTypeHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3), dtype=float), np.ones((2, 3), dtype=int), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameDataHandler","title":"coola.equality.handlers.SameDataHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects have different data, otherwise it passes the inputs to the next handler. The objects must have a <code>data</code> attribute (e.g. <code>object.data</code>) which returns the shape of the object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameDataHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameDataHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameLengthHandler","title":"coola.equality.handlers.SameLengthHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same length.</p> <p>This handler returns <code>False</code> if the two objects have different lengths, otherwise it passes the inputs to the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameLengthHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameLengthHandler()\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameObjectHandler","title":"coola.equality.handlers.SameObjectHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects refer to the same object.</p> <p>This handler returns <code>True</code> if the two objects refer to the same object, otherwise it passes the inputs to the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameShapeHandler","title":"coola.equality.handlers.SameShapeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same shape.</p> <p>This handler returns <code>False</code> if the two objects have different shapes, otherwise it passes the inputs to the next handler. The objects must have a <code>shape</code> attribute (e.g. <code>object.shape</code>) which returns the shape of the object. This handler works on <code>jax.numpy.ndarray</code>s, <code>numpy.ndarray</code>s, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> and <code>torch.Tensor</code>s objects.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameShapeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameShapeHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((3, 2)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameTypeHandler","title":"coola.equality.handlers.SameTypeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same type.</p> <p>This handler returns <code>False</code> if the two objects have different types, otherwise it passes the inputs to the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameTypeHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameTypeHandler()\n&gt;&gt;&gt; handler.handle(1, \"abc\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.ScalarEqualHandler","title":"coola.equality.handlers.ScalarEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two numbers are equal or not.</p> <p>This handler returns <code>False</code> if the two numbers are different, otherwise it returns <code>True</code>. It is possible to control the tolerance by using <code>atol</code> and <code>rtol</code>. By default, the tolerances are set to 0.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import ScalarEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = ScalarEqualHandler()\n&gt;&gt;&gt; handler.handle(42.0, 42.0, config)\nTrue\n&gt;&gt;&gt; config.atol = 1e-3\n&gt;&gt;&gt; handler.handle(42.0, 42.0001, config)\nTrue\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SequenceSameValuesHandler","title":"coola.equality.handlers.SequenceSameValuesHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two sequences have the same values.</p> <p>This handler returns <code>False</code> if the two sequences have at least one different value, otherwise it passes the inputs to the next handler. If the sequences have different length, this handler checks only the values of the shortest sequence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SequenceSameValuesHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SequenceSameValuesHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3], config)\nTrue\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.TorchTensorEqualHandler","title":"coola.equality.handlers.TorchTensorEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two tensors are equal.</p> <p>This handler returns <code>True</code> if the two tensors are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers.torch_ import TorchTensorEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = TorchTensorEqualHandler()\n&gt;&gt;&gt; handler.handle(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; handler.handle(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.TrueHandler","title":"coola.equality.handlers.TrueHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a handler that always return <code>True</code>.</p> <p>This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = TrueHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers","title":"coola.equality.testers","text":"<p>Contain the testers to check if two objects are equal or not.</p>"},{"location":"refs/equality/#coola.equality.testers.BaseEqualityTester","title":"coola.equality.testers.BaseEqualityTester","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality tester.</p>"},{"location":"refs/equality/#coola.equality.testers.BaseEqualityTester.equal","title":"coola.equality.testers.BaseEqualityTester.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; config = EqualityConfig(tester=tester)\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.zeros(2)], [np.ones((2, 3)), np.zeros(2)], config)\nTrue\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.ones(2)], [np.ones((2, 3)), np.zeros(2)], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester","title":"coola.equality.testers.EqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement the default equality tester.</p>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.add_comparator","title":"coola.equality.testers.EqualityTester.add_comparator  <code>classmethod</code>","text":"<pre><code>add_comparator(\n    data_type: type,\n    comparator: BaseEqualityComparator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a comparator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; EqualityTester.add_comparator(list, SequenceEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.find_comparator","title":"coola.equality.testers.EqualityTester.find_comparator  <code>classmethod</code>","text":"<pre><code>find_comparator(data_type: Any) -&gt; BaseEqualityComparator\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator</code> <p>The equality comparator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; EqualityTester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.has_comparator","title":"coola.equality.testers.EqualityTester.has_comparator  <code>classmethod</code>","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.has_comparator(list)\nTrue\n&gt;&gt;&gt; EqualityTester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.local_copy","title":"coola.equality.testers.EqualityTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalEqualityTester\n</code></pre> <p>Return a copy of <code>EqualityTester</code> that can easily be customized without changind <code>EqualityTester</code>.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A \"local\" copy of <code>EqualityTester</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester\nLocalEqualityTester(...)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester","title":"coola.equality.testers.LocalEqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type, BaseEqualityComparator] | None</code> <p>The initial registry with the equality comparators.</p> <code>None</code>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.add_comparator","title":"coola.equality.testers.LocalEqualityTester.add_comparator","text":"<pre><code>add_comparator(\n    data_type: type,\n    comparator: BaseEqualityComparator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an comparator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator())\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.clone","title":"coola.equality.testers.LocalEqualityTester.clone","text":"<pre><code>clone() -&gt; LocalEqualityTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A deep copy of the current tester.</p> <p>Example usage:</p> <p>```pycon</p> <p>from coola.equality.testers import EqualityTester tester = EqualityTester.local_copy() tester_cloned = tester.clone()</p> <p>```</p>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.find_comparator","title":"coola.equality.testers.LocalEqualityTester.find_comparator","text":"<pre><code>find_comparator(data_type: Any) -&gt; BaseEqualityComparator\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator</code> <p>The equality comparator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; tester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.has_comparator","title":"coola.equality.testers.LocalEqualityTester.has_comparator","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.has_comparator(list)\nTrue\n&gt;&gt;&gt; tester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/formatters/","title":"Formatters","text":""},{"location":"refs/formatters/#coola.formatters","title":"coola.formatters","text":"<p>Contain the formatter implementations.</p>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter","title":"coola.formatters.BaseFormatter","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a formatter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.clone","title":"coola.formatters.BaseFormatter.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseFormatter\n</code></pre> <p>Return a copy of the formatter.</p> <p>Returns:</p> Type Description <code>BaseFormatter</code> <p>A copy of the formatter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter2 = formatter.clone()\n&gt;&gt;&gt; formatter.set_max_characters(10)\n&gt;&gt;&gt; formatter\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; formatter2\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.equal","title":"coola.formatters.BaseFormatter.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if the other object is equal to the self object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.equal(DefaultFormatter())\nTrue\n&gt;&gt;&gt; formatter.equal(DefaultFormatter(max_characters=10))\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.format","title":"coola.formatters.BaseFormatter.format  <code>abstractmethod</code>","text":"<pre><code>format(\n    summarizer: BaseSummarizer,\n    value: T,\n    depth: int,\n    max_depth: int,\n) -&gt; str\n</code></pre> <p>Format a value.</p> <p>Parameters:</p> Name Type Description Default <code>summarizer</code> <code>BaseSummarizer</code> <p>The summarizer.</p> required <code>value</code> <code>T</code> <p>The value to summarize.</p> required <code>depth</code> <code>int</code> <p>The current depth.</p> required <code>max_depth</code> <code>int</code> <p>The maximum depth.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.load_state_dict","title":"coola.formatters.BaseFormatter.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict</code> <p>a dict with parameters</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; # Please take a look to the implementation of the state_dict\n&gt;&gt;&gt; # function to know the expected structure\n&gt;&gt;&gt; formatter.load_state_dict({\"max_characters\": 10})\n&gt;&gt;&gt; formatter\nDefaultFormatter(max_characters=10)\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.BaseFormatter.state_dict","title":"coola.formatters.BaseFormatter.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict\n</code></pre> <p>Return a dictionary containing state values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.state_dict()\n{'max_characters': -1}\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter","title":"coola.formatters.DefaultFormatter","text":"<p>               Bases: <code>BaseFormatter[Any]</code></p> <p>Implement the default formatter.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>The maximum number of characters to show. If a negative value is provided, all the characters are shown.</p> <code>-1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), 1)\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter.get_max_characters","title":"coola.formatters.DefaultFormatter.get_max_characters","text":"<pre><code>get_max_characters() -&gt; int\n</code></pre> <p>Get the maximum number of characters to show.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum number of characters to show.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.get_max_characters()\n-1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.DefaultFormatter.set_max_characters","title":"coola.formatters.DefaultFormatter.set_max_characters","text":"<pre><code>set_max_characters(max_characters: int) -&gt; None\n</code></pre> <p>Set the maximum number of characters to show.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>The maximum number of characters to show.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>max_characters</code> is not an integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import DefaultFormatter\n&gt;&gt;&gt; formatter = DefaultFormatter()\n&gt;&gt;&gt; formatter.set_max_characters(10)\n&gt;&gt;&gt; formatter.get_max_characters()\n10\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.MappingFormatter","title":"coola.formatters.MappingFormatter","text":"<p>               Bases: <code>BaseCollectionFormatter[Mapping]</code></p> <p>Implement a formatter for <code>Mapping</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import MappingFormatter\n&gt;&gt;&gt; formatter = MappingFormatter()\n&gt;&gt;&gt; print(formatter.format(Summarizer(), {'key1': 1.2, 'key2': 'abc', 'key3': 42}))\n&lt;class 'dict'&gt; (length=3)\n  (key1): 1.2\n  (key2): abc\n  (key3): 42\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter","title":"coola.formatters.NDArrayFormatter","text":"<p>               Bases: <code>BaseFormatter[ndarray]</code></p> <p>Implement a formatter for <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, the returned string is the default string representation (<code>repr</code>). If <code>False</code>, the returned string only contains the tensor metadata.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), np.arange(21))\n&lt;class 'numpy.ndarray'&gt; | shape=(21,) | dtype=int64\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter.get_show_data","title":"coola.formatters.NDArrayFormatter.get_show_data","text":"<pre><code>get_show_data() -&gt; bool\n</code></pre> <p>Indicate if the array data or metadata are shown.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the array data are shown, <code>False</code> if the array metadata are shown.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.get_show_data()\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.NDArrayFormatter.set_show_data","title":"coola.formatters.NDArrayFormatter.set_show_data","text":"<pre><code>set_show_data(show_data: bool) -&gt; None\n</code></pre> <p>Set if the array data or metadata are shown.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p><code>True</code> if the array data are shown, <code>False</code> if the array metadata are shown.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>show_data</code> is not a boolean.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import NDArrayFormatter\n&gt;&gt;&gt; formatter = NDArrayFormatter()\n&gt;&gt;&gt; formatter.set_show_data(True)\n&gt;&gt;&gt; formatter.get_show_data()\nTrue\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.SequenceFormatter","title":"coola.formatters.SequenceFormatter","text":"<p>               Bases: <code>BaseCollectionFormatter[Sequence]</code></p> <p>Implement a formatter for <code>Sequence</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import SequenceFormatter\n&gt;&gt;&gt; formatter = SequenceFormatter()\n&gt;&gt;&gt; print(formatter.format(Summarizer(), [1, 2, 3]))\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.SetFormatter","title":"coola.formatters.SetFormatter","text":"<p>               Bases: <code>BaseCollectionFormatter[set]</code></p> <p>Implement a formatter for <code>set</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import SetFormatter\n&gt;&gt;&gt; formatter = SetFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), {1})\n&lt;class 'set'&gt; (length=1)\\n  (0): 1\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter","title":"coola.formatters.TensorFormatter","text":"<p>               Bases: <code>BaseFormatter[Tensor]</code></p> <p>Implement a formatter for <code>torch.Tensor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, the returned string is the default string representation (<code>repr</code>). If <code>False</code>, the returned string only contains the tensor metadata.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.format(Summarizer(), torch.arange(21))\n&lt;class 'torch.Tensor'&gt; | shape=torch.Size([21]) | dtype=torch.int64 | device=cpu\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter.get_show_data","title":"coola.formatters.TensorFormatter.get_show_data","text":"<pre><code>get_show_data() -&gt; bool\n</code></pre> <p>Indicate if the tensor data or metadata are shown.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the tensor data are shown, <code>False</code> if the tensor metadata are shown.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.get_show_data()\nFalse\n</code></pre>"},{"location":"refs/formatters/#coola.formatters.TensorFormatter.set_show_data","title":"coola.formatters.TensorFormatter.set_show_data","text":"<pre><code>set_show_data(show_data: bool) -&gt; None\n</code></pre> <p>Set if the tensor data or metadata are shown.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p><code>True</code> if the tensor data are shown, <code>False</code> if the tensor metadata are shown.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>show_data</code> is not an boolean.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.formatters import TensorFormatter\n&gt;&gt;&gt; formatter = TensorFormatter()\n&gt;&gt;&gt; formatter.set_show_data(True)\n&gt;&gt;&gt; formatter.get_show_data()\nTrue\n</code></pre>"},{"location":"refs/random/","title":"Random","text":""},{"location":"refs/random/#coola.random","title":"coola.random","text":"<p>Contain functionalities to manage randomness.</p>"},{"location":"refs/random/#coola.random.BaseRandomManager","title":"coola.random.BaseRandomManager","text":"<p>               Bases: <code>ABC</code></p> <p>Implement the base class to manage randomness.</p> <p>Each child class must implement the methods: - <code>get_rng_state</code>. - <code>manual_seed</code>. - <code>set_rng_state</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.get_rng_state","title":"coola.random.BaseRandomManager.get_rng_state  <code>abstractmethod</code>","text":"<pre><code>get_rng_state() -&gt; Any\n</code></pre> <p>Get the current RNG state.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The current RNG state.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; state = manager.get_rng_state()\n&gt;&gt;&gt; state\n{'torch': tensor([...], dtype=torch.uint8), 'torch.cuda': ...}\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.manual_seed","title":"coola.random.BaseRandomManager.manual_seed  <code>abstractmethod</code>","text":"<pre><code>manual_seed(seed: int) -&gt; None\n</code></pre> <p>Set the seed for generating random numbers.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The desired seed.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.set_rng_state","title":"coola.random.BaseRandomManager.set_rng_state  <code>abstractmethod</code>","text":"<pre><code>set_rng_state(state: Any) -&gt; None\n</code></pre> <p>Set the RNG state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Any</code> <p>The new RNG state.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; state = manager.get_rng_state()\n&gt;&gt;&gt; manager.set_rng_state(state)\n</code></pre>"},{"location":"refs/random/#coola.random.NumpyRandomManager","title":"coola.random.NumpyRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement a random manager for the library <code>numpy</code>.</p> <p>The seed must be between <code>0</code> and <code>2**32 - 1</code>, so a modulo operator to convert an integer to an integer between <code>0</code> and <code>2**32 - 1</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import NumpyRandomManager\n&gt;&gt;&gt; manager = NumpyRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManager","title":"coola.random.RandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement the default random manager.</p> <p>By default, it is initialized with the following random managers:</p> <ul> <li><code>'random'</code>: <code>RandomRandomManager</code></li> <li><code>'numpy'</code>: <code>NumpyRandomManager</code> if <code>numpy</code> is available</li> <li><code>'torch'</code>: <code>TorchRandomManager</code> if <code>torch</code> is available</li> </ul> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomManager\n&gt;&gt;&gt; manager = RandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManager.add_manager","title":"coola.random.RandomManager.add_manager  <code>classmethod</code>","text":"<pre><code>add_manager(\n    name: str,\n    manager: BaseRandomManager,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a random manager for a given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the random manager to add.</p> required <code>manager</code> <code>BaseRandomManager</code> <p>The random manager to add.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>ValueError</code> is raised if the name already exists. This parameter should be set to <code>True</code> to overwrite the manager for a name.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a random manager is already registered for the name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import BaseRandomManager, RandomManager\n&gt;&gt;&gt; class OtherRandomManager(BaseRandomManager):\n...     def get_rng_state(self) -&gt; dict:\n...         return {}\n...\n...     def manual_seed(self, seed: int) -&gt; None:\n...         pass\n...\n...     def set_rng_state(self, state: dict) -&gt; dict:\n...         pass\n...\n&gt;&gt;&gt; RandomManager.add_manager(\"other\", OtherRandomManager())\n&gt;&gt;&gt; # To overwrite an existing random manager\n&gt;&gt;&gt; RandomManager.add_manager(\"other\", OtherRandomManager(), exist_ok=True)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManager.has_manager","title":"coola.random.RandomManager.has_manager  <code>classmethod</code>","text":"<pre><code>has_manager(name: str) -&gt; bool\n</code></pre> <p>Indicate if a random manager is registered for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a random manager is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomManager\n&gt;&gt;&gt; RandomManager.has_manager(\"random\")\nTrue\n&gt;&gt;&gt; RandomManager.has_manager(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/random/#coola.random.RandomRandomManager","title":"coola.random.RandomRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement a random manager for the python standard library <code>random</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomRandomManager\n&gt;&gt;&gt; manager = RandomRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.TorchRandomManager","title":"coola.random.TorchRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implements a random number generator for the library <code>torch</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.get_random_managers","title":"coola.random.get_random_managers","text":"<pre><code>get_random_managers() -&gt; dict[str, BaseRandomManager]\n</code></pre> <p>Get the random managers and their default name.</p> <p>Returns:</p> Type Description <code>dict[str, BaseRandomManager]</code> <p>The mapping between the name and random managers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import get_random_managers\n&gt;&gt;&gt; get_random_managers()\n{'random': RandomRandomManager()...}\n</code></pre>"},{"location":"refs/random/#coola.random.get_rng_state","title":"coola.random.get_rng_state","text":"<pre><code>get_rng_state() -&gt; dict[str, Any]\n</code></pre> <p>Get the current RNG state.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The current RNG state.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import get_rng_state\n&gt;&gt;&gt; state = get_rng_state()\n&gt;&gt;&gt; state\n{'random': ...}\n</code></pre>"},{"location":"refs/random/#coola.random.manual_seed","title":"coola.random.manual_seed","text":"<pre><code>manual_seed(seed: int) -&gt; None\n</code></pre> <p>Set the seed for generating random numbers.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The desired random seed.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n</code></pre>"},{"location":"refs/random/#coola.random.numpy_seed","title":"coola.random.numpy_seed","text":"<pre><code>numpy_seed(seed: int) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the NumPy random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola.random import numpy_seed\n&gt;&gt;&gt; with numpy_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n&gt;&gt;&gt; with numpy_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n</code></pre>"},{"location":"refs/random/#coola.random.random_seed","title":"coola.random.random_seed","text":"<pre><code>random_seed(seed: int) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n</code></pre>"},{"location":"refs/random/#coola.random.register_random_managers","title":"coola.random.register_random_managers","text":"<pre><code>register_random_managers() -&gt; None\n</code></pre> <p>Register randomness managers to <code>RandomManager</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomManager\n&gt;&gt;&gt; from coola.random.default import register_random_managers\n&gt;&gt;&gt; register_random_managers()\n&gt;&gt;&gt; manager = RandomManager()\n&gt;&gt;&gt; manager\nRandomManager(\n  (random): RandomRandomManager()\n  ...\n)\n</code></pre>"},{"location":"refs/random/#coola.random.set_rng_state","title":"coola.random.set_rng_state","text":"<pre><code>set_rng_state(state: dict[str, Any]) -&gt; None\n</code></pre> <p>Set the RNG state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict[str, Any]</code> <p>The new RNG state.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import get_rng_state, set_rng_state\n&gt;&gt;&gt; st = get_rng_state()\n&gt;&gt;&gt; set_rng_state(st)\n</code></pre>"},{"location":"refs/random/#coola.random.torch_seed","title":"coola.random.torch_seed","text":"<pre><code>torch_seed(seed: int) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the PyTorch random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import torch_seed\n&gt;&gt;&gt; with torch_seed(42):\n...     print(torch.randn(2, 4))\n...\ntensor([[...]])\n&gt;&gt;&gt; with torch_seed(42):\n...     print(torch.randn(2, 4))\n...\ntensor([[...]])\n</code></pre>"},{"location":"refs/reducers/","title":"Reducers","text":""},{"location":"refs/reducers/#coola.reducers","title":"coola.reducers","text":"<p>Contain the reducer implementations.</p>"},{"location":"refs/reducers/#coola.reducers.BaseBasicReducer","title":"coola.reducers.BaseBasicReducer","text":"<p>               Bases: <code>BaseReducer[T]</code></p> <p>Extension of <code>BaseReducer</code> to check if the input sequence is empty before to call the reduction methods.</p>"},{"location":"refs/reducers/#coola.reducers.BaseReducer","title":"coola.reducers.BaseReducer","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.max","title":"coola.reducers.BaseReducer.max  <code>abstractmethod</code>","text":"<pre><code>max(values: T) -&gt; int | float\n</code></pre> <p>Compute the maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The maximum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.mean","title":"coola.reducers.BaseReducer.mean  <code>abstractmethod</code>","text":"<pre><code>mean(values: T) -&gt; float\n</code></pre> <p>Compute the mean value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.mean([-2, -1, 0, 1, 2])\n0.0\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.median","title":"coola.reducers.BaseReducer.median  <code>abstractmethod</code>","text":"<pre><code>median(values: T) -&gt; int | float\n</code></pre> <p>Compute the median value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The median value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.min","title":"coola.reducers.BaseReducer.min  <code>abstractmethod</code>","text":"<pre><code>min(values: T) -&gt; int | float\n</code></pre> <p>Compute the minimum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The minimum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.min([-2, -1, 0, 1, 2])\n-2\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.quantile","title":"coola.reducers.BaseReducer.quantile  <code>abstractmethod</code>","text":"<pre><code>quantile(\n    values: T, quantiles: Sequence[float]\n) -&gt; list[float]\n</code></pre> <p>Compute the quantiles.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <code>quantiles</code> <code>sequence of float</code> <p>The quantile values in the range <code>[0, 1]</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The quantiles.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.quantile([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (0.2, 0.5, 0.9))\n[2.0, 5.0, 9.0]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.sort","title":"coola.reducers.BaseReducer.sort  <code>abstractmethod</code>","text":"<pre><code>sort(\n    values: T, descending: bool = False\n) -&gt; list[int | float]\n</code></pre> <p>Sorts the values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <code>descending</code> <code>bool</code> <p>The sorting order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int | float]</code> <p>The sorted values.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0], descending=True)\n[3, 2, 1, 0, -2]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.BaseReducer.std","title":"coola.reducers.BaseReducer.std  <code>abstractmethod</code>","text":"<pre><code>std(values: T) -&gt; float\n</code></pre> <p>Compute the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> <p>Example usage:</p> <p>.. code-block:: pycon</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.std([-2, -1, 0, 1, 2])\n1.581138...\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.EmptySequenceError","title":"coola.reducers.EmptySequenceError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise when the sequence is empty because it is not possible to reduce an empty sequence.</p>"},{"location":"refs/reducers/#coola.reducers.NativeReducer","title":"coola.reducers.NativeReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a native reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import NativeReducer\n&gt;&gt;&gt; reducer = NativeReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.NumpyReducer","title":"coola.reducers.NumpyReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a reducer based on NumPy functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>numpy</code> is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry","title":"coola.reducers.ReducerRegistry","text":"<p>Implement the reducer registry.</p> <p>The registry is a class variable, so it is shared with all the instances of this class.</p>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.add_reducer","title":"coola.reducers.ReducerRegistry.add_reducer  <code>classmethod</code>","text":"<pre><code>add_reducer(\n    name: str, reducer: BaseReducer, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Add a reducer to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the reducer.</p> required <code>reducer</code> <code>BaseReducer</code> <p>The reducer.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the name already exists. This parameter should be set to <code>True</code> to overwrite the existing reducer.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a reducer is already registered for the name and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry, NativeReducer\n&gt;&gt;&gt; ReducerRegistry.add_reducer(\"native\", NativeReducer(), exist_ok=True)\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.available_reducers","title":"coola.reducers.ReducerRegistry.available_reducers  <code>classmethod</code>","text":"<pre><code>available_reducers() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available reducers.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available reducers.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry\n&gt;&gt;&gt; ReducerRegistry.available_reducers()\n('native', 'numpy', 'torch')\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.ReducerRegistry.has_reducer","title":"coola.reducers.ReducerRegistry.has_reducer  <code>classmethod</code>","text":"<pre><code>has_reducer(name: str) -&gt; bool\n</code></pre> <p>Indicate if a reducer is registered for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a reducer is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import ReducerRegistry\n&gt;&gt;&gt; ReducerRegistry.has_reducer(\"native\")\nTrue\n&gt;&gt;&gt; ReducerRegistry.has_reducer(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.TorchReducer","title":"coola.reducers.TorchReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a reducer based on torch functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducers/#coola.reducers.auto_reducer","title":"coola.reducers.auto_reducer","text":"<pre><code>auto_reducer() -&gt; BaseReducer\n</code></pre> <p>Find the \"best\" reducer to used based on the installed packages.</p> <p>The \"best\" reducer is found by using the following rules:     - If <code>torch</code> is available, use <code>TorchReducer</code>     - If <code>numpy</code> is available, use <code>NumpyReducer</code>     - Otherwise, use <code>BasicReducer</code></p> <p>Returns:</p> Type Description <code>BaseReducer</code> <p>The \"best\" reducer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.reducers import auto_reducer\n&gt;&gt;&gt; reducer = auto_reducer()\n</code></pre>"},{"location":"refs/summarizers/","title":"Summarizers","text":""},{"location":"refs/summarizers/#coola.summarizers","title":"coola.summarizers","text":"<p>Contain the summarizer implementations.</p>"},{"location":"refs/summarizers/#coola.summarizers.BaseSummarizer","title":"coola.summarizers.BaseSummarizer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a summarizer.</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer\nSummarizer(\n  (&lt;class 'collections.abc.Mapping'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'collections.abc.Sequence'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'dict'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'list'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'object'&gt;): DefaultFormatter(max_characters=-1)\n  (&lt;class 'set'&gt;): SetFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'tuple'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'numpy.ndarray'&gt;): NDArrayFormatter(show_data=False)\n  (&lt;class 'torch.Tensor'&gt;): TensorFormatter(show_data=False)\n)\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.BaseSummarizer.summary","title":"coola.summarizers.BaseSummarizer.summary  <code>abstractmethod</code>","text":"<pre><code>summary(\n    value: Any, depth: int = 0, max_depth: int = 1\n) -&gt; str\n</code></pre> <p>Summarize the input value in a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to summarize.</p> required <code>depth</code> <code>int</code> <p>The current depth.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to summarize if the input is nested.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The summary as a string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer","title":"coola.summarizers.Summarizer","text":"<p>               Bases: <code>BaseSummarizer</code></p> <p>Implement the default summarizer.</p> <p>The registry is a class variable, so it is shared with all the instances of this class.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer\nSummarizer(\n  (&lt;class 'collections.abc.Mapping'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'collections.abc.Sequence'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'dict'&gt;): MappingFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'list'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'object'&gt;): DefaultFormatter(max_characters=-1)\n  (&lt;class 'set'&gt;): SetFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'tuple'&gt;): SequenceFormatter(max_items=5, num_spaces=2)\n  (&lt;class 'numpy.ndarray'&gt;): NDArrayFormatter(show_data=False)\n  (&lt;class 'torch.Tensor'&gt;): TensorFormatter(show_data=False)\n)\n&gt;&gt;&gt; print(summarizer.summary(1))\n&lt;class 'int'&gt; 1\n&gt;&gt;&gt; print(summarizer.summary([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n&gt;&gt;&gt; print(summarizer.summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.add_formatter","title":"coola.summarizers.Summarizer.add_formatter  <code>classmethod</code>","text":"<pre><code>add_formatter(\n    data_type: type[object],\n    formatter: BaseFormatter,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a formatter for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>The data type for this test.</p> required <code>formatter</code> <code>BaseFormatter</code> <p>The formatter to use for the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the formatter for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a formatter is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; from coola.formatters import MappingFormatter\n&gt;&gt;&gt; Summarizer.add_formatter(dict, MappingFormatter(), exist_ok=True)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.find_formatter","title":"coola.summarizers.Summarizer.find_formatter  <code>classmethod</code>","text":"<pre><code>find_formatter(data_type: Any) -&gt; BaseFormatter\n</code></pre> <p>Find the formatter associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseFormatter</code> <p>The formatter associated to the data type.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if a formatter cannot be found for this data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.find_formatter(list)\nSequenceFormatter(max_items=5, num_spaces=2)\n&gt;&gt;&gt; Summarizer.find_formatter(str)\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.has_formatter","title":"coola.summarizers.Summarizer.has_formatter  <code>classmethod</code>","text":"<pre><code>has_formatter(data_type: type[object]) -&gt; bool\n</code></pre> <p>Indicate if a formatter is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[object]</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a formatter is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.has_formatter(list)\nTrue\n&gt;&gt;&gt; Summarizer.has_formatter(str)\nFalse\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.load_state_dict","title":"coola.summarizers.Summarizer.load_state_dict  <code>classmethod</code>","text":"<pre><code>load_state_dict(state: dict) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict</code> <p>A dictionary with state values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.load_state_dict({object: {\"max_characters\": 10}})\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; Summarizer.load_state_dict({object: {\"max_characters\": -1}})\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_max_characters","title":"coola.summarizers.Summarizer.set_max_characters  <code>classmethod</code>","text":"<pre><code>set_max_characters(max_characters: int) -&gt; None\n</code></pre> <p>Set the maximum of characters for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_max_characters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>The maximum of characters.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_max_characters(10)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=10)\n&gt;&gt;&gt; Summarizer.set_max_characters(-1)\n&gt;&gt;&gt; summarizer.registry[object]\nDefaultFormatter(max_characters=-1)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_max_items","title":"coola.summarizers.Summarizer.set_max_items  <code>classmethod</code>","text":"<pre><code>set_max_items(max_items: int) -&gt; None\n</code></pre> <p>Set the maximum number of items for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_max_items</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>The maximum number of items to show.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_max_items(10)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=10, num_spaces=2)\n&gt;&gt;&gt; Summarizer.set_max_items(5)\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=2)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.set_num_spaces","title":"coola.summarizers.Summarizer.set_num_spaces  <code>classmethod</code>","text":"<pre><code>set_num_spaces(num_spaces: int) -&gt; None\n</code></pre> <p>Set the maximum of items for the compatible formatter to the specified value.</p> <p>To be updated, the formatters need to implement the method <code>set_num_spaces</code>.</p> <p>Parameters:</p> Name Type Description Default <code>num_spaces</code> <code>int</code> <p>The number of spaces for indentation.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.set_num_spaces(4)\n&gt;&gt;&gt; summarizer = Summarizer()\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=4)\n&gt;&gt;&gt; Summarizer.set_num_spaces(2)\n&gt;&gt;&gt; summarizer.registry[dict]\nMappingFormatter(max_items=5, num_spaces=2)\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.Summarizer.state_dict","title":"coola.summarizers.Summarizer.state_dict  <code>classmethod</code>","text":"<pre><code>state_dict() -&gt; dict\n</code></pre> <p>Return a dictionary containing state values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import Summarizer\n&gt;&gt;&gt; Summarizer.state_dict()\n{&lt;class 'collections.abc.Mapping'&gt;: {'max_items': 5, 'num_spaces': 2},...}\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.set_summarizer_options","title":"coola.summarizers.set_summarizer_options","text":"<pre><code>set_summarizer_options(\n    max_characters: int | None = None,\n    max_items: int | None = None,\n    num_spaces: int | None = None,\n) -&gt; None\n</code></pre> <p>Set the <code>Summarizer</code> options.</p> <p>Note: It is recommended to use <code>summarizer_options</code> rather than this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int | None</code> <p>The maximum number of characters to show. If <code>None</code>, the maximum number of characters is unchanged.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>The maximum number of items to show. If <code>None</code>, the maximum number of items is unchanged.</p> <code>None</code> <code>num_spaces</code> <code>int | None</code> <p>The number of spaces for indentation. If <code>None</code>, the number of  spaces for indentation is unchanged.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import set_summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; set_summarizer_options(max_characters=10)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; set_summarizer_options(max_characters=-1)\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/summarizers/#coola.summarizers.summarizer_options","title":"coola.summarizers.summarizer_options","text":"<pre><code>summarizer_options(**kwargs: Any) -&gt; None\n</code></pre> <p>Context manager that temporarily changes the summarizer options.</p> <p>Accepted arguments are same as <code>set_summarizer_options</code>. The context manager temporary change the configuration of <code>Summarizer</code>. This context manager has no effect if <code>Summarizer</code> is not used.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Accepted arguments are same as <code>set_summarizer_options</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola import summarizer_options, summary\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n&gt;&gt;&gt; with summarizer_options(max_characters=10):\n...     print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n...\n&lt;class 'str'&gt; abcdefghij...\n&gt;&gt;&gt; print(summary(\"abcdefghijklmnopqrstuvwxyz\"))\n&lt;class 'str'&gt; abcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"refs/testers/","title":"Testers","text":""},{"location":"refs/testers/#coola.equality.testers","title":"coola.equality.testers","text":"<p>Contain the testers to check if two objects are equal or not.</p>"},{"location":"refs/testers/#coola.equality.testers.BaseEqualityTester","title":"coola.equality.testers.BaseEqualityTester","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality tester.</p>"},{"location":"refs/testers/#coola.equality.testers.BaseEqualityTester.equal","title":"coola.equality.testers.BaseEqualityTester.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; config = EqualityConfig(tester=tester)\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.zeros(2)], [np.ones((2, 3)), np.zeros(2)], config)\nTrue\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.ones(2)], [np.ones((2, 3)), np.zeros(2)], config)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester","title":"coola.equality.testers.EqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement the default equality tester.</p>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.add_comparator","title":"coola.equality.testers.EqualityTester.add_comparator  <code>classmethod</code>","text":"<pre><code>add_comparator(\n    data_type: type,\n    comparator: BaseEqualityComparator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a comparator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; EqualityTester.add_comparator(list, SequenceEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.find_comparator","title":"coola.equality.testers.EqualityTester.find_comparator  <code>classmethod</code>","text":"<pre><code>find_comparator(data_type: Any) -&gt; BaseEqualityComparator\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator</code> <p>The equality comparator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; EqualityTester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.has_comparator","title":"coola.equality.testers.EqualityTester.has_comparator  <code>classmethod</code>","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.has_comparator(list)\nTrue\n&gt;&gt;&gt; EqualityTester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.local_copy","title":"coola.equality.testers.EqualityTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalEqualityTester\n</code></pre> <p>Return a copy of <code>EqualityTester</code> that can easily be customized without changind <code>EqualityTester</code>.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A \"local\" copy of <code>EqualityTester</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester\nLocalEqualityTester(...)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester","title":"coola.equality.testers.LocalEqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type, BaseEqualityComparator] | None</code> <p>The initial registry with the equality comparators.</p> <code>None</code>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.add_comparator","title":"coola.equality.testers.LocalEqualityTester.add_comparator","text":"<pre><code>add_comparator(\n    data_type: type,\n    comparator: BaseEqualityComparator,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an comparator is already registered for the data type and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator())\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.clone","title":"coola.equality.testers.LocalEqualityTester.clone","text":"<pre><code>clone() -&gt; LocalEqualityTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A deep copy of the current tester.</p> <p>Example usage:</p> <p>```pycon</p> <p>from coola.equality.testers import EqualityTester tester = EqualityTester.local_copy() tester_cloned = tester.clone()</p> <p>```</p>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.find_comparator","title":"coola.equality.testers.LocalEqualityTester.find_comparator","text":"<pre><code>find_comparator(data_type: Any) -&gt; BaseEqualityComparator\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>Any</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator</code> <p>The equality comparator associated to the data type.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; tester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.has_comparator","title":"coola.equality.testers.LocalEqualityTester.has_comparator","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.has_comparator(list)\nTrue\n&gt;&gt;&gt; tester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#coola.utils","title":"coola.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#coola.utils.check_numpy","title":"coola.utils.check_numpy","text":"<pre><code>check_numpy() -&gt; None\n</code></pre> <p>Check if the <code>numpy</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>numpy</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_numpy\n&gt;&gt;&gt; check_numpy()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_pandas","title":"coola.utils.check_pandas","text":"<pre><code>check_pandas() -&gt; None\n</code></pre> <p>Check if the <code>pandas</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pandas</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_pandas\n&gt;&gt;&gt; check_pandas()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_polars","title":"coola.utils.check_polars","text":"<pre><code>check_polars() -&gt; None\n</code></pre> <p>Check if the <code>polars</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>polars</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_polars\n&gt;&gt;&gt; check_polars()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_torch","title":"coola.utils.check_torch","text":"<pre><code>check_torch() -&gt; None\n</code></pre> <p>Check if the <code>torch</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>torch</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_torch\n&gt;&gt;&gt; check_torch()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_xarray","title":"coola.utils.check_xarray","text":"<pre><code>check_xarray() -&gt; None\n</code></pre> <p>Check if the <code>xarray</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>xarray</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_xarray\n&gt;&gt;&gt; check_xarray()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_jax_available","title":"coola.utils.is_jax_available  <code>cached</code>","text":"<pre><code>is_jax_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>jax</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>jax</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_jax_available\n&gt;&gt;&gt; is_jax_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_numpy_available","title":"coola.utils.is_numpy_available  <code>cached</code>","text":"<pre><code>is_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>numpy</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>numpy</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_numpy_available\n&gt;&gt;&gt; is_numpy_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_pandas_available","title":"coola.utils.is_pandas_available  <code>cached</code>","text":"<pre><code>is_pandas_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pandas</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pandas</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_pandas_available\n&gt;&gt;&gt; is_pandas_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_polars_available","title":"coola.utils.is_polars_available  <code>cached</code>","text":"<pre><code>is_polars_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>polars</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>polars</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_polars_available\n&gt;&gt;&gt; is_polars_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_torch_available","title":"coola.utils.is_torch_available  <code>cached</code>","text":"<pre><code>is_torch_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>torch</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>torch</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_torch_available\n&gt;&gt;&gt; is_torch_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_xarray_available","title":"coola.utils.is_xarray_available  <code>cached</code>","text":"<pre><code>is_xarray_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>xarray</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>xarray</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_xarray_available\n&gt;&gt;&gt; is_xarray_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_indent","title":"coola.utils.repr_indent","text":"<pre><code>repr_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>repr</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_mapping","title":"coola.utils.repr_mapping","text":"<pre><code>repr_mapping(\n    mapping: Mapping,\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_mapping\n&gt;&gt;&gt; print(repr_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_sequence","title":"coola.utils.repr_sequence","text":"<pre><code>repr_sequence(\n    sequence: Sequence, num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_indent","title":"coola.utils.str_indent","text":"<pre><code>str_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>str</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_indent\n&gt;&gt;&gt; print(str_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_mapping","title":"coola.utils.str_mapping","text":"<pre><code>str_mapping(\n    mapping: Mapping,\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_mapping\n&gt;&gt;&gt; print(str_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_sequence","title":"coola.utils.str_sequence","text":"<pre><code>str_sequence(\n    sequence: Sequence, num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from coola.utils.format import str_sequence\n&gt;&gt;&gt; print(str_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"upgrade/0.3/","title":"0.2 to 0.3","text":"<p>This page explains how to migrate from <code>coola</code> 0.2 to 0.3 because <code>coola</code> 0.3 introduces several non-backward compatible changes due to the redesign of the equality mechanism.</p>"},{"location":"upgrade/0.3/#objects_are_equalallclose","title":"<code>objects_are_equal/allclose</code>","text":"<p>The signature of the <code>objects_are_equal</code> and <code>objects_are_allclose</code> function were updated and only the first two arguments can be provided as positional arguments. All the other arguments had to be provided as keyword arguments. Both functions take a <code>BaseEqualityTester</code> as <code>tester</code> argument.</p>"},{"location":"upgrade/0.3/#objects_are_equal","title":"<code>objects_are_equal</code>","text":"<p><code>coola</code> 0.3 also introduces a new parameter <code>equal_nan</code> to <code>objects_are_equal</code> to indicate whether to compare NaN\u2019s as equal. To keep the behavior similar as <code>coola</code> 0.2, the default value of <code>equal_nan</code> is <code>False</code>.</p> coola 0.2 (old)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> coola 0.3 (new)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre>"},{"location":"upgrade/0.3/#equality-mechanism","title":"Equality mechanism","text":"<p>The equality mechanism was fully redesigned in <code>coola</code> 0.3 to merge the two existing equality mechanisms. In <code>coola</code> 0.2, there were two equality mechanisms:</p> <ul> <li>a mechanism to check if two objects are equal (mechanism behind <code>objects_are_equal</code>)</li> <li>a mechanism to check if two objects are equal within tolerance (mechanism   behind <code>objects_are_allclose</code>)</li> </ul> <p>This approach was not scalable because there were a lot of overlap and duplicate code between the two mechanisms. For each new type to support, it was necessary to implement two comparators: one inheriting from <code>BaseEqualityOperator</code> and another one inheriting from <code>BaseAllCloseOperator</code>. In the long term, fusing the two mechanisms will make the code easier to maintain and extend. The new equality mechanism combines two previous equality mechanisms in a single equality mechanism so it is necessary to implement only a single comparator for each type.</p> <p><code>BaseEqualityOperator</code> has a new interface which is similar but not directly compatible with the old interface. The new interface introduces a new data structure <code>EqualityConfig</code> to keep the interface simpler and to make the fusion easier. <code>EqualityConfig</code> stores all the parameters that controls the equality mechanism, like the absolute or relative tolerance thresholds. Below is a simplified version of the interface. Please check the code to see all the details.</p> coola 0.3 (new interface)<pre><code>from abc import ABC, abstractmethod\nfrom typing import Any, Generic, TypeVar\n\nfrom coola.equality.config import EqualityConfig\n\nT = TypeVar(\"T\")\n\n\nclass BaseEqualityComparator(ABC, Generic[T]):\n    @abstractmethod\n    def equal(self, object1: T, object2: Any, config: EqualityConfig) -&gt; bool:\n        pass\n</code></pre> <p>Note that in most of the cases, it will not be necessary to change the overall logic inside the <code>equal</code> method.</p> <p>The redesign of the equality mechanism introduces the following main changes:</p> <ul> <li>The class <code>BaseAllCloseOperator</code> has been removed as well as all its child classes.</li> <li><code>coola.comparators</code> has been removed and an equivalent package has been   added <code>coola.equality.comparators</code>. Please note that <code>coola.equality.comparators</code> is not a direct   replacement of <code>coola.comparators</code> because <code>BaseEqualityOperator</code> has new interface.</li> <li><code>coola.testers</code> has been removed and an equivalent package has been   added <code>coola.equality.testers</code>. Please note that <code>coola.equality.testers</code> is not a direct   replacement of <code>coola.testers</code> because <code>BaseEqualityOperator</code> has new interface.</li> </ul>"},{"location":"upgrade/0.4/","title":"0.3 to 0.4","text":"<p>This page explains how to migrate from <code>coola</code> 0.3 to 0.4 because <code>coola</code> 0.4 introduces several non-backward compatible changes.</p>"},{"location":"upgrade/0.4/#objects_are_equalallclose","title":"<code>objects_are_equal/allclose</code>","text":"<p>The signature of the <code>objects_are_equal</code> and <code>objects_are_allclose</code> function were updated:</p> <ul> <li><code>object1</code> was renamed to <code>actual</code></li> <li><code>object2</code> was renamed to <code>expected</code></li> </ul> <p>The same changes were made in the associated classes to be consistent:</p> <ul> <li><code>BaseEqualityComparator</code></li> <li><code>BaseEqualityHandler</code></li> <li><code>BaseEqualityTester</code></li> </ul>"}]}