{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>coola</code> is a Python library that provides simple functions to check in a single line if two complex/nested objects are equal or not. <code>coola</code> was initially designed to work with PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>, but it is possible to extend it to support other data structures.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have the following dictionaries that contain both a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>. You want to check if the two dictionaries are equal or not. By default, Python does not provide an easy way to check if the two dictionaries are equal or not. It is not possible to use the default equality operator <code>==</code> because it will raise an error. The <code>coola</code> library was developed to fill this gap. <code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p><code>coola</code> also provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-6)\nFalse\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>coola</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>coola</code> to a new version will possibly break any code that was using the old version of <code>coola</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>coola</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install coola\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>coola</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'coola[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install coola numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>coola</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/coola.git\n</code></pre> <p>Note: <code>coola</code> requires Python 3.10 or higher.</p> <p>It is recommended to create a virtual environment (this step is optional). To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate coola\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>coola</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"get_started/#testing","title":"Testing","text":"<p><code>coola</code> is continuously tested with the following package versions:</p> package tested versions <code>jax</code> <code>&gt;=0.5.0,&lt;1.0</code> <code>numpy</code> <code>&gt;=1.24,&lt;3.0</code> <code>packaging</code> <code>&gt;=22.0,&lt;26.0</code> <code>pandas</code> <code>&gt;=2.0,&lt;3.0</code> <code>polars</code> <code>&gt;=1.0,&lt;2.0</code> <code>pyarrow</code> <code>&gt;=11.0,&lt;23.0</code> <code>torch</code> <code>&gt;=2.0,&lt;3.0</code> <code>xarray</code> <code>&gt;=2023.1</code> <p>For the most up-to-date compatibility information, see:</p> <ul> <li>The GitHub README compatibility table</li> <li>The CI workflow configuration</li> <li>The pyproject.toml file</li> </ul> <p>Note:</p> <ul> <li><code>coola</code> relies on semantic versioning (SemVer) for most packages.</li> <li><code>xarray</code> uses calendar versioning (CalVer).</li> <li>Version constraints are designed to be flexible while ensuring compatibility.</li> </ul>"},{"location":"dev/architecture/","title":"Architecture and Design","text":"<p>This document describes the internal architecture and design principles of <code>coola</code>.</p>"},{"location":"dev/architecture/#overview","title":"Overview","text":"<p><code>coola</code> is designed around a flexible, extensible comparison framework that can handle various data types through a plugin-like architecture. The core design follows these principles:</p> <ol> <li>Separation of concerns: Comparison logic is separated from data type handling</li> <li>Extensibility: New data types can be added without modifying core code</li> <li>Type safety: Strong type checking to prevent subtle bugs</li> <li>Composability: Complex comparisons are built from simpler ones</li> </ol>"},{"location":"dev/architecture/#core-components","title":"Core Components","text":""},{"location":"dev/architecture/#1-comparison-functions","title":"1. Comparison Functions","text":"<p>The main entry points for users:</p> <ul> <li><code>objects_are_equal</code>: Checks exact equality</li> <li><code>objects_are_allclose</code>: Checks equality within tolerance</li> </ul> <p>These functions provide a simple interface while delegating to the internal comparison system.</p>"},{"location":"dev/architecture/#2-testers","title":"2. Testers","text":"<p>Testers are responsible for orchestrating the comparison process.</p>"},{"location":"dev/architecture/#baseequalitytester","title":"<code>BaseEqualityTester</code>","text":"<p>Abstract base class defining the tester interface:</p> <pre><code>class BaseEqualityTester:\n    def equal(self, actual: Any, expected: Any, config: EqualityConfig) -&gt; bool:\n        \"\"\"Check if two objects are equal.\"\"\"\n        ...\n</code></pre>"},{"location":"dev/architecture/#equalitytester","title":"<code>EqualityTester</code>","text":"<p>The default implementation that uses a registry of comparators:</p> <ul> <li>Maintains a registry mapping types to comparators</li> <li>Uses Method Resolution Order (MRO) to find the most specific comparator</li> <li>Delegates comparison to the appropriate comparator</li> </ul> <p>Key Features:</p> <ul> <li>Type-based dispatch</li> <li>Support for inheritance hierarchies</li> <li>Extensible through registration</li> </ul>"},{"location":"dev/architecture/#3-comparators","title":"3. Comparators","text":"<p>Comparators implement comparison logic for specific types.</p>"},{"location":"dev/architecture/#baseequalitycomparator","title":"<code>BaseEqualityComparator</code>","text":"<p>Abstract base class for comparators:</p> <pre><code>class BaseEqualityComparator:\n    def equal(self, actual: Any, expected: Any, config: EqualityConfig) -&gt; bool:\n        \"\"\"Compare two objects of a specific type.\"\"\"\n        ...\n\n    def clone(self) -&gt; BaseEqualityComparator:\n        \"\"\"Create a copy of this comparator.\"\"\"\n        ...\n</code></pre>"},{"location":"dev/architecture/#built-in-comparators","title":"Built-in Comparators","text":"<ul> <li><code>DefaultEqualityComparator</code>: Handles basic Python types</li> <li><code>MappingEqualityComparator</code>: Handles dict and mapping types</li> <li><code>SequenceEqualityComparator</code>: Handles list, tuple, and sequences</li> <li><code>TorchTensorComparator</code>: Handles PyTorch tensors</li> <li><code>NumpyArrayComparator</code>: Handles NumPy arrays</li> <li><code>PandasDataFrameComparator</code>: Handles pandas DataFrames</li> <li>And more for other supported types...</li> </ul>"},{"location":"dev/architecture/#4-configuration","title":"4. Configuration","text":""},{"location":"dev/architecture/#equalityconfig","title":"<code>EqualityConfig</code>","text":"<p>Configuration object that carries comparison settings through the comparison tree:</p> <pre><code>@dataclasses.dataclass\nclass EqualityConfig:\n    tester: BaseEqualityTester\n    show_difference: bool = False\n    # Additional settings...\n</code></pre> <p>This allows behavior to be customized without changing comparator signatures.</p>"},{"location":"dev/architecture/#5-handlers","title":"5. Handlers","text":"<p>Handlers provide reusable comparison logic for common checks:</p> <ul> <li><code>DTypeHandler</code>: Compares data types</li> <li><code>ShapeHandler</code>: Compares array shapes</li> <li><code>DeviceHandler</code>: Compares PyTorch device placement</li> <li><code>NativeEqualHandler</code>: Performs native equality checks</li> <li>And more...</li> </ul> <p>Handlers promote code reuse and consistency across comparators.</p>"},{"location":"dev/architecture/#data-flow","title":"Data Flow","text":"<p>Here's how a comparison flows through the system:</p> <pre><code>User calls objects_are_equal(obj1, obj2)\n    \u2193\nCreates EqualityConfig with settings\n    \u2193\nCalls tester.equal(obj1, obj2, config)\n    \u2193\nTester looks up comparator based on obj1's type\n    \u2193\nCalls comparator.equal(obj1, obj2, config)\n    \u2193\nComparator performs type-specific checks\n    \u2193\nMay recursively call tester.equal() for nested objects\n    \u2193\nReturns boolean result\n</code></pre>"},{"location":"dev/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"dev/architecture/#1-strategy-pattern","title":"1. Strategy Pattern","text":"<p>Comparators implement different comparison strategies for different types, allowing the algorithm to vary independently from the clients that use it.</p>"},{"location":"dev/architecture/#2-chain-of-responsibility","title":"2. Chain of Responsibility","text":"<p>The MRO-based comparator lookup implements a chain of responsibility, trying more specific comparators before falling back to general ones.</p>"},{"location":"dev/architecture/#3-template-method","title":"3. Template Method","text":"<p>Many comparators follow a template:</p> <ol> <li>Check types match</li> <li>Check metadata (shape, dtype, etc.)</li> <li>Check values</li> <li>Optionally show differences</li> </ol>"},{"location":"dev/architecture/#4-registry-pattern","title":"4. Registry Pattern","text":"<p>The comparator registry allows runtime type-to-comparator mapping, enabling extensibility.</p>"},{"location":"dev/architecture/#5-visitor-pattern","title":"5. Visitor Pattern","text":"<p>The recursive nature of comparison through nested structures follows a visitor-like pattern.</p>"},{"location":"dev/architecture/#extension-points","title":"Extension Points","text":""},{"location":"dev/architecture/#adding-support-for-new-types","title":"Adding Support for New Types","text":"<p>To add support for a custom type:</p> <ol> <li> <p>Implement a Comparator: <pre><code>class MyTypeComparator(BaseEqualityComparator):\n    def equal(self, actual: MyType, expected: Any, config: EqualityConfig) -&gt; bool:\n        # Type check\n        if type(actual) is not type(expected):\n            return False\n\n        # Custom comparison logic\n        return actual.compare_to(expected)\n\n    def clone(self):\n        return MyTypeComparator()\n</code></pre></p> </li> <li> <p>Register the Comparator: <pre><code>tester = EqualityTester.local_copy()\ntester.add_comparator(MyType, MyTypeComparator())\n</code></pre></p> </li> <li> <p>Use with Custom Tester: <pre><code>objects_are_equal(obj1, obj2, tester=tester)\n</code></pre></p> </li> </ol>"},{"location":"dev/architecture/#type-system","title":"Type System","text":""},{"location":"dev/architecture/#strict-type-checking","title":"Strict Type Checking","text":"<p><code>coola</code> enforces strict type checking:</p> <ul> <li><code>1</code> (int) \u2260 <code>1.0</code> (float) \u2260 <code>True</code> (bool)</li> <li><code>list</code> \u2260 <code>tuple</code></li> <li><code>dict</code> \u2260 <code>OrderedDict</code></li> </ul> <p>This prevents subtle bugs from type coercion.</p>"},{"location":"dev/architecture/#type-hierarchy-support","title":"Type Hierarchy Support","text":"<p>Through MRO-based lookup, <code>coola</code> supports inheritance:</p> <ul> <li>A comparator for <code>Sequence</code> applies to <code>list</code>, <code>tuple</code>, etc.</li> <li>More specific comparators override general ones</li> <li>Custom subclasses inherit parent comparators</li> </ul>"},{"location":"dev/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"dev/architecture/#early-exit","title":"Early Exit","text":"<p>Comparators check fast properties first:</p> <ol> <li>Type check (very fast)</li> <li>Metadata checks (fast: shape, dtype, device)</li> <li>Value comparison (potentially slow)</li> </ol>"},{"location":"dev/architecture/#lazy-evaluation","title":"Lazy Evaluation","text":"<p>Comparisons short-circuit on first difference when possible.</p>"},{"location":"dev/architecture/#caching","title":"Caching","text":"<p>The tester caches comparator lookups by type for performance.</p>"},{"location":"dev/architecture/#recursive-depth","title":"Recursive Depth","text":"<p>For deeply nested structures, comparison is recursive. Very deep nesting may hit recursion limits ( typically ~1000 levels in Python).</p>"},{"location":"dev/architecture/#error-handling","title":"Error Handling","text":""},{"location":"dev/architecture/#graceful-degradation","title":"Graceful Degradation","text":"<p>When a specific comparator is not available, <code>coola</code> falls back to:</p> <ol> <li>More general comparator (via MRO)</li> <li>Default comparator (for <code>object</code>)</li> <li>Native equality check as last resort</li> </ol>"},{"location":"dev/architecture/#informative-messages","title":"Informative Messages","text":"<p>When <code>show_difference=True</code>, comparators log:</p> <ul> <li>What objects differ</li> <li>Where in the structure the difference is</li> <li>The actual values that differ</li> </ul>"},{"location":"dev/architecture/#testing-strategy","title":"Testing Strategy","text":"<p>The <code>coola</code> codebase uses:</p> <ol> <li>Unit tests: Test individual comparators in isolation</li> <li>Integration tests: Test complete comparison workflows</li> <li>Property-based tests: Test invariants (e.g., reflexivity)</li> <li>Cross-library tests: Test integration with PyTorch, NumPy, etc.</li> </ol>"},{"location":"dev/architecture/#dependencies","title":"Dependencies","text":""},{"location":"dev/architecture/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>Python 3.10+: Core language features</li> </ul>"},{"location":"dev/architecture/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>torch: PyTorch tensor support</li> <li>numpy: NumPy array support</li> <li>pandas: DataFrame support</li> <li>polars: Polars DataFrame support</li> <li>xarray: xarray support</li> <li>jax: JAX array support</li> <li>pyarrow: PyArrow table support</li> </ul> <p>Each optional dependency is only imported when used (lazy loading).</p>"},{"location":"dev/architecture/#module-organization","title":"Module Organization","text":"<pre><code>coola/\n\u251c\u2500\u2500 comparison.py          # Main public API\n\u251c\u2500\u2500 equality/\n\u2502   \u251c\u2500\u2500 comparators/       # Type-specific comparators\n\u2502   \u2502   \u251c\u2500\u2500 base.py\n\u2502   \u2502   \u251c\u2500\u2500 default.py\n\u2502   \u2502   \u251c\u2500\u2500 collection.py  # Mapping, Sequence\n\u2502   \u2502   \u251c\u2500\u2500 torch_.py\n\u2502   \u2502   \u251c\u2500\u2500 numpy_.py\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 testers/          # Comparison orchestration\n\u2502   \u2502   \u251c\u2500\u2500 base.py\n\u2502   \u2502   \u2514\u2500\u2500 default.py\n\u2502   \u251c\u2500\u2500 handlers/         # Reusable comparison logic\n\u2502   \u2514\u2500\u2500 config.py         # Configuration\n\u251c\u2500\u2500 allclose/             # Tolerance-based comparison\n\u2514\u2500\u2500 utils/                # Utility functions\n</code></pre>"},{"location":"dev/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"dev/architecture/#why-strict-type-checking","title":"Why Strict Type Checking?","text":"<p>Rationale: Prevents subtle bugs from implicit type coercion. In scientific computing, knowing that <code>1</code> (int) and <code>1.0</code> (float) are treated differently can catch numerical issues.</p> <p>Trade-off: Less convenient for some use cases, but more explicit and safe.</p>"},{"location":"dev/architecture/#why-registry-based-dispatch","title":"Why Registry-Based Dispatch?","text":"<p>Rationale: Allows extensibility without modifying core code. Users can add support for their own types.</p> <p>Trade-off: Slightly more complex than if/else chains, but much more maintainable.</p>"},{"location":"dev/architecture/#why-separate-testers-and-comparators","title":"Why Separate Testers and Comparators?","text":"<p>Rationale: Separation of concerns. Testers handle dispatch and orchestration, comparators handle type-specific logic.</p> <p>Trade-off: More classes/files, but better modularity.</p>"},{"location":"dev/architecture/#why-handlers","title":"Why Handlers?","text":"<p>Rationale: Code reuse. Many comparators need similar checks (dtype, shape, etc.).</p> <p>Trade-off: One more abstraction layer, but reduces duplication.</p>"},{"location":"dev/architecture/#future-directions","title":"Future Directions","text":"<p>Potential areas for enhancement:</p> <ol> <li>Parallel comparison: For large independent comparisons</li> <li>Streaming comparison: For very large objects that don't fit in memory</li> <li>Approximate structural matching: For comparing objects with similar but not identical    structure</li> <li>Diff generation: Not just boolean result, but detailed diff</li> <li>Performance optimizations: Cython/Numba for hot paths</li> </ol>"},{"location":"dev/architecture/#references","title":"References","text":"<ul> <li>PEP 8: Python style guide</li> <li>PyTorch documentation</li> <li>NumPy documentation</li> <li>Design Patterns: Gang of Four patterns</li> </ul>"},{"location":"dev/architecture/#contributing","title":"Contributing","text":"<p>To contribute to <code>coola</code>'s architecture:</p> <ol> <li>Understand the existing patterns</li> <li>Follow the established conventions</li> <li>Document design decisions</li> <li>Write tests for new components</li> <li>Update this document for significant changes</li> </ol> <p>See the contributing guide for more details.</p>"},{"location":"dev/development/","title":"Development Guide","text":"<p>This guide covers setting up your development environment and common development tasks.</p>"},{"location":"dev/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Poetry for dependency management</li> <li>Git for version control</li> <li>Basic knowledge of Python and testing</li> </ul>"},{"location":"dev/development/#initial-setup","title":"Initial Setup","text":""},{"location":"dev/development/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/YOUR-USERNAME/coola.git\ncd coola\n</code></pre>"},{"location":"dev/development/#2-install-poetry","title":"2. Install Poetry","text":"<p>If you don't have Poetry installed:</p> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <p>Verify installation:</p> <pre><code>poetry --version\n</code></pre>"},{"location":"dev/development/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code># Install all dependencies (including dev dependencies)\npoetry install --no-interaction\n\n# Or use make command\nmake install\n</code></pre> <p>To install with docs dependencies:</p> <pre><code>poetry install --with docs\n# Or\nmake install-all\n</code></pre>"},{"location":"dev/development/#4-set-up-pre-commit-hooks","title":"4. Set Up Pre-commit Hooks","text":"<pre><code>poetry run pre-commit install\n</code></pre> <p>This will automatically run code quality checks before each commit.</p>"},{"location":"dev/development/#development-workflow","title":"Development Workflow","text":""},{"location":"dev/development/#running-tests","title":"Running Tests","text":"<p>Run all unit tests:</p> <pre><code>make unit-test\n</code></pre> <p>Run tests with coverage:</p> <pre><code>make unit-test-cov\n</code></pre> <p>Run specific test file:</p> <pre><code>poetry run pytest tests/unit/test_comparison.py\n</code></pre> <p>Run specific test:</p> <pre><code>poetry run pytest tests/unit/test_comparison.py::test_objects_are_equal\n</code></pre> <p>Run tests with verbose output:</p> <pre><code>poetry run pytest -v tests/unit/\n</code></pre>"},{"location":"dev/development/#code-quality","title":"Code Quality","text":"<p>Format code with Black:</p> <pre><code>poetry run black .\n# Or\nmake format\n</code></pre> <p>Run linter (Ruff):</p> <pre><code>make lint\n</code></pre> <p>Format docstrings:</p> <pre><code>make docformat\n</code></pre> <p>Run all pre-commit checks:</p> <pre><code>poetry run pre-commit run --all-files\n</code></pre>"},{"location":"dev/development/#documentation","title":"Documentation","text":"<p>Build documentation locally:</p> <pre><code>poetry run mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>Then open http://127.0.0.1:8000 in your browser.</p> <p>Build documentation without serving:</p> <pre><code>poetry run mkdocs build -f docs/mkdocs.yml\n</code></pre> <p>Run doctests:</p> <pre><code>make doctest-src\n</code></pre>"},{"location":"dev/development/#type-checking","title":"Type Checking","text":"<p>While <code>coola</code> doesn't currently use mypy in CI, you can run type checking locally:</p> <pre><code>poetry run mypy src/coola --ignore-missing-imports\n</code></pre>"},{"location":"dev/development/#project-structure","title":"Project Structure","text":"<pre><code>coola/\n\u251c\u2500\u2500 .github/               # GitHub configuration\n\u2502   \u251c\u2500\u2500 workflows/        # CI/CD workflows\n\u2502   \u251c\u2500\u2500 CONTRIBUTING.md   # Contribution guidelines\n\u2502   \u2514\u2500\u2500 ISSUE_TEMPLATE/   # Issue templates\n\u251c\u2500\u2500 docs/                 # Documentation\n\u2502   \u251c\u2500\u2500 docs/            # Documentation source\n\u2502   \u2514\u2500\u2500 mkdocs.yml       # MkDocs configuration\n\u251c\u2500\u2500 src/                 # Source code\n\u2502   \u2514\u2500\u2500 coola/\n\u2502       \u251c\u2500\u2500 comparison.py           # Main API\n\u2502       \u251c\u2500\u2500 equality/              # Equality comparison\n\u2502       \u2502   \u251c\u2500\u2500 comparators/      # Type-specific comparators\n\u2502       \u2502   \u251c\u2500\u2500 testers/          # Comparison testers\n\u2502       \u2502   \u2514\u2500\u2500 handlers/         # Comparison handlers\n\u2502       \u2514\u2500\u2500 utils/                # Utility functions\n\u251c\u2500\u2500 tests/               # Test files\n\u2502   \u251c\u2500\u2500 unit/           # Unit tests\n\u2502   \u2514\u2500\u2500 integration/    # Integration tests\n\u251c\u2500\u2500 pyproject.toml      # Project configuration\n\u251c\u2500\u2500 poetry.lock         # Locked dependencies\n\u251c\u2500\u2500 LICENSE             # License file\n\u251c\u2500\u2500 README.md           # Project README\n\u2514\u2500\u2500 SECURITY.md         # Security policy\n</code></pre>"},{"location":"dev/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"dev/development/#adding-a-new-feature","title":"Adding a New Feature","text":"<ol> <li> <p>Create a new branch: <pre><code>git checkout -b feature/my-feature\n</code></pre></p> </li> <li> <p>Implement the feature:</p> <ul> <li>Write code in <code>src/coola/</code></li> <li>Add tests in <code>tests/unit/</code></li> <li>Update documentation in <code>docs/docs/</code></li> </ul> </li> <li> <p>Run tests: <pre><code>make unit-test-cov\n</code></pre></p> </li> <li> <p>Run code quality checks: <pre><code>poetry run pre-commit run --all-files\n</code></pre></p> </li> <li> <p>Commit changes: <pre><code>git add .\ngit commit -m \"Add: brief description of feature\"\n</code></pre></p> </li> <li> <p>Push and create PR: <pre><code>git push origin feature/my-feature\n</code></pre></p> </li> </ol>"},{"location":"dev/development/#fixing-a-bug","title":"Fixing a Bug","text":"<ol> <li> <p>Create a branch: <pre><code>git checkout -b fix/bug-description\n</code></pre></p> </li> <li> <p>Write a failing test that reproduces the bug</p> </li> <li> <p>Fix the bug</p> </li> <li> <p>Verify the test passes: <pre><code>poetry run pytest tests/unit/path/to/test.py\n</code></pre></p> </li> <li> <p>Run full test suite: <pre><code>make unit-test-cov\n</code></pre></p> </li> <li> <p>Commit and push: <pre><code>git commit -m \"Fix: description of bug fix\"\ngit push origin fix/bug-description\n</code></pre></p> </li> </ol>"},{"location":"dev/development/#adding-support-for-a-new-type","title":"Adding Support for a New Type","text":"<ol> <li> <p>Create a new comparator: <pre><code># src/coola/equality/comparators/mytype_.py\nfrom typing import Any\nfrom coola.equality import EqualityConfig\nfrom coola.equality.comparators.base import BaseEqualityComparator\n\n\nclass MyTypeComparator(BaseEqualityComparator):\n    def clone(self) -&gt; \"MyTypeComparator\":\n        return self.__class__()\n\n    def equal(self, actual: Any, expected: Any, config: EqualityConfig) -&gt; bool:\n        # Type check\n        if type(actual) is not type(expected):\n            if config.show_difference:\n                # Log difference\n                pass\n            return False\n\n        # Implement comparison logic\n        return actual == expected\n</code></pre></p> </li> <li> <p>Register the comparator: <pre><code># In the appropriate __init__.py\nfrom coola.equality.testers import EqualityTester\nfrom coola.equality.comparators.mytype_ import MyTypeComparator\n\nEqualityTester.registry[MyType] = MyTypeComparator()\n</code></pre></p> </li> <li> <p>Write tests: <pre><code># tests/unit/equality/comparators/test_mytype_.py\nimport pytest\nfrom coola import objects_are_equal\n\n\ndef test_mytype_equal():\n    obj1 = MyType(...)\n    obj2 = MyType(...)\n    assert objects_are_equal(obj1, obj2)\n</code></pre></p> </li> <li> <p>Update documentation:</p> <ul> <li>Add to <code>docs/docs/types.md</code></li> <li>Add examples to <code>docs/docs/examples.md</code></li> </ul> </li> </ol>"},{"location":"dev/development/#updating-dependencies","title":"Updating Dependencies","text":"<pre><code># Update all dependencies\npoetry update\n\n# Update specific dependency\npoetry update numpy\n\n# Update poetry itself\npoetry self update\n</code></pre>"},{"location":"dev/development/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"dev/development/#writing-good-tests","title":"Writing Good Tests","text":"<ol> <li> <p>Use descriptive names: <pre><code>def test_objects_are_equal_with_identical_dicts_returns_true(): ...\n\n\ndef test_objects_are_equal_with_different_types_returns_false(): ...\n</code></pre></p> </li> <li> <p>Test edge cases:</p> <ul> <li>Empty collections</li> <li>None values</li> <li>Large data</li> <li>Deeply nested structures</li> </ul> </li> <li> <p>Use fixtures for common data: <pre><code>@pytest.fixture\ndef sample_tensor():\n    return torch.randn(10, 10)\n\n\ndef test_tensor_comparison(sample_tensor):\n    result = objects_are_equal(sample_tensor, sample_tensor)\n    assert result is True\n</code></pre></p> </li> <li> <p>Test both success and failure cases: <pre><code>def test_success_case():\n    assert objects_are_equal(obj1, obj2)\n\n\ndef test_failure_case():\n    assert not objects_are_equal(obj1, obj3)\n</code></pre></p> </li> </ol>"},{"location":"dev/development/#running-tests-with-different-configurations","title":"Running Tests with Different Configurations","text":"<p>Run tests for a specific module:</p> <pre><code>poetry run pytest tests/unit/equality/\n</code></pre> <p>Run tests matching a pattern:</p> <pre><code>poetry run pytest -k \"tensor\"\n</code></pre> <p>Run tests with markers:</p> <pre><code>poetry run pytest -m \"slow\"\n</code></pre> <p>Run tests in parallel:</p> <pre><code>poetry run pytest -n auto\n</code></pre>"},{"location":"dev/development/#continuous-integration","title":"Continuous Integration","text":"<p>The project uses GitHub Actions for CI. Workflows are in <code>.github/workflows/</code>:</p> <ul> <li> <p>CI: Runs on every push and PR</p> <ul> <li>Linting</li> <li>Tests</li> <li>Coverage</li> </ul> </li> <li> <p>Documentation: Builds and deploys docs</p> <ul> <li>Builds on every push</li> <li>Deploys on release</li> </ul> </li> <li> <p>Nightly Tests: Tests against latest dependencies</p> <ul> <li>Runs daily</li> <li>Tests multiple Python versions</li> </ul> </li> </ul>"},{"location":"dev/development/#release-process","title":"Release Process","text":"<p>Releases are managed by the maintainers:</p> <ol> <li>Update version in <code>pyproject.toml</code></li> <li>Create and push a git tag</li> <li>GitHub Actions automatically publishes to PyPI</li> <li>Documentation is automatically deployed</li> </ol>"},{"location":"dev/development/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://durandtibo.github.io/coola/</li> <li>GitHub Issues: https://github.com/durandtibo/coola/issues</li> <li>Contributing Guide   : CONTRIBUTING.md</li> </ul>"},{"location":"dev/development/#best-practices","title":"Best Practices","text":"<ol> <li>Write tests first (TDD approach when possible)</li> <li>Keep PRs focused on a single feature or fix</li> <li>Update documentation for user-facing changes</li> <li>Run pre-commit hooks before committing</li> <li>Write clear commit messages</li> <li>Add docstrings to all public APIs</li> <li>Keep dependencies minimal</li> <li>Follow existing code style</li> </ol>"},{"location":"dev/development/#troubleshooting-development-issues","title":"Troubleshooting Development Issues","text":""},{"location":"dev/development/#test-issues","title":"Test Issues","text":"<p>Tests fail after pulling changes:</p> <pre><code># Update dependencies\npoetry install\n# Re-run tests\nmake unit-test\n</code></pre> <p>Import errors in tests:</p> <pre><code># Make sure package is installed in development mode\npoetry install\n</code></pre>"},{"location":"dev/development/#pre-commit-issues","title":"Pre-commit Issues","text":"<p>Pre-commit hooks fail:</p> <pre><code># Update pre-commit hooks\npoetry run pre-commit autoupdate\n# Try running manually\npoetry run pre-commit run --all-files\n</code></pre>"},{"location":"dev/development/#code-review-checklist","title":"Code Review Checklist","text":"<p>Before submitting a PR, ensure:</p> <ul> <li>[ ] All tests pass locally</li> <li>[ ] Code coverage is maintained or improved</li> <li>[ ] Pre-commit hooks pass</li> <li>[ ] Documentation is updated</li> <li>[ ] Commit messages are clear</li> <li>[ ] Code follows project style</li> <li>[ ] No unnecessary dependencies added</li> <li>[ ] Examples are provided for new features</li> <li>[ ] Edge cases are tested</li> </ul>"},{"location":"dev/development/#additional-resources","title":"Additional Resources","text":"<ul> <li>Python Packaging Guide</li> <li>pytest Documentation</li> <li>Poetry Documentation</li> <li>MkDocs Documentation</li> <li>GitHub Actions Documentation</li> </ul>"},{"location":"refs/","title":"Main functions","text":""},{"location":"refs/#comparison","title":"Comparison","text":""},{"location":"refs/#coola.objects_are_allclose","title":"coola.objects_are_allclose","text":"<pre><code>objects_are_allclose(\n    actual: Any,\n    expected: Any,\n    *,\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>The equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are (element-wise) equal within a tolerance, otherwise <code>False</code></p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3), torch.ones(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     [torch.ones(2, 3) + 1e-7, torch.ones(2)],\n...     [torch.ones(2, 3), torch.ones(2) - 1e-7],\n...     rtol=0,\n...     atol=1e-8,\n... )\nFalse\n</code></pre>"},{"location":"refs/#coola.objects_are_equal","title":"coola.objects_are_equal","text":"<pre><code>objects_are_equal(\n    actual: Any,\n    expected: Any,\n    *,\n    equal_nan: bool = False,\n    show_difference: bool = False,\n    tester: BaseEqualityTester | None = None\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s  will be considered as equal.</p> <code>False</code> <code>show_difference</code> <code>bool</code> <p>If <code>True</code>, it shows a difference between the two objects if they are different. This parameter is useful to find the difference between two objects.</p> <code>False</code> <code>tester</code> <code>BaseEqualityTester | None</code> <p>The equality tester. If <code>None</code>, <code>EqualityTester</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two nested data are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     [torch.ones(2, 3), torch.zeros(2)],\n...     [torch.ones(2, 3), torch.zeros(2)],\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal([torch.ones(2, 3), torch.ones(2)], [torch.ones(2, 3), torch.zeros(2)])\nFalse\n</code></pre>"},{"location":"refs/equality/","title":"Equality","text":""},{"location":"refs/equality/#coola.equality.comparators","title":"coola.equality.comparators","text":"<p>Contain the comparators to check if two objects are equal or not.</p>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator","title":"coola.equality.comparators.BaseEqualityComparator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement an equality operator.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator.clone","title":"coola.equality.comparators.BaseEqualityComparator.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseEqualityComparator[T]\n</code></pre> <p>Return a copy of the equality operator.</p> <p>Returns:</p> Type Description <code>BaseEqualityComparator[T]</code> <p>A copy of the equality operator.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; op = DefaultEqualityComparator()\n&gt;&gt;&gt; op_cloned = op.clone()\n&gt;&gt;&gt; op_cloned\nDefaultEqualityComparator()\n&gt;&gt;&gt; op is op_cloned\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.BaseEqualityComparator.equal","title":"coola.equality.comparators.BaseEqualityComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: T, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>T</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.DefaultEqualityComparator","title":"coola.equality.comparators.DefaultEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Any]</code></p> <p>Implement a default equality comparator.</p> <p>The <code>==</code> operator is used to test the equality between the objects.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = DefaultEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42, 42, config)\nTrue\n&gt;&gt;&gt; comparator.equal(\"meow\", \"meov\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.JaxArrayEqualityComparator","title":"coola.equality.comparators.JaxArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[ndarray]</code></p> <p>Implement an equality comparator for <code>jax.numpy.ndarray</code>.</p> Example <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import JaxArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = JaxArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(jnp.ones((2, 3)), jnp.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; comparator.equal(jnp.ones((2, 3)), jnp.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.MappingEqualityComparator","title":"coola.equality.comparators.MappingEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Mapping[Any, Any]]</code></p> <p>Implement a sequence equality comparator.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import MappingEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = MappingEqualityComparator()\n&gt;&gt;&gt; comparator.equal({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2}, config)\nTrue\n&gt;&gt;&gt; comparator.equal({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 4}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.NumpyArrayEqualityComparator","title":"coola.equality.comparators.NumpyArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[ndarray]</code></p> <p>Implement an equality comparator for <code>numpy.ndarray</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import NumpyArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = NumpyArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; comparator.equal(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.NumpyMaskedArrayEqualityComparator","title":"coola.equality.comparators.NumpyMaskedArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[MaskedArray]</code></p> <p>Implement an equality comparator for <code>numpy.ndarray</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import NumpyMaskedArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = NumpyMaskedArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]),\n...     np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     np.ma.array(data=[0.0, 1.0, 1.2], mask=[0, 1, 0]),\n...     np.ma.array(data=[0.0, 1.0, 2.0], mask=[0, 1, 0]),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PandasDataFrameEqualityComparator","title":"coola.equality.comparators.PandasDataFrameEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataFrame]</code></p> <p>Implement an equality comparator for <code>pandas.DataFrame</code>.</p> Example <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PandasDataFrameEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PandasDataFrameEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     pd.DataFrame({\"col\": [1, 2, 3]}),\n...     pd.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PandasSeriesEqualityComparator","title":"coola.equality.comparators.PandasSeriesEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Series]</code></p> <p>Implement an equality comparator for <code>pandas.Series</code>.</p> Example <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PandasSeriesEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PandasSeriesEqualityComparator()\n&gt;&gt;&gt; comparator.equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; comparator.equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PolarsDataFrameEqualityComparator","title":"coola.equality.comparators.PolarsDataFrameEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataFrame]</code></p> <p>Implement an equality comparator for <code>polars.DataFrame</code>.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PolarsDataFrameEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PolarsDataFrameEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     pl.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PolarsLazyFrameEqualityComparator","title":"coola.equality.comparators.PolarsLazyFrameEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[LazyFrame]</code></p> <p>Implement an equality comparator for <code>polars.LazyFrame</code>.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PolarsLazyFrameEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PolarsLazyFrameEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     pl.LazyFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PolarsSeriesEqualityComparator","title":"coola.equality.comparators.PolarsSeriesEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Series]</code></p> <p>Implement an equality comparator for <code>polars.Series</code>.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PolarsSeriesEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PolarsSeriesEqualityComparator()\n&gt;&gt;&gt; comparator.equal(pl.Series([1, 2, 3]), pl.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; comparator.equal(pl.Series([1, 2, 3]), pl.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.PyarrowEqualityComparator","title":"coola.equality.comparators.PyarrowEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Array]</code></p> <p>Implement an equality comparator for <code>`pyarrow.Array</code>s and <code>pyarrow.Table</code>s.</p> <p>Note that <code>config.equal_nan</code>, <code>config.atol</code> and <code>config.rtol</code> arguments are ignored.</p> Example <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import PyarrowEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = PyarrowEqualityComparator()\n&gt;&gt;&gt; comparator.equal(pa.array([1, 2, 3]), pa.array([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; comparator.equal(pa.array([1, 2, 3]), pa.array([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.ScalarEqualityComparator","title":"coola.equality.comparators.ScalarEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Any]</code></p> <p>Implement a default equality comparator.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import ScalarEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = ScalarEqualityComparator()\n&gt;&gt;&gt; comparator.equal(42.0, 42.0, config)\nTrue\n&gt;&gt;&gt; comparator.equal(42.0, 1.0, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.SequenceEqualityComparator","title":"coola.equality.comparators.SequenceEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Sequence[Any]]</code></p> <p>Implement a sequence equality comparator.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = SequenceEqualityComparator()\n&gt;&gt;&gt; comparator.equal([1, 2, 3], [1, 2, 3], config)\nTrue\n&gt;&gt;&gt; comparator.equal([1, 2, 3], [1, 2, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.TorchPackedSequenceEqualityComparator","title":"coola.equality.comparators.TorchPackedSequenceEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[PackedSequence]</code></p> <p>Implement an equality comparator for <code>torch.Tensor</code>.</p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import TorchPackedSequenceEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = TorchTensorEqualityComparator()\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.TorchTensorEqualityComparator","title":"coola.equality.comparators.TorchTensorEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Tensor]</code></p> <p>Implement an equality comparator for <code>torch.Tensor</code>.</p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import TorchTensorEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = TorchTensorEqualityComparator()\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; comparator.equal(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayDataArrayEqualityComparator","title":"coola.equality.comparators.XarrayDataArrayEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[DataArray]</code></p> <p>Implement an equality comparator for <code>xarray.DataArray</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayDataArrayEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayDataArrayEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]),\n...     xr.DataArray(np.arange(6), dims=[\"z\"]),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.DataArray(np.ones(6), dims=[\"z\"]),\n...     xr.DataArray(np.zeros(6), dims=[\"z\"]),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayDatasetEqualityComparator","title":"coola.equality.comparators.XarrayDatasetEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Dataset]</code></p> <p>Implement an equality comparator for <code>xarray.Dataset</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayDatasetEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayDatasetEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.Dataset({\"x\": xr.DataArray(np.arange(6), dims=[\"z\"])}),\n...     xr.Dataset({\"x\": xr.DataArray(np.arange(6), dims=[\"z\"])}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.Dataset({\"x\": xr.DataArray(np.zeros(6), dims=[\"z\"])}),\n...     xr.Dataset({\"x\": xr.DataArray(np.ones(6), dims=[\"z\"])}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.XarrayVariableEqualityComparator","title":"coola.equality.comparators.XarrayVariableEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[Variable]</code></p> <p>Implement an equality comparator for <code>xarray.Variable</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.comparators import XarrayVariableEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; comparator = XarrayVariableEqualityComparator()\n&gt;&gt;&gt; comparator.equal(\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     xr.Variable(dims=[\"z\"], data=np.arange(6)),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; comparator.equal(\n...     xr.Variable(dims=[\"z\"], data=np.zeros(6)),\n...     xr.Variable(dims=[\"z\"], data=np.ones(6)),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.comparators.get_type_comparator_mapping","title":"coola.equality.comparators.get_type_comparator_mapping","text":"<pre><code>get_type_comparator_mapping() -&gt; (\n    dict[type[object], BaseEqualityComparator[Any]]\n)\n</code></pre> <p>Get a default mapping between the types and the equality comparators.</p> <p>Returns:</p> Type Description <code>dict[type[object], BaseEqualityComparator[Any]]</code> <p>The mapping between the types and the equality comparators.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.comparators import get_type_comparator_mapping\n&gt;&gt;&gt; get_type_comparator_mapping()\n{&lt;class 'object'&gt;: DefaultEqualityComparator(),\n &lt;class 'collections.abc.Mapping'&gt;: MappingEqualityComparator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityComparator(), ...}\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers","title":"coola.equality.handlers","text":"<p>Contain the handlers to help to check if two objects are equal or not.</p> <p>The handlers are designed to work with Chain of Responsibility pattern.</p>"},{"location":"refs/equality/#coola.equality.handlers.AbstractEqualityHandler","title":"coola.equality.handlers.AbstractEqualityHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a base class with the default chaining behavior.</p> <p>A child class needs to implement the following method: <code>handle</code>.</p>"},{"location":"refs/equality/#coola.equality.handlers.AbstractEqualityHandler.next_handler","title":"coola.equality.handlers.AbstractEqualityHandler.next_handler  <code>property</code>","text":"<pre><code>next_handler: BaseEqualityHandler | None\n</code></pre> <p>The next handler.</p>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler","title":"coola.equality.handlers.BaseEqualityHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality handler.</p> <p>A child class needs to implement the following methods:</p> <ul> <li><code>handle</code></li> <li><code>set_next_handler</code></li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler, FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.set_next_handler(FalseHandler())\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.chain","title":"coola.equality.handlers.BaseEqualityHandler.chain","text":"<pre><code>chain(handler: BaseEqualityHandler) -&gt; BaseEqualityHandler\n</code></pre> <p>Chain a handler to the current handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>BaseEqualityHandler</code> <p>The handler to chain.</p> required <p>Returns:</p> Type Description <code>BaseEqualityHandler</code> <p>The input handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import (\n...     SameObjectHandler,\n...     SameTypeHandler,\n...     ObjectEqualHandler,\n... )\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.chain(SameTypeHandler()).chain(ObjectEqualHandler())\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3], config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.handle","title":"coola.equality.handlers.BaseEqualityHandler.handle  <code>abstractmethod</code>","text":"<pre><code>handle(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Return the equality result between the two input objects.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input objects are equal, and <code>False</code> otherwise.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.BaseEqualityHandler.set_next_handler","title":"coola.equality.handlers.BaseEqualityHandler.set_next_handler  <code>abstractmethod</code>","text":"<pre><code>set_next_handler(handler: BaseEqualityHandler) -&gt; None\n</code></pre> <p>Set the next handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>BaseEqualityHandler</code> <p>The next handler.</p> required Example <pre><code>&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler, TrueHandler\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.set_next_handler(TrueHandler())\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.EqualHandler","title":"coola.equality.handlers.EqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects are different data, otherwise it returns <code>True</code>. The first object must have a <code>equal</code> attribute which indicates if the two objects are equal or not.</p> Example <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import EqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyFloat:\n...     def __init__(self, value: float) -&gt; None:\n...         self._value = value\n...     def equal(self, other: float) -&gt; bool:\n...         return self._value == other\n...\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = EqualHandler()\n&gt;&gt;&gt; handler.handle(MyFloat(42), 42, config)\nTrue\n&gt;&gt;&gt; handler.handle(MyFloat(42), float(\"nan\"), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.EqualNanHandler","title":"coola.equality.handlers.EqualNanHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects are different data, otherwise it returns <code>True</code>. The first object must have a <code>equal</code> attribute which indicates if the two objects are equal or not.</p> Example <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import EqualNanHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyFloat:\n...     def __init__(self, value: float) -&gt; None:\n...         self._value = value\n...     def equal(self, other: float, equal_nan: bool = False) -&gt; bool:\n...         if equal_nan and math.isnan(self._value) and math.isnan(other):\n...             return True\n...         return self._value == other\n...\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = EqualNanHandler()\n&gt;&gt;&gt; handler.handle(MyFloat(42), 42, config)\nTrue\n&gt;&gt;&gt; handler.handle(MyFloat(float(\"nan\")), float(\"nan\"), config)\nFalse\n&gt;&gt;&gt; config.equal_nan = True\n&gt;&gt;&gt; handler.handle(MyFloat(float(\"nan\")), float(\"nan\"), config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.FalseHandler","title":"coola.equality.handlers.FalseHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a handler that always returns <code>False</code>.</p> <p>This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = FalseHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nFalse\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.JaxArrayEqualHandler","title":"coola.equality.handlers.JaxArrayEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two JAX arrays are equal.</p> <p>This handler returns <code>True</code> if the two arrays are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import jax.numpy as jnp\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import JaxArrayEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = JaxArrayEqualHandler()\n&gt;&gt;&gt; handler.handle(jnp.ones((2, 3)), jnp.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(jnp.ones((2, 3)), jnp.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.MappingSameKeysHandler","title":"coola.equality.handlers.MappingSameKeysHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same keys.</p> <p>This handler returns <code>False</code> if the two objects have different keys, otherwise it passes the inputs to the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import MappingSameKeysHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = MappingSameKeysHandler()\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2, \"c\": 1}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.MappingSameValuesHandler","title":"coola.equality.handlers.MappingSameValuesHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the key-value pairs in the first mapping are in the second mapping.</p> <p>This handler returns <code>False</code> if the one of the key-value pair in the first mapping is not in the second mapping, otherwise it passes the inputs to the next handler.</p> Notes <p>This handler assumes that all the keys in the first mapping are also in the second mapping. The second mapping can have more keys. To check if two mappings are equal, you can combine this handler with <code>MappingSameKeysHandler</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import MappingSameValuesHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = MappingSameValuesHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2}, config)\nTrue\n&gt;&gt;&gt; handler.handle({\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 3}, config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.NanEqualHandler","title":"coola.equality.handlers.NanEqualHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two NaNs are equal.</p> <p>This handler returns <code>True</code> if the two numbers are NaNs, otherwise it passes the inputs to the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import NanEqualHandler, FalseHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = NanEqualHandler(next_handler=FalseHandler())\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nFalse\n&gt;&gt;&gt; config.equal_nan = True\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.NumpyArrayEqualHandler","title":"coola.equality.handlers.NumpyArrayEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two NumPy arrays are equal.</p> <p>This handler returns <code>True</code> if the two arrays are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import NumpyArrayEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = NumpyArrayEqualHandler()\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.ObjectEqualHandler","title":"coola.equality.handlers.ObjectEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two objects are equal using the default equality operator <code>==</code>.</p> <p>This handler returns <code>True</code> if the two objects are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import ObjectEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = ObjectEqualHandler()\n&gt;&gt;&gt; handler.handle(1, 1, config)\nTrue\n&gt;&gt;&gt; handler.handle(1, \"abc\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PandasDataFrameEqualHandler","title":"coola.equality.handlers.PandasDataFrameEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>pandas.DataFrame</code> are equal.</p> <p>This handler returns <code>True</code> if the two <code>pandas.DataFrame</code>s equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PandasDataFrameEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PandasDataFrameEqualHandler()\n&gt;&gt;&gt; handler.handle(\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; handler.handle(\n...     pandas.DataFrame({\"col\": [1, 2, 3]}),\n...     pandas.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PandasSeriesEqualHandler","title":"coola.equality.handlers.PandasSeriesEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>pandas.Series</code> are equal.</p> <p>This handler returns <code>True</code> if the two arrays <code>pandas.Series</code> equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import pandas\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PandasSeriesEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PandasSeriesEqualHandler()\n&gt;&gt;&gt; handler.handle(pandas.Series([1, 2, 3]), pandas.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; handler.handle(pandas.Series([1, 2, 3]), pandas.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PolarsDataFrameEqualHandler","title":"coola.equality.handlers.PolarsDataFrameEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>polars.DataFrame</code> are equal.</p> <p>This handler returns <code>True</code> if the two <code>polars.DataFrame</code>s equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PolarsDataFrameEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PolarsDataFrameEqualHandler()\n&gt;&gt;&gt; handler.handle(\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; handler.handle(\n...     pl.DataFrame({\"col\": [1, 2, 3]}),\n...     pl.DataFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PolarsLazyFrameEqualHandler","title":"coola.equality.handlers.PolarsLazyFrameEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>polars.LazyFrame</code> are equal.</p> <p>This handler returns <code>True</code> if the two <code>polars.LazyFrame</code>s equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PolarsLazyFrameEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PolarsLazyFrameEqualHandler()\n&gt;&gt;&gt; handler.handle(\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     config,\n... )\nTrue\n&gt;&gt;&gt; handler.handle(\n...     pl.LazyFrame({\"col\": [1, 2, 3]}),\n...     pl.LazyFrame({\"col\": [1, 2, 4]}),\n...     config,\n... )\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PolarsSeriesEqualHandler","title":"coola.equality.handlers.PolarsSeriesEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two <code>polars.Series</code> are equal.</p> <p>This handler returns <code>True</code> if the two arrays <code>polars.Series</code> equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PolarsSeriesEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PolarsSeriesEqualHandler()\n&gt;&gt;&gt; handler.handle(pl.Series([1, 2, 3]), pl.Series([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; handler.handle(pl.Series([1, 2, 3]), pl.Series([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.PyarrowEqualHandler","title":"coola.equality.handlers.PyarrowEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two pyarrow arrays or tables are equal.</p> <p>This handler returns <code>True</code> if the two arrays or tables are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> <p>Note that <code>config.equal_nan</code>, <code>config.atol</code> and <code>config.rtol</code> arguments are ignored.</p> Example <pre><code>&gt;&gt;&gt; import pyarrow\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import PyarrowEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = PyarrowEqualHandler()\n&gt;&gt;&gt; handler.handle(pyarrow.array([1, 2, 3]), pyarrow.array([1, 2, 3]), config)\nTrue\n&gt;&gt;&gt; handler.handle(pyarrow.array([1, 2, 3]), pyarrow.array([1, 2, 4]), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameAttributeHandler","title":"coola.equality.handlers.SameAttributeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same attribute.</p> <p>This handler returns <code>False</code> if the two objects have different attributes, otherwise it passes the inputs to the next handler. The objects must have the attribute.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameAttributeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameAttributeHandler(name=\"shape\", next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((3, 2)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameDTypeHandler","title":"coola.equality.handlers.SameDTypeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same data type.</p> <p>This handler returns <code>False</code> if the two objects have different data types, otherwise it passes the inputs to the next handler. The objects must have a <code>dtype</code> attribute (e.g. <code>object.dtype</code>) which returns the shape of the object. This handler works on <code>numpy.ndarray</code>s and <code>torch.Tensor</code>s objects.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameDTypeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameDTypeHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3), dtype=float), np.ones((2, 3), dtype=int), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameDataHandler","title":"coola.equality.handlers.SameDataHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same data.</p> <p>This handler returns <code>False</code> if the two objects have different data, otherwise it passes the inputs to the next handler. The objects must have a <code>data</code> attribute (e.g. <code>object.data</code>) which returns the shape of the object.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameDataHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameDataHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.zeros((2, 3)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameLengthHandler","title":"coola.equality.handlers.SameLengthHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same length.</p> <p>This handler returns <code>False</code> if the two objects have different lengths, otherwise it passes the inputs to the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameLengthHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameLengthHandler()\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameObjectHandler","title":"coola.equality.handlers.SameObjectHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects refer to the same object.</p> <p>This handler returns <code>True</code> if the two objects refer to the same object, otherwise it passes the inputs to the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameObjectHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameObjectHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameShapeHandler","title":"coola.equality.handlers.SameShapeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same shape.</p> <p>This handler returns <code>False</code> if the two objects have different shapes, otherwise it passes the inputs to the next handler. The objects must have a <code>shape</code> attribute (e.g. <code>object.shape</code>) which returns the shape of the object. This handler works on <code>jax.numpy.ndarray</code>s, <code>numpy.ndarray</code>s, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> and <code>torch.Tensor</code>s objects.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameShapeHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameShapeHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((2, 3)), config)\nTrue\n&gt;&gt;&gt; handler.handle(np.ones((2, 3)), np.ones((3, 2)), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SameTypeHandler","title":"coola.equality.handlers.SameTypeHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two objects have the same type.</p> <p>This handler returns <code>False</code> if the two objects have different types, otherwise it passes the inputs to the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SameTypeHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SameTypeHandler()\n&gt;&gt;&gt; handler.handle(1, \"abc\", config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.ScalarEqualHandler","title":"coola.equality.handlers.ScalarEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two numbers are equal or not.</p> <p>This handler returns <code>False</code> if the two numbers are different, otherwise it returns <code>True</code>. It is possible to control the tolerance by using <code>atol</code> and <code>rtol</code>. By default, the tolerances are set to 0.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import ScalarEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = ScalarEqualHandler()\n&gt;&gt;&gt; handler.handle(42.0, 42.0, config)\nTrue\n&gt;&gt;&gt; config.atol = 1e-3\n&gt;&gt;&gt; handler.handle(42.0, 42.0001, config)\nTrue\n&gt;&gt;&gt; handler.handle(float(\"nan\"), float(\"nan\"), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.SequenceSameValuesHandler","title":"coola.equality.handlers.SequenceSameValuesHandler","text":"<p>               Bases: <code>AbstractEqualityHandler</code></p> <p>Check if the two sequences have the same values.</p> <p>This handler returns <code>False</code> if the two sequences have at least one different value, otherwise it passes the inputs to the next handler. If the sequences have different length, this handler checks only the values of the shortest sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import SequenceSameValuesHandler, TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = SequenceSameValuesHandler(next_handler=TrueHandler())\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 3], config)\nTrue\n&gt;&gt;&gt; handler.handle([1, 2, 3], [1, 2, 4], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.TorchTensorEqualHandler","title":"coola.equality.handlers.TorchTensorEqualHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Check if the two tensors are equal.</p> <p>This handler returns <code>True</code> if the two tensors are equal, otherwise <code>False</code>. This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers.torch_ import TorchTensorEqualHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = TorchTensorEqualHandler()\n&gt;&gt;&gt; handler.handle(torch.ones(2, 3), torch.ones(2, 3), config)\nTrue\n&gt;&gt;&gt; handler.handle(torch.ones(2, 3), torch.zeros(2, 3), config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.handlers.TrueHandler","title":"coola.equality.handlers.TrueHandler","text":"<p>               Bases: <code>BaseEqualityHandler</code></p> <p>Implement a handler that always returns <code>True</code>.</p> <p>This handler is designed to be used at the end of the chain of responsibility. This handler does not call the next handler.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.handlers import TrueHandler\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; config = EqualityConfig(tester=EqualityTester())\n&gt;&gt;&gt; handler = TrueHandler()\n&gt;&gt;&gt; handler.handle(\"abc\", \"abc\", config)\nTrue\n&gt;&gt;&gt; handler.handle(\"abc\", \"ABC\", config)\nTrue\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers","title":"coola.equality.testers","text":"<p>Contain the testers to check if two objects are equal or not.</p>"},{"location":"refs/equality/#coola.equality.testers.BaseEqualityTester","title":"coola.equality.testers.BaseEqualityTester","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality tester.</p>"},{"location":"refs/equality/#coola.equality.testers.BaseEqualityTester.equal","title":"coola.equality.testers.BaseEqualityTester.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; config = EqualityConfig(tester=tester)\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.zeros(2)], [np.ones((2, 3)), np.zeros(2)], config)\nTrue\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.ones(2)], [np.ones((2, 3)), np.zeros(2)], config)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester","title":"coola.equality.testers.EqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement the default equality tester.</p>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.add_comparator","title":"coola.equality.testers.EqualityTester.add_comparator  <code>classmethod</code>","text":"<pre><code>add_comparator(\n    data_type: type[T],\n    comparator: BaseEqualityComparator[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator[T]</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a comparator is already registered for the data type and <code>exist_ok=False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; EqualityTester.add_comparator(list, SequenceEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.find_comparator","title":"coola.equality.testers.EqualityTester.find_comparator  <code>classmethod</code>","text":"<pre><code>find_comparator(\n    data_type: type[T],\n) -&gt; BaseEqualityComparator[T]\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator[T]</code> <p>The equality comparator associated to the data type.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; EqualityTester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.has_comparator","title":"coola.equality.testers.EqualityTester.has_comparator  <code>classmethod</code>","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.has_comparator(list)\nTrue\n&gt;&gt;&gt; EqualityTester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.EqualityTester.local_copy","title":"coola.equality.testers.EqualityTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalEqualityTester\n</code></pre> <p>Return a copy of <code>EqualityTester</code> that can easily be customized without changind <code>EqualityTester</code>.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A \"local\" copy of <code>EqualityTester</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester\nLocalEqualityTester(...)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester","title":"coola.equality.testers.LocalEqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type[object], BaseEqualityComparator[Any]] | None</code> <p>The initial registry with the equality comparators.</p> <code>None</code>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.add_comparator","title":"coola.equality.testers.LocalEqualityTester.add_comparator","text":"<pre><code>add_comparator(\n    data_type: type[T],\n    comparator: BaseEqualityComparator[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator[T]</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an comparator is already registered for the data type and <code>exist_ok=False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator())\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.clone","title":"coola.equality.testers.LocalEqualityTester.clone","text":"<pre><code>clone() -&gt; LocalEqualityTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A deep copy of the current tester.</p> Example <p>```pycon</p> <p>from coola.equality.testers import EqualityTester tester = EqualityTester.local_copy() tester_cloned = tester.clone()</p> <pre><code>```\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.find_comparator","title":"coola.equality.testers.LocalEqualityTester.find_comparator","text":"<pre><code>find_comparator(\n    data_type: type[T],\n) -&gt; BaseEqualityComparator[T]\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator[T]</code> <p>The equality comparator associated to the data type.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; tester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/equality/#coola.equality.testers.LocalEqualityTester.has_comparator","title":"coola.equality.testers.LocalEqualityTester.has_comparator","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.has_comparator(list)\nTrue\n&gt;&gt;&gt; tester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/iterator/","title":"Iterator","text":""},{"location":"refs/iterator/#coola.iterator","title":"coola.iterator","text":"<p>Contain code to iterate over nested data.</p>"},{"location":"refs/iterator/#coola.iterator.bfs_iterate","title":"coola.iterator.bfs_iterate","text":"<pre><code>bfs_iterate(\n    data: Any, registry: ChildFinderRegistry | None = None\n) -&gt; Iterator[Any]\n</code></pre> <p>Perform Breadth-First Search (BFS) iteration over nested data structures (lists, dicts, tuples, sets, etc.).</p> <p>This function yields elements from the data structure in a BFS manner, recursively traversing all levels of nested structures. It uses the appropriate child finders registered for the data types (e.g., lists, dictionaries, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The nested data structure to traverse. Can be a list, tuple, dict, set, or any other registered type.</p> required <code>registry</code> <code>ChildFinderRegistry | None</code> <p>The registry to resolve iterators for nested data. If <code>None</code>, the default registry is used.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>Atomic leaf values in BFS order (excludes containers even if empty)</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate\n&gt;&gt;&gt; list(bfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(bfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs_iterate","title":"coola.iterator.dfs_iterate","text":"<pre><code>dfs_iterate(\n    data: Any, registry: IteratorRegistry | None = None\n) -&gt; Iterator[Any]\n</code></pre> <p>Perform Depth-First Search (DFS) iteration over nested data structures (lists, dicts, tuples, sets, etc.).</p> <p>This function yields elements from the data structure in a DFS manner, recursively traversing all levels of nested structures. It uses the appropriate iterators registered for the data types (e.g., lists, dictionaries, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The nested data structure to traverse. Can be a list, tuple, dict, set, or any other registered type.</p> required <code>registry</code> <code>IteratorRegistry | None</code> <p>The registry to resolve iterators for nested data. If <code>None</code>, the default registry is used.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>The elements from the nested data structure in DFS order.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; list(dfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(dfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.filter_by_type","title":"coola.iterator.filter_by_type","text":"<pre><code>filter_by_type(\n    iterator: Iterable[Any],\n    types: type[T] | tuple[type, ...],\n) -&gt; Iterator[T]\n</code></pre> <p>Filter an iterator to yield only values of specified types.</p> <p>This function acts as a type-safe filter that passes through only values matching the specified type(s). It's particularly useful when working with heterogeneous collections where you need to extract elements of specific types.</p> <p>Parameters:</p> Name Type Description Default <code>iterator</code> <code>Iterable[Any]</code> <p>An iterator or iterable to filter. Can contain values of any type.</p> required <code>types</code> <code>type[T] | tuple[type, ...]</code> <p>A single type or tuple of types to filter for. Only values that are instances of these types will be yielded. Follows the same semantics as the built-in isinstance() function.</p> required <p>Yields:</p> Type Description <code>T</code> <p>Values from the input iterator that are instances of any of the specified</p> <code>T</code> <p>types, preserving the original order of elements.</p> Example <p>Filter mixed-type list to get only integers:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import filter_by_type\n&gt;&gt;&gt; list(filter_by_type([1, \"hello\", 2, 3.14, \"world\", 4], int))\n[1, 2, 4]\n</code></pre> <p>Filter for multiple types:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import filter_by_type\n&gt;&gt;&gt; # Note: bool is a subclass of int\n&gt;&gt;&gt; list(filter_by_type([1, \"hello\", 2.5, True, None, [1, 2]], (int, float)))\n[1, 2.5, True]\n</code></pre> Notes <ul> <li>This function uses isinstance() internally, so subclass relationships   are respected (e.g., bool values will match int type).</li> <li>The input iterator is consumed as items are yielded.</li> <li>For empty iterators or when no items match, the generator yields nothing.</li> </ul>"},{"location":"refs/iterator/#coola.iterator.bfs","title":"coola.iterator.bfs","text":"<p>Contain code to iterate over nested data with a Breadth-First Search (BFS) strategy.</p>"},{"location":"refs/iterator/#coola.iterator.bfs.BaseChildFinder","title":"coola.iterator.bfs.BaseChildFinder","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for child finders used in breadth-first search.</p> <p>This class defines the interface that all child finders must implement. Child finders are responsible for finding and yielding the immediate children of a given data structure. Custom child finders can be registered with a <code>ChildFinderRegistry</code> to handle specific data types during BFS traversal.</p> <p>The generic type parameter <code>T</code> indicates the type of data this child finder is designed to handle.</p> Notes <ul> <li>Subclasses must implement the <code>find_children</code> method.</li> <li>For leaf types (types with no children), simply return without yielding.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import DefaultChildFinder\n&gt;&gt;&gt; child_finder = DefaultChildFinder()\n&gt;&gt;&gt; list(child_finder.find_children(42))\n[]\n&gt;&gt;&gt; list(child_finder.find_children(\"hello\"))\n[]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.BaseChildFinder.find_children","title":"coola.iterator.bfs.BaseChildFinder.find_children  <code>abstractmethod</code>","text":"<pre><code>find_children(data: T) -&gt; Iterator[Any]\n</code></pre> <p>Find and yield the immediate children of the given data structure.</p> <p>This method defines how to extract children from the data structure. For container types, this typically means yielding the contained elements. For leaf types, this method should return without yielding anything.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data structure whose children should be found.</p> required <p>Yields:</p> Type Description <code>Any</code> <p>The immediate children of the data structure. The type of yielded</p> <code>Any</code> <p>elements depends on the specific data structure being processed.</p> Notes <ul> <li>This method should only yield direct children, not recurse deeply.</li> <li>The BFS traversal logic handles visiting children recursively.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import DefaultChildFinder\n&gt;&gt;&gt; child_finder = DefaultChildFinder()\n&gt;&gt;&gt; list(child_finder.find_children(42))\n[]\n&gt;&gt;&gt; list(child_finder.find_children(\"hello\"))\n[]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry","title":"coola.iterator.bfs.ChildFinderRegistry","text":"<p>Registry that manages child finders for breadth-first traversal of nested data structures.</p> <p>This registry maps Python data types to <code>BaseChildFinder</code> instances. During traversal, the registry selects the most specific child finder for a given object using Method Resolution Order (MRO). If no match is found, a default child finder is used.</p> <p>The registry also caches resolved child finders to speed up repeated lookups.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[type, BaseChildFinder[Any]] | None</code> <p>An optional dictionary mapping Python types to <code>BaseChildFinder</code> instances. If provided, the registry is initialized with this mapping.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>TypeRegistry[BaseChildFinder]</code> <p>Mapping of registered data types to child finders.</p> Example <p>Basic usage with a flat iterable:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     DefaultChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry(\n...     {object: DefaultChildFinder(), list: IterableChildFinder()}\n... )\n&gt;&gt;&gt; list(registry.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre> <p>Working with nested structures using the default registry:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; list(registry.iterate(data))\n[1, 2, 3, 4]\n</code></pre> <p>Breadth-first traversal over mixed nested data:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     MappingChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry(\n...     {\n...         object: DefaultChildFinder(),\n...         list: IterableChildFinder(),\n...         dict: MappingChildFinder(),\n...     }\n... )\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4], \"c\": 5, \"d\": {\"e\": 6}}\n&gt;&gt;&gt; list(registry.iterate(data))\n[5, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.find_child_finder","title":"coola.iterator.bfs.ChildFinderRegistry.find_child_finder","text":"<pre><code>find_child_finder(data_type: type) -&gt; BaseChildFinder[Any]\n</code></pre> <p>Find the appropriate child finder for a given data type.</p> <p>This method resolves the child finder using MRO lookup and caches the result for faster subsequent access.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for which to find a child finder.</p> required <p>Returns:</p> Type Description <code>BaseChildFinder[Any]</code> <p>The resolved child finder instance.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     DefaultChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry(\n...     {object: DefaultChildFinder(), list: IterableChildFinder()}\n... )\n&gt;&gt;&gt; registry.find_child_finder(list)\nIterableChildFinder()\n&gt;&gt;&gt; registry.find_child_finder(tuple)\nDefaultChildFinder()\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.find_children","title":"coola.iterator.bfs.ChildFinderRegistry.find_children","text":"<pre><code>find_children(data: Any) -&gt; Iterator[Any]\n</code></pre> <p>Return the immediate children of an object using its child finder.</p> <p>This method does not perform traversal by itself. It delegates to the appropriate child finder for the object's type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The object whose children should be extracted.</p> required <p>Yields:</p> Type Description <code>Any</code> <p>Child objects as defined by the resolved child finder.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     DefaultChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry(\n...     {object: DefaultChildFinder(), list: IterableChildFinder()}\n... )\n&gt;&gt;&gt; list(registry.find_children([1, 2, 3]))\n[1, 2, 3]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.has_child_finder","title":"coola.iterator.bfs.ChildFinderRegistry.has_child_finder","text":"<pre><code>has_child_finder(data_type: type) -&gt; bool\n</code></pre> <p>Check if a child finder is directly registered for a data type.</p> <p>This method only checks for an exact type match in the registry. Even if this returns <code>False</code>, a suitable child finder may still be resolved via MRO lookup.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a child finder is directly registered for the type, <code>False</code> otherwise.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import ChildFinderRegistry, IterableChildFinder\n&gt;&gt;&gt; registry = ChildFinderRegistry({list: IterableChildFinder()})\n&gt;&gt;&gt; registry.has_child_finder(list)\nTrue\n&gt;&gt;&gt; registry.has_child_finder(tuple)\nFalse\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.iterate","title":"coola.iterator.bfs.ChildFinderRegistry.iterate","text":"<pre><code>iterate(data: Any) -&gt; Iterator[Any]\n</code></pre> <p>Perform a breadth-first traversal over a nested data structure.</p> <p>This method traverses the input data using breadth-first search (BFS). Container objects (mappings and iterables, excluding strings and bytes) are expanded using registered child finders. Only non-container (leaf) values are yielded.</p> <p>Containers themselves are never yielded, even if they are empty.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data structure to traverse.</p> required <p>Yields:</p> Type Description <code>Any</code> <p>Atomic (non-container) values in breadth-first order.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     MappingChildFinder,\n...     DefaultChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry(\n...     {\n...         object: DefaultChildFinder(),\n...         list: IterableChildFinder(),\n...         dict: MappingChildFinder(),\n...     }\n... )\n&gt;&gt;&gt; list(registry.iterate({\"a\": [1, 2], \"b\": [3, 4], \"c\": 5, \"d\": {\"e\": 6}}))\n[5, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.register","title":"coola.iterator.bfs.ChildFinderRegistry.register","text":"<pre><code>register(\n    data_type: type,\n    child_finder: BaseChildFinder[Any],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register a child finder for a given data type.</p> <p>This method associates a specific <code>BaseChildFinder</code> with a Python type. When an object of this type (or a subclass) is encountered during traversal, the registered child finder will be used.</p> <p>The internal cache is cleared after registration to ensure consistency.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to register (e.g., <code>list</code>, <code>dict</code>, or a custom class).</p> required <code>child_finder</code> <code>BaseChildFinder[Any]</code> <p>The child finder instance responsible for extracting children from objects of this type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, allows overwriting an existing registration. If <code>False</code>, raises an error.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the type is already registered and <code>exist_ok</code> is <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import ChildFinderRegistry, IterableChildFinder\n&gt;&gt;&gt; registry = ChildFinderRegistry()\n&gt;&gt;&gt; registry.register(list, IterableChildFinder())\n&gt;&gt;&gt; registry.has_child_finder(list)\nTrue\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.ChildFinderRegistry.register_many","title":"coola.iterator.bfs.ChildFinderRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[type, BaseChildFinder[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple child finders at once.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseChildFinder[Any]]</code> <p>A mapping from Python types to their corresponding child finders.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, allows overwriting existing registrations.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any type is already registered and <code>exist_ok</code> is <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     ChildFinderRegistry,\n...     IterableChildFinder,\n...     MappingChildFinder,\n... )\n&gt;&gt;&gt; registry = ChildFinderRegistry()\n&gt;&gt;&gt; registry.register_many({list: IterableChildFinder(), dict: MappingChildFinder()})\n&gt;&gt;&gt; registry.has_child_finder(list), registry.has_child_finder(dict)\n(True, True)\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.DefaultChildFinder","title":"coola.iterator.bfs.DefaultChildFinder","text":"<p>               Bases: <code>BaseChildFinder[Any]</code></p> <p>Default child finder for breadth-first search traversal.</p> <pre><code>This child finder serves as the fallback handler for objects that don't have\na specialized child finder registered. It treats the input data as a leaf node\nwith no children, so it yields nothing during traversal.\n\nThe DefaultChildFinder is typically used for:\n- Primitive types (int, float, str, bool, None)\n- Objects without internal structure to traverse\n- Terminal nodes in a data structure\n</code></pre> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import DefaultChildFinder\n&gt;&gt;&gt; child_finder = DefaultChildFinder()\n&gt;&gt;&gt; list(child_finder.find_children(42))\n[]\n&gt;&gt;&gt; list(child_finder.find_children(\"hello\"))\n[]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.IterableChildFinder","title":"coola.iterator.bfs.IterableChildFinder","text":"<p>               Bases: <code>BaseChildFinder[Iterable[Any]]</code></p> <p>Child finder for iterable objects.</p> <p>This child finder handles iterable objects by yielding each element of the iterable. It works with lists, tuples, sets, strings, and any object implementing the Iterable protocol.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import IterableChildFinder\n&gt;&gt;&gt; child_finder = IterableChildFinder()\n&gt;&gt;&gt; list(child_finder.find_children((4, 2, 1)))\n[4, 2, 1]\n&gt;&gt;&gt; list(child_finder.find_children(\"hello\"))\n['h', 'e', 'l', 'l', 'o']\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.MappingChildFinder","title":"coola.iterator.bfs.MappingChildFinder","text":"<p>               Bases: <code>BaseChildFinder[Mapping[Any, Any]]</code></p> <p>Child finder for mapping objects.</p> <p>This child finder handles mapping objects by yielding the values from the mapping. It works with dictionaries and any object implementing the Mapping protocol.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import MappingChildFinder\n&gt;&gt;&gt; child_finder = MappingChildFinder()\n&gt;&gt;&gt; list(child_finder.find_children({\"a\": 1, \"b\": 2}))\n[1, 2]\n&gt;&gt;&gt; list(child_finder.find_children({\"a\": {\"b\": 1, \"c\": 2}, \"d\": 3}))\n[{'b': 1, 'c': 2}, 3]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.bfs_iterate","title":"coola.iterator.bfs.bfs_iterate","text":"<pre><code>bfs_iterate(\n    data: Any, registry: ChildFinderRegistry | None = None\n) -&gt; Iterator[Any]\n</code></pre> <p>Perform Breadth-First Search (BFS) iteration over nested data structures (lists, dicts, tuples, sets, etc.).</p> <p>This function yields elements from the data structure in a BFS manner, recursively traversing all levels of nested structures. It uses the appropriate child finders registered for the data types (e.g., lists, dictionaries, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The nested data structure to traverse. Can be a list, tuple, dict, set, or any other registered type.</p> required <code>registry</code> <code>ChildFinderRegistry | None</code> <p>The registry to resolve iterators for nested data. If <code>None</code>, the default registry is used.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>Atomic leaf values in BFS order (excludes containers even if empty)</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate\n&gt;&gt;&gt; list(bfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(bfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.get_default_registry","title":"coola.iterator.bfs.get_default_registry","text":"<pre><code>get_default_registry() -&gt; ChildFinderRegistry\n</code></pre> <p>Get or create the default global registry for child finders.</p> <p>This function returns a singleton instance of the <code>ChildFinderRegistry</code>, which is pre-configured with child finders for common Python types, including iterables (lists, tuples), mappings (dicts), sets, and scalars (int, float, str, bool). The registry is used to look up the appropriate child finder for a given data structure during iteration.</p> <p>Returns:</p> Type Description <code>ChildFinderRegistry</code> <p>An <code>ChildFinderRegistry</code> instance with child finders registered for common Python types.</p> Notes <p>The singleton pattern means any changes to the returned registry affect all future calls to this function. If an isolated registry is needed, create a new <code>ChildFinderRegistry</code> instance directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import get_default_registry\n&gt;&gt;&gt; reg = get_default_registry()\n&gt;&gt;&gt; list(reg.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.bfs.register_child_finders","title":"coola.iterator.bfs.register_child_finders","text":"<pre><code>register_child_finders(\n    mapping: Mapping[type, BaseChildFinder[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom child finders to the default global registry.</p> <p>This allows users to add support for custom types without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseChildFinder[Any]]</code> <p>A dictionary mapping Python types to their corresponding child finder instances.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, existing registrations for types will be overwritten. If <code>False</code>, an error is raised when a type is already registered.</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import (\n...     register_child_finders,\n...     IterableChildFinder,\n...     ChildFinderRegistry,\n... )\n&gt;&gt;&gt; register_child_finders({list: IterableChildFinder()}, exist_ok=True)\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; list(registry.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs","title":"coola.iterator.dfs","text":"<p>Contain code to iterate over nested data with a Depth-First Search (DFS) strategy.</p>"},{"location":"refs/iterator/#coola.iterator.dfs.BaseIterator","title":"coola.iterator.dfs.BaseIterator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for depth-first search iterators.</p> <p>This class defines the interface that all DFS iterators must implement. Iterators are responsible for traversing specific data types and yielding their elements during depth-first search traversal. Custom iterators can be registered with an <code>IteratorRegistry</code> to handle specific data types.</p> <p>The generic type parameter <code>T</code> indicates the type of data this iterator is designed to handle, though the <code>iterate</code> method accepts <code>Any</code> for flexibility.</p> Notes <ul> <li>Subclasses must implement the <code>iterate</code> method.</li> <li>For container types, use <code>registry.iterate()</code> to recursively   traverse nested structures.</li> <li>For leaf types, simply yield the data directly.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, DefaultIterator\n&gt;&gt;&gt; iterator = DefaultIterator()\n&gt;&gt;&gt; registry = IteratorRegistry()\n&gt;&gt;&gt; list(iterator.iterate(42, registry))\n[42]\n&gt;&gt;&gt; list(iterator.iterate(\"hello\", registry))\n['hello']\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.BaseIterator.iterate","title":"coola.iterator.dfs.BaseIterator.iterate  <code>abstractmethod</code>","text":"<pre><code>iterate(\n    data: T, registry: IteratorRegistry\n) -&gt; Iterator[Any]\n</code></pre> <p>Traverse the data structure and yield elements depth-first.</p> <p>This method defines how the iterator traverses its associated data type. For container or composite types, it should recursively traverse nested elements using <code>registry.iterate()</code> to delegate to appropriate iterators. For leaf types, it should yield the data directly.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data structure to traverse. While typed as <code>T</code> for flexibility, implementations typically expect a specific type corresponding to the iterator's purpose.</p> required <code>registry</code> <code>IteratorRegistry</code> <p>The iterator registry used to resolve and dispatch iterators for nested data structures. Use <code>registry.iterate()</code> to recursively traverse nested elements.</p> required <p>Yields:</p> Type Description <code>Any</code> <p>Elements found during depth-first traversal. The exact type and</p> <code>Any</code> <p>nature of yielded elements depends on the specific iterator</p> <code>Any</code> <p>implementation and traversal strategy.</p> Notes <ul> <li>The registry parameter should be used to maintain consistent   traversal behavior across different data types.</li> <li>Implementations should handle the specific structure of their   target data type appropriately.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, DefaultIterator\n&gt;&gt;&gt; iterator = DefaultIterator()\n&gt;&gt;&gt; registry = IteratorRegistry()\n&gt;&gt;&gt; list(iterator.iterate(42, registry))\n[42]\n&gt;&gt;&gt; list(iterator.iterate(\"hello\", registry))\n['hello']\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.DefaultIterator","title":"coola.iterator.dfs.DefaultIterator","text":"<p>               Bases: <code>BaseIterator[Any]</code></p> <p>Default iterator for depth-first search traversal of leaf nodes.</p> <p>This iterator serves as the fallback handler for objects that don't have a specialized iterator registered. It treats the input data as a leaf node and yields it directly without further traversal.</p> <p>The DefaultIterator is typically used for: - Primitive types (int, float, str, bool, None) - Objects without internal structure to traverse - Terminal nodes in a data structure</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, DefaultIterator\n&gt;&gt;&gt; iterator = DefaultIterator()\n&gt;&gt;&gt; registry = IteratorRegistry()\n&gt;&gt;&gt; list(iterator.iterate(42, registry))\n[42]\n&gt;&gt;&gt; list(iterator.iterate(\"hello\", registry))\n['hello']\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IterableIterator","title":"coola.iterator.dfs.IterableIterator","text":"<p>               Bases: <code>BaseIterator[Iterable[Any]]</code></p> <p>Iterator for performing a depth-first traversal over iterable data structures.</p> <p>This iterator recursively traverses through iterable structures such as lists, tuples, or other collections that implement the <code>Iterable</code> interface, yielding elements one by one.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, IterableIterator, DefaultIterator\n&gt;&gt;&gt; iterator = IterableIterator()\n&gt;&gt;&gt; registry = IteratorRegistry({object: DefaultIterator(), list: iterator})\n&gt;&gt;&gt; # Iterating over a simple list\n&gt;&gt;&gt; list(iterator.iterate([1, 2, 3], registry))\n[1, 2, 3]\n&gt;&gt;&gt; # Iterating over a string (iterable of characters)\n&gt;&gt;&gt; list(iterator.iterate(\"hello\", registry))\n['h', 'e', 'l', 'l', 'o']\n&gt;&gt;&gt; # Iterating over nested iterables (lists within lists)\n&gt;&gt;&gt; list(iterator.iterate([[1, 2, 3], [4, 5, 6]], registry))\n[1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry","title":"coola.iterator.dfs.IteratorRegistry","text":"<p>Registry that manages iterators for different data types.</p> <p>This registry stores iterators for various data types and handles the dispatching of the appropriate iterator based on the data type during iteration. It uses Method Resolution Order (MRO) to resolve the most specific iterator for a given data type. It also supports caching of iterators for performance optimization in repetitive iteration tasks.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[type, BaseIterator[Any]] | None</code> <p>An optional dictionary mapping types to iterators. If provided, the registry is initialized with this mapping.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>TypeRegistry[BaseIterator]</code> <p>Internal mapping of registered data types to iterators.</p> Example <p>Basic usage:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, IterableIterator, DefaultIterator\n&gt;&gt;&gt; registry = IteratorRegistry({object: DefaultIterator(), list: IterableIterator()})\n&gt;&gt;&gt; registry\nIteratorRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'object'&gt;): DefaultIterator()\n      (&lt;class 'list'&gt;): IterableIterator()\n    )\n)\n&gt;&gt;&gt; list(registry.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre> <p>Working with nested structures:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; list(registry.iterate(data))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry.find_iterator","title":"coola.iterator.dfs.IteratorRegistry.find_iterator","text":"<pre><code>find_iterator(data_type: type) -&gt; BaseIterator[Any]\n</code></pre> <p>Find the appropriate iterator for a given type.</p> <p>This method uses the MRO to find the most specific iterator. It caches the result for performance, so subsequent lookups are faster.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type for which to find an iterator.</p> required <p>Returns:</p> Type Description <code>BaseIterator[Any]</code> <p>The appropriate iterator for the data type.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, IterableIterator, DefaultIterator\n&gt;&gt;&gt; registry = IteratorRegistry({object: DefaultIterator(), list: IterableIterator()})\n&gt;&gt;&gt; registry.find_iterator(list)\nIterableIterator()\n&gt;&gt;&gt; registry.find_iterator(tuple)\nDefaultIterator()\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry.has_iterator","title":"coola.iterator.dfs.IteratorRegistry.has_iterator","text":"<pre><code>has_iterator(data_type: type) -&gt; bool\n</code></pre> <p>Check if an iterator is registered for a given data type.</p> <p>This method checks for direct registration. Even if this method returns <code>False</code>, a suitable iterator might still be found using the MRO lookup.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an iterator is registered for the type, <code>False</code> otherwise.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, IterableIterator\n&gt;&gt;&gt; registry = IteratorRegistry({list: IterableIterator()})\n&gt;&gt;&gt; registry.has_iterator(list)\nTrue\n&gt;&gt;&gt; registry.has_iterator(tuple)\nFalse\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry.iterate","title":"coola.iterator.dfs.IteratorRegistry.iterate","text":"<pre><code>iterate(data: Any) -&gt; Iterator[Any]\n</code></pre> <p>Perform depth-first iteration over a data structure.</p> <p>This method uses the appropriate iterator for the data type, which may be retrieved via the registry. The iterator will recursively traverse the data structure, yielding elements based on its specific implementation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data structure to iterate over.</p> required <p>Yields:</p> Type Description <code>Any</code> <p>The elements of the data structure according to the appropriate iterator's traversal logic.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import (\n...     IteratorRegistry,\n...     IterableIterator,\n...     MappingIterator,\n...     DefaultIterator,\n... )\n&gt;&gt;&gt; registry = IteratorRegistry(\n...     {object: DefaultIterator(), list: IterableIterator(), dict: MappingIterator()}\n... )\n&gt;&gt;&gt; list(registry.iterate({\"a\": [1, 2], \"b\": [3, 4]}))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry.register","title":"coola.iterator.dfs.IteratorRegistry.register","text":"<pre><code>register(\n    data_type: type,\n    iterator: BaseIterator[Any],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register an iterator for a given data type.</p> <p>This method associates a specific iterator with a type. If data of this type is iterated, the registered iterator will be used. The cache is cleared after a registration to ensure consistency.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to register (e.g., <code>list</code>, <code>dict</code>, custom types).</p> required <code>iterator</code> <code>BaseIterator[Any]</code> <p>The iterator instance that handles this type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, allows overwriting an existing registration. If <code>False</code>, raises an error.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the type is already registered and <code>exist_ok</code> is <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, IterableIterator\n&gt;&gt;&gt; registry = IteratorRegistry()\n&gt;&gt;&gt; registry.register(list, IterableIterator())\n&gt;&gt;&gt; registry.has_iterator(list)\nTrue\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.IteratorRegistry.register_many","title":"coola.iterator.dfs.IteratorRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[type, BaseIterator[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple iterators at once.</p> <p>This method allows for bulk registration of iterators for multiple data types.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseIterator[Any]]</code> <p>A dictionary mapping Python types to their respective iterators.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, allows overwriting existing registrations.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any type is already registered and <code>exist_ok</code> is <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import (\n...     IteratorRegistry,\n...     IterableIterator,\n...     MappingIterator,\n...     DefaultIterator,\n... )\n&gt;&gt;&gt; registry = IteratorRegistry({object: DefaultIterator()})\n&gt;&gt;&gt; registry.register_many({list: IterableIterator(), dict: MappingIterator()})\n&gt;&gt;&gt; registry\nIteratorRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'object'&gt;): DefaultIterator()\n      (&lt;class 'list'&gt;): IterableIterator()\n      (&lt;class 'dict'&gt;): MappingIterator()\n    )\n)\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.MappingIterator","title":"coola.iterator.dfs.MappingIterator","text":"<p>               Bases: <code>BaseIterator[Mapping[Any, Any]]</code></p> <p>Iterator for depth-first traversal of mapping data structures.</p> <p>This iterator handles dict-like objects by recursively iterating over their values. Keys are not yielded during iteration - only the values are traversed. If values contain nested structures (lists, dicts, etc.), those are recursively iterated as well.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import (\n...     IteratorRegistry,\n...     MappingIterator,\n...     IterableIterator,\n...     DefaultIterator,\n... )\n&gt;&gt;&gt; iterator = MappingIterator()\n&gt;&gt;&gt; registry = IteratorRegistry(\n...     {object: DefaultIterator(), dict: iterator, list: IterableIterator()}\n... )\n&gt;&gt;&gt; # Simple dictionary with scalar values\n&gt;&gt;&gt; list(iterator.iterate({\"a\": 1, \"b\": 2}, registry))\n[1, 2]\n&gt;&gt;&gt; # Nested dictionary with scalar values\n&gt;&gt;&gt; list(iterator.iterate({\"a\": {\"b\": 1, \"c\": 2}, \"d\": 3}, registry))\n[1, 2, 3]\n&gt;&gt;&gt; # Dictionary with list values\n&gt;&gt;&gt; list(iterator.iterate({\"x\": [1, 2], \"y\": [3, 4]}, registry))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.dfs_iterate","title":"coola.iterator.dfs.dfs_iterate","text":"<pre><code>dfs_iterate(\n    data: Any, registry: IteratorRegistry | None = None\n) -&gt; Iterator[Any]\n</code></pre> <p>Perform Depth-First Search (DFS) iteration over nested data structures (lists, dicts, tuples, sets, etc.).</p> <p>This function yields elements from the data structure in a DFS manner, recursively traversing all levels of nested structures. It uses the appropriate iterators registered for the data types (e.g., lists, dictionaries, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The nested data structure to traverse. Can be a list, tuple, dict, set, or any other registered type.</p> required <code>registry</code> <code>IteratorRegistry | None</code> <p>The registry to resolve iterators for nested data. If <code>None</code>, the default registry is used.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>The elements from the nested data structure in DFS order.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; list(dfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(dfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.get_default_registry","title":"coola.iterator.dfs.get_default_registry","text":"<pre><code>get_default_registry() -&gt; IteratorRegistry\n</code></pre> <p>Get or create the default global registry for iterators.</p> <p>This function returns a singleton instance of the <code>IteratorRegistry</code>, which is pre-configured with iterators for common Python types, including iterables (lists, tuples), mappings (dicts), sets, and scalars (int, float, str, bool). The registry is used to look up the appropriate iterator for a given data structure during iteration.</p> <p>Returns:</p> Type Description <code>IteratorRegistry</code> <p>An <code>IteratorRegistry</code> instance with iterators registered for common Python types.</p> Notes <p>The singleton pattern means any changes to the returned registry affect all future calls to this function. If an isolated registry is needed, create a new <code>IteratorRegistry</code> instance directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import get_default_registry\n&gt;&gt;&gt; reg = get_default_registry()\n&gt;&gt;&gt; list(reg.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre>"},{"location":"refs/iterator/#coola.iterator.dfs.register_iterators","title":"coola.iterator.dfs.register_iterators","text":"<pre><code>register_iterators(\n    mapping: Mapping[type, BaseIterator[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom iterators to the default global registry.</p> <p>This allows users to add support for custom types without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseIterator[Any]]</code> <p>A dictionary mapping Python types to their corresponding iterator instances.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>True</code>, existing registrations for types will be overwritten. If <code>False</code>, an error is raised when a type is already registered.</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import register_iterators, IterableIterator, IteratorRegistry\n&gt;&gt;&gt; register_iterators({list: IterableIterator()}, exist_ok=True)\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; list(registry.iterate([1, 2, 3]))\n[1, 2, 3]\n</code></pre>"},{"location":"refs/random/","title":"Random","text":""},{"location":"refs/random/#coola.random","title":"coola.random","text":"<p>Contain functionalities to manage randomness.</p>"},{"location":"refs/random/#coola.random.BaseRandomManager","title":"coola.random.BaseRandomManager","text":"<p>               Bases: <code>ABC</code></p> <p>Implement the base class to manage randomness.</p> <p>Each child class must implement the methods: - <code>get_rng_state</code>. - <code>manual_seed</code>. - <code>set_rng_state</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.get_rng_state","title":"coola.random.BaseRandomManager.get_rng_state  <code>abstractmethod</code>","text":"<pre><code>get_rng_state() -&gt; Any\n</code></pre> <p>Get the current RNG state.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The current RNG state.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; state = manager.get_rng_state()\n&gt;&gt;&gt; state\n{'torch': tensor([...], dtype=torch.uint8), 'torch.cuda': ...}\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.manual_seed","title":"coola.random.BaseRandomManager.manual_seed  <code>abstractmethod</code>","text":"<pre><code>manual_seed(seed: int) -&gt; None\n</code></pre> <p>Set the seed for generating random numbers.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The desired seed.</p> required Example <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.BaseRandomManager.set_rng_state","title":"coola.random.BaseRandomManager.set_rng_state  <code>abstractmethod</code>","text":"<pre><code>set_rng_state(state: Any) -&gt; None\n</code></pre> <p>Set the RNG state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Any</code> <p>The new RNG state.</p> required Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; state = manager.get_rng_state()\n&gt;&gt;&gt; manager.set_rng_state(state)\n</code></pre>"},{"location":"refs/random/#coola.random.NumpyRandomManager","title":"coola.random.NumpyRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement a random manager for the library <code>numpy</code>.</p> <p>The seed must be between <code>0</code> and <code>2**32 - 1</code>, so a modulo operator to convert an integer to an integer between <code>0</code> and <code>2**32 - 1</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import NumpyRandomManager\n&gt;&gt;&gt; manager = NumpyRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManagerRegistry","title":"coola.random.RandomManagerRegistry","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Registry that manages random number generator managers.</p> <p>This registry maintains a mapping from string keys to random manager instances, enabling centralized control of random number generator states across multiple libraries. It provides methods to seed all managers, get and set their states, and check for registered managers.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[str, BaseRandomManager] | None</code> <p>Optional initial mapping of string keys to managers. If provided, the state is copied to prevent external mutations.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>Registry[str, BaseRandomManager]</code> <p>Internal registry mapping keys to random managers</p> Example <p>Basic usage with a random manager:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomManagerRegistry, RandomRandomManager\n&gt;&gt;&gt; registry = RandomManagerRegistry({\"random\": RandomRandomManager()})\n&gt;&gt;&gt; registry\nRandomManagerRegistry(\n  (state): Registry(\n      (random): RandomRandomManager()\n    )\n)\n&gt;&gt;&gt; registry.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManagerRegistry.has_manager","title":"coola.random.RandomManagerRegistry.has_manager","text":"<pre><code>has_manager(key: str) -&gt; bool\n</code></pre> <p>Check if a random manager is registered for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The string key to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a manager is registered for this key, False otherwise</p> Example <pre><code>&gt;&gt;&gt; from coola.random import RandomManagerRegistry, RandomRandomManager\n&gt;&gt;&gt; registry = RandomManagerRegistry()\n&gt;&gt;&gt; registry.register(\"random\", RandomRandomManager())\n&gt;&gt;&gt; registry.has_manager(\"random\")\nTrue\n&gt;&gt;&gt; registry.has_manager(\"torch\")\nFalse\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManagerRegistry.register","title":"coola.random.RandomManagerRegistry.register","text":"<pre><code>register(\n    key: str,\n    manager: BaseRandomManager,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register a random manager with a given key.</p> <p>This method associates a manager instance with a specific string key. The manager will be used to control the random number generator state for its corresponding library.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The string key to register (e.g., \"random\", \"torch\", \"numpy\")</p> required <code>manager</code> <code>BaseRandomManager</code> <p>The random manager instance that handles RNG state</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if the key is already registered. If True, overwrites the existing registration silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the key is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.random import RandomManagerRegistry, RandomRandomManager\n&gt;&gt;&gt; registry = RandomManagerRegistry()\n&gt;&gt;&gt; registry.register(\"random\", RandomRandomManager())\n&gt;&gt;&gt; registry.has_manager(\"random\")\nTrue\n</code></pre>"},{"location":"refs/random/#coola.random.RandomManagerRegistry.register_many","title":"coola.random.RandomManagerRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[str, BaseRandomManager],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple random managers at once.</p> <p>This is a convenience method for bulk registration that internally calls register() for each key-manager pair.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[str, BaseRandomManager]</code> <p>Dictionary mapping string keys to random manager instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if any key is already registered. If True, overwrites existing registrations silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any key is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.random import (\n...     RandomManagerRegistry,\n...     RandomRandomManager,\n...     TorchRandomManager,\n... )\n&gt;&gt;&gt; registry = RandomManagerRegistry()\n&gt;&gt;&gt; registry.register_many(\n...     {\n...         \"random\": RandomRandomManager(),\n...         \"torch\": TorchRandomManager(),\n...     }\n... )\n&gt;&gt;&gt; registry\nRandomManagerRegistry(\n  (state): Registry(\n      (random): RandomRandomManager()\n      (torch): TorchRandomManager()\n    )\n)\n</code></pre>"},{"location":"refs/random/#coola.random.RandomRandomManager","title":"coola.random.RandomRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement a random manager for the python standard library <code>random</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import RandomRandomManager\n&gt;&gt;&gt; manager = RandomRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.TorchRandomManager","title":"coola.random.TorchRandomManager","text":"<p>               Bases: <code>BaseRandomManager</code></p> <p>Implement a random manager for the library <code>torch</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n</code></pre>"},{"location":"refs/random/#coola.random.get_default_registry","title":"coola.random.get_default_registry","text":"<pre><code>get_default_registry() -&gt; RandomManagerRegistry\n</code></pre> <p>Get or create the default global registry with common random managers.</p> <p>Returns a singleton registry instance that is pre-configured with managers for common random number generation libraries including Python's random module, NumPy (if available), and PyTorch (if available).</p> <p>This function uses a singleton pattern to ensure the same registry instance is returned on subsequent calls, which is efficient and maintains consistency across an application.</p> <p>Returns:</p> Type Description <code>RandomManagerRegistry</code> <p>A RandomManagerRegistry instance with managers registered for: - \"random\": Python's random module (always available) - \"numpy\": NumPy random (if NumPy is installed) - \"torch\": PyTorch random (if PyTorch is installed)</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. If you need an isolated registry, create a new RandomManagerRegistry instance directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; # Registry is ready to use with available random managers\n&gt;&gt;&gt; registry\nRandomManagerRegistry(\n  (state): Registry(\n      (random): RandomRandomManager()\n      (numpy): NumpyRandomManager()\n      (torch): TorchRandomManager()\n    )\n)\n</code></pre>"},{"location":"refs/random/#coola.random.get_rng_state","title":"coola.random.get_rng_state","text":"<pre><code>get_rng_state() -&gt; dict[str, Any]\n</code></pre> <p>Get the current RNG state.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The current RNG state.</p> Example <pre><code>&gt;&gt;&gt; from coola.random import get_rng_state\n&gt;&gt;&gt; state = get_rng_state()\n&gt;&gt;&gt; state\n{'random': ...}\n</code></pre>"},{"location":"refs/random/#coola.random.manual_seed","title":"coola.random.manual_seed","text":"<pre><code>manual_seed(seed: int) -&gt; None\n</code></pre> <p>Set the seed for generating random numbers.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The desired random seed.</p> required Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; torch.randn(3)\ntensor([...])\n</code></pre>"},{"location":"refs/random/#coola.random.numpy_seed","title":"coola.random.numpy_seed","text":"<pre><code>numpy_seed(seed: int) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the NumPy random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required Example <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola.random import numpy_seed\n&gt;&gt;&gt; with numpy_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n&gt;&gt;&gt; with numpy_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n</code></pre>"},{"location":"refs/random/#coola.random.random_seed","title":"coola.random.random_seed","text":"<pre><code>random_seed(\n    seed: int, manager: RandomManagerRegistry | None = None\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required <code>manager</code> <code>RandomManagerRegistry | None</code> <p>An optional RandomManagerRegistry instance to use. If not provided, the default random manager will be used.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n</code></pre>"},{"location":"refs/random/#coola.random.register_managers","title":"coola.random.register_managers","text":"<pre><code>register_managers(\n    mapping: Mapping[str, BaseRandomManager],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom managers to the default global registry.</p> <p>This allows users to add support for custom random number generators without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[str, BaseRandomManager]</code> <p>Dictionary mapping manager names to manager instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False, raises error if any manager name already registered</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from coola.random import register_managers, RandomRandomManager\n&gt;&gt;&gt; register_managers({\"custom\": RandomRandomManager()})  # doctest: +SKIP\n</code></pre>"},{"location":"refs/random/#coola.random.set_rng_state","title":"coola.random.set_rng_state","text":"<pre><code>set_rng_state(state: dict[str, Any]) -&gt; None\n</code></pre> <p>Set the RNG state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict[str, Any]</code> <p>The new RNG state.</p> required Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import get_rng_state, set_rng_state\n&gt;&gt;&gt; st = get_rng_state()\n&gt;&gt;&gt; set_rng_state(st)\n</code></pre>"},{"location":"refs/random/#coola.random.torch_seed","title":"coola.random.torch_seed","text":"<pre><code>torch_seed(seed: int) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to manage the PyTorch random seed and random number generator (RNG) state.</p> <p>The context manager sets the specified random seed and restores the original RNG state afterward.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The random number generator seed to use while using this context manager.</p> required Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import torch_seed\n&gt;&gt;&gt; with torch_seed(42):\n...     print(torch.randn(2, 4))\n...\ntensor([[...]])\n&gt;&gt;&gt; with torch_seed(42):\n...     print(torch.randn(2, 4))\n...\ntensor([[...]])\n</code></pre>"},{"location":"refs/recursive/","title":"Recursive","text":""},{"location":"refs/recursive/#coola.recursive","title":"coola.recursive","text":"<p>Recursive data transformation using DFS pattern.</p> <p>This design is inspired by the DFS array iterator pattern and provides: 1. Memory-efficient generator-based traversal 2. Clean separation between transformation logic and type dispatch 3. No state object threading through recursion 4. Easy extensibility via registry pattern</p>"},{"location":"refs/recursive/#coola.recursive.BaseTransformer","title":"coola.recursive.BaseTransformer","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class for type-specific transformers.</p> <p>This abstract base class defines the interface for transformers that recursively apply functions to nested data structures. Each concrete transformer implementation handles a specific data type and knows how to reconstruct that type after transforming its nested elements.</p> Notes <p>Subclasses must implement the <code>transform</code> method to define how their specific type should be traversed and reconstructed.</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import DefaultTransformer, TransformerRegistry\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; transformer = DefaultTransformer()\n&gt;&gt;&gt; transformer\nDefaultTransformer()\n&gt;&gt;&gt; transformer.transform([1, 2, 3], func=str, registry=registry)\n'[1, 2, 3]'\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.BaseTransformer.transform","title":"coola.recursive.BaseTransformer.transform  <code>abstractmethod</code>","text":"<pre><code>transform(\n    data: T,\n    func: Callable[[Any], Any],\n    registry: TransformerRegistry,\n) -&gt; Any\n</code></pre> <p>Transform data by recursively applying a function.</p> <p>This method traverses the data structure, applies the given function to leaf values, and reconstructs the original structure with the transformed values. The registry is used to resolve appropriate transformers for nested data types encountered during traversal.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data structure to transform. Must be of type T that this transformer handles.</p> required <code>func</code> <code>Callable[[Any], Any]</code> <p>A function to apply to leaf values (non-container elements). Should accept a single argument and return the transformed value.</p> required <code>registry</code> <code>TransformerRegistry</code> <p>The transformer registry used to look up transformers for nested data structures of different types.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The transformed data structure, maintaining the original type</p> <code>Any</code> <p>and structure but with leaf values transformed by func.</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import DefaultTransformer, SequenceTransformer, TransformerRegistry\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; transformer = DefaultTransformer()\n&gt;&gt;&gt; # Convert numeric values to strings\n&gt;&gt;&gt; transformer.transform([1, 2, 3], func=str, registry=registry)\n'[1, 2, 3]'\n&gt;&gt;&gt; # Apply a mathematical operation\n&gt;&gt;&gt; transformer.transform([1, 2, 3], func=lambda x: x * 2, registry=registry)\n[1, 2, 3, 1, 2, 3]\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.ConditionalTransformer","title":"coola.recursive.ConditionalTransformer","text":"<p>               Bases: <code>BaseTransformer[T]</code></p> <p>Wrapper transformer that conditionally applies transformations.</p> <p>This transformer wraps another transformer and only applies it when a given condition evaluates to True. If the condition is False, the data is returned unchanged. This allows for selective transformation based on runtime checks without modifying the underlying transformer or core architecture.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer[T]</code> <p>The underlying transformer to apply when the condition is met. This can be any BaseTransformer implementation.</p> required <code>condition</code> <code>Callable[[Any], bool]</code> <p>A predicate function that determines whether to apply the transformation. Should accept the data as input and return True to transform or False to pass through unchanged.</p> required Example <pre><code>&gt;&gt;&gt; from coola.recursive import (\n...     DefaultTransformer,\n...     ConditionalTransformer,\n...     TransformerRegistry,\n... )\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; # Create a transformer that only processes positive numbers\n&gt;&gt;&gt; transformer = ConditionalTransformer(\n...     transformer=DefaultTransformer(),\n...     condition=lambda x: isinstance(x, (int, float)) and x &gt; 0,\n... )\n&gt;&gt;&gt; transformer\nConditionalTransformer(\n  (transformer): DefaultTransformer()\n  (condition): &lt;function &lt;lambda&gt; at 0x...&gt;\n)\n&gt;&gt;&gt; # Positive number: condition passes, transformation applied\n&gt;&gt;&gt; transformer.transform(5, func=lambda x: x * 2, registry=registry)\n10\n&gt;&gt;&gt; # Negative number: condition fails, returned unchanged\n&gt;&gt;&gt; transformer.transform(-5, func=lambda x: x * 2, registry=registry)\n-5\n&gt;&gt;&gt; # Non-numeric: condition fails, returned unchanged\n&gt;&gt;&gt; transformer.transform(\"text\", func=lambda x: x * 2, registry=registry)\n'text'\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.DefaultTransformer","title":"coola.recursive.DefaultTransformer","text":"<p>               Bases: <code>BaseTransformer[Any]</code></p> <p>Transformer for leaf nodes that directly applies the function.</p> <p>This is the default transformer used for values that don't require recursive traversal. It simply applies the given function directly to the data without any structural transformation or nested processing. This transformer is typically used as the terminal case in recursive transformations when a leaf value (non-container) is encountered.</p> Notes <p>Unlike container-specific transformers (e.g., list, dict), this transformer does not traverse nested structures. It treats all input as atomic values and applies the function directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import DefaultTransformer, TransformerRegistry\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; transformer = DefaultTransformer()\n&gt;&gt;&gt; transformer\nDefaultTransformer()\n&gt;&gt;&gt; # Transform a simple value directly\n&gt;&gt;&gt; transformer.transform(42, func=str, registry=registry)\n'42'\n&gt;&gt;&gt; # Transform a string\n&gt;&gt;&gt; transformer.transform(\"hello\", func=str.upper, registry=registry)\n'HELLO'\n&gt;&gt;&gt; # Apply a mathematical operation\n&gt;&gt;&gt; transformer.transform(10, func=lambda x: x * 2, registry=registry)\n20\n&gt;&gt;&gt; # Even container types are treated as atomic values\n&gt;&gt;&gt; transformer.transform([1, 2, 3], func=str, registry=registry)\n'[1, 2, 3]'\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.MappingTransformer","title":"coola.recursive.MappingTransformer","text":"<p>               Bases: <code>BaseTransformer[Mapping[Any, Any]]</code></p> <p>Transformer for mapping types that recursively transforms values.</p> <p>This transformer handles dict-like mapping structures by recursively transforming all values while preserving keys unchanged. After transformation, it reconstructs the mapping using its original type (dict, OrderedDict, defaultdict, etc.), maintaining the mapping's specific characteristics and behavior.</p> Notes <ul> <li>Keys are never transformed, only values are processed recursively</li> <li>The original mapping type is preserved in the output</li> <li>Nested mappings and other containers in values are handled recursively</li> <li>Empty mappings are preserved as empty mappings of the same type</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.recursive import MappingTransformer, TransformerRegistry, DefaultTransformer\n&gt;&gt;&gt; registry = TransformerRegistry({object: DefaultTransformer()})\n&gt;&gt;&gt; transformer = MappingTransformer()\n&gt;&gt;&gt; transformer\nMappingTransformer()\n&gt;&gt;&gt; # Transform simple dict values\n&gt;&gt;&gt; transformer.transform({\"a\": 1, \"b\": 2}, func=str, registry=registry)\n{'a': '1', 'b': '2'}\n&gt;&gt;&gt; # Keys remain unchanged\n&gt;&gt;&gt; transformer.transform({1: \"x\", 2: \"y\"}, func=str.upper, registry=registry)\n{1: 'X', 2: 'Y'}\n&gt;&gt;&gt; # Nested structures in values are handled recursively\n&gt;&gt;&gt; transformer.transform({\"nums\": [1, 2, 3], \"text\": \"hello\"}, func=str, registry=registry)\n{'nums': '[1, 2, 3]', 'text': 'hello'}\n&gt;&gt;&gt; # Empty mappings are preserved\n&gt;&gt;&gt; transformer.transform({}, func=str, registry=registry)\n{}\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.SequenceTransformer","title":"coola.recursive.SequenceTransformer","text":"<p>               Bases: <code>BaseTransformer[Sequence[Any]]</code></p> <p>Transformer for sequence types that recursively transforms elements.</p> <p>This transformer handles sequence structures (list, tuple, namedtuple, etc.) by recursively transforming all elements while preserving the original sequence type and structure. After transformation, it reconstructs the sequence using its original type, with special handling for named tuples to preserve their field structure.</p> Notes <ul> <li>All elements are transformed recursively through the registry</li> <li>The original sequence type is preserved (list remains list, tuple remains tuple)</li> <li>Named tuples receive special handling to preserve field names</li> <li>Nested sequences and other containers are handled recursively</li> <li>Empty sequences are preserved as empty sequences of the same type</li> <li>String sequences (str) should typically use a different transformer   as they are often treated as atomic values</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.recursive import SequenceTransformer, TransformerRegistry, DefaultTransformer\n&gt;&gt;&gt; transformer = SequenceTransformer()\n&gt;&gt;&gt; transformer\nSequenceTransformer()\n&gt;&gt;&gt; registry = TransformerRegistry({object: DefaultTransformer(), list: transformer})\n&gt;&gt;&gt; # Transform list elements\n&gt;&gt;&gt; transformer.transform([1, 2, 3], func=str, registry=registry)\n['1', '2', '3']\n&gt;&gt;&gt; # Tuple type is preserved\n&gt;&gt;&gt; transformer.transform((1, 2, 3), func=lambda x: x * 2, registry=registry)\n(2, 4, 6)\n&gt;&gt;&gt; # Nested sequences are handled recursively\n&gt;&gt;&gt; transformer.transform([[1, 2], [3, 4]], func=str, registry=registry)\n[['1', '2'], ['3', '4']]\n&gt;&gt;&gt; # Empty sequences are preserved\n&gt;&gt;&gt; transformer.transform([], func=str, registry=registry)\n[]\n&gt;&gt;&gt; # Named tuples preserve their structure\n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Point = namedtuple(\"Point\", [\"x\", \"y\"])\n&gt;&gt;&gt; transformer.transform(Point(1, 2), func=str, registry=registry)\nPoint(x='1', y='2')\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.SetTransformer","title":"coola.recursive.SetTransformer","text":"<p>               Bases: <code>BaseTransformer[Set[Any]]</code></p> <p>Transformer for set types that recursively transforms elements.</p> <p>This transformer handles set structures (set, frozenset) by recursively transforming all elements while preserving the original set type. After transformation, it reconstructs the set using its original type. Sets maintain their unordered, unique-element properties.</p> Important <p>HASHABILITY REQUIREMENT: All transformed values MUST remain hashable (i.e., immutable and hashable) since sets can only contain hashable elements. Transforming to unhashable types (like lists or dicts) will raise a TypeError.</p> Notes <ul> <li>All elements are transformed recursively through the registry</li> <li>The original set type is preserved (set remains set, frozenset remains frozenset)</li> <li>Element order is not guaranteed (sets are unordered)</li> <li>Duplicate transformed values will be automatically deduplicated</li> <li>Empty sets are preserved as empty sets of the same type</li> <li>If transformation produces unhashable values, a TypeError will be raised</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.recursive import SetTransformer, TransformerRegistry, DefaultTransformer\n&gt;&gt;&gt; registry = TransformerRegistry({object: DefaultTransformer()})\n&gt;&gt;&gt; transformer = SetTransformer()\n&gt;&gt;&gt; transformer\nSetTransformer()\n&gt;&gt;&gt; # Transform set elements (order may vary in output)\n&gt;&gt;&gt; transformer.transform({1}, func=str, registry=registry)\n{'1'}\n&gt;&gt;&gt; # Frozenset type is preserved\n&gt;&gt;&gt; transformer.transform(frozenset([1, 2, 3]), func=lambda x: x * 2, registry=registry)\nfrozenset({2, 4, 6})\n&gt;&gt;&gt; # Duplicate values after transformation are automatically deduplicated\n&gt;&gt;&gt; transformer.transform({1, 2, 3}, func=lambda x: x // 4, registry=registry)\n{0}\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry","title":"coola.recursive.TransformerRegistry","text":"<p>Registry that manages and dispatches transformers based on data type.</p> <p>This registry maintains a mapping from Python types to transformer instances and uses the Method Resolution Order (MRO) for type lookup. When transforming data, it automatically selects the most specific registered transformer for the data's type, falling back to parent types or a default transformer if needed.</p> <p>The registry includes an LRU cache for type lookups to optimize performance in applications that repeatedly transform similar data structures.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[type, BaseTransformer[Any]] | None</code> <p>Optional initial mapping of types to transformers. If provided, the state is copied to prevent external mutations.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>TypeRegistry[BaseTransformer]</code> <p>Internal mapping of registered types to transformers</p> Example <p>Basic usage with a sequence transformer:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer, DefaultTransformer\n&gt;&gt;&gt; registry = TransformerRegistry(\n...     {object: DefaultTransformer(), list: SequenceTransformer()}\n... )\n&gt;&gt;&gt; registry\nTransformerRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'object'&gt;): DefaultTransformer()\n      (&lt;class 'list'&gt;): SequenceTransformer()\n    )\n)\n&gt;&gt;&gt; registry.transform([1, 2, 3], str)\n['1', '2', '3']\n</code></pre> <p>Registering custom transformers:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer\n&gt;&gt;&gt; registry = TransformerRegistry({object: DefaultTransformer()})\n&gt;&gt;&gt; registry.register(list, SequenceTransformer())\n&gt;&gt;&gt; registry.transform([1, 2, 3], lambda x: x * 2)\n[2, 4, 6]\n</code></pre> <p>Working with nested structures:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; registry.transform(data, str)\n{'a': ['1', '2'], 'b': ['3', '4']}\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry.find_transformer","title":"coola.recursive.TransformerRegistry.find_transformer","text":"<pre><code>find_transformer(data_type: type) -&gt; BaseTransformer[Any]\n</code></pre> <p>Find the appropriate transformer for a given type.</p> <p>Uses the Method Resolution Order (MRO) to find the most specific registered transformer. For example, if you register a transformer for Sequence but not for list, lists will use the Sequence transformer.</p> <p>Results are cached using an LRU cache (256 entries) for performance, as transformer lookup is a hot path in recursive transformations.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to find a transformer for</p> required <p>Returns:</p> Type Description <code>BaseTransformer[Any]</code> <p>The most specific registered transformer for this type, a parent</p> <code>BaseTransformer[Any]</code> <p>type's transformer via MRO, or the default transformer</p> Example <pre><code>&gt;&gt;&gt; from collections.abc import Sequence\n&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer, DefaultTransformer\n&gt;&gt;&gt; registry = TransformerRegistry({object: DefaultTransformer()})\n&gt;&gt;&gt; registry.register(Sequence, SequenceTransformer())\n&gt;&gt;&gt; # list does not inherit from Sequence, so it uses DefaultTransformer\n&gt;&gt;&gt; transformer = registry.find_transformer(list)\n&gt;&gt;&gt; transformer\nDefaultTransformer()\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry.has_transformer","title":"coola.recursive.TransformerRegistry.has_transformer","text":"<pre><code>has_transformer(data_type: type) -&gt; bool\n</code></pre> <p>Check if a transformer is explicitly registered for the given type.</p> <p>Note that this only checks for direct registration. Even if this returns False, find_transformer() may still return a transformer via MRO lookup or the default transformer.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The type to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a transformer is explicitly registered for this type,</p> <code>bool</code> <p>False otherwise</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; registry.register(list, SequenceTransformer())\n&gt;&gt;&gt; registry.has_transformer(list)\nTrue\n&gt;&gt;&gt; registry.has_transformer(tuple)\nFalse\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry.register","title":"coola.recursive.TransformerRegistry.register","text":"<pre><code>register(\n    data_type: type,\n    transformer: BaseTransformer[Any],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register a transformer for a given data type.</p> <p>This method associates a transformer instance with a specific Python type. When data of this type is transformed, the registered transformer will be used. The cache is automatically cleared after registration to ensure consistency.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to register (e.g., list, dict, custom classes)</p> required <code>transformer</code> <code>BaseTransformer[Any]</code> <p>The transformer instance that handles this type</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if the type is already registered. If True, overwrites the existing registration silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the type is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; registry.register(list, SequenceTransformer())\n&gt;&gt;&gt; registry.has_transformer(list)\nTrue\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry.register_many","title":"coola.recursive.TransformerRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[type, BaseTransformer[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple transformers at once.</p> <p>This is a convenience method for bulk registration that internally calls register() for each type-transformer pair.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseTransformer[Any]]</code> <p>Dictionary mapping Python types to transformer instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if any type is already registered. If True, overwrites existing registrations silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any type is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, SequenceTransformer, MappingTransformer\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; registry.register_many(\n...     {\n...         list: SequenceTransformer(),\n...         dict: MappingTransformer(),\n...     }\n... )\n&gt;&gt;&gt; registry\nTransformerRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'list'&gt;): SequenceTransformer()\n      (&lt;class 'dict'&gt;): MappingTransformer()\n    )\n)\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.TransformerRegistry.transform","title":"coola.recursive.TransformerRegistry.transform","text":"<pre><code>transform(data: Any, func: Callable[[Any], Any]) -&gt; Any\n</code></pre> <p>Transform data by applying a function recursively through the structure.</p> <p>This is the main entry point for transformation. It automatically: 1. Determines the data's type 2. Finds the appropriate transformer 3. Delegates to that transformer's transform method 4. The transformer recursively processes nested structures</p> <p>The original structure of the data is preserved - only the leaf values are transformed by the provided function.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to transform (can be nested: lists, dicts, tuples, etc.)</p> required <code>func</code> <code>Callable[[Any], Any]</code> <p>Function to apply to leaf values. Should accept one argument and return a transformed value.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Transformed data with the same structure as the input but with</p> <code>Any</code> <p>leaf values transformed by func</p> Example <p>Converting all numbers to strings in a nested structure:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry.transform({\"scores\": [95, 87, 92], \"name\": \"test\"}, str)\n{'scores': ['95', '87', '92'], 'name': 'test'}\n</code></pre> <p>Doubling all numeric values:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry.transform(\n...     [1, [2, 3], {\"a\": 4}], lambda x: x * 2 if isinstance(x, (int, float)) else x\n... )\n[2, [4, 6], {'a': 8}]\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.get_default_registry","title":"coola.recursive.get_default_registry","text":"<pre><code>get_default_registry() -&gt; TransformerRegistry\n</code></pre> <p>Get or create the default global registry with common Python types.</p> <p>Returns a singleton registry instance that is pre-configured with transformers for Python's built-in types including sequences (list, tuple), mappings (dict), sets, and scalar types (int, float, str, bool).</p> <p>This function uses a singleton pattern to ensure the same registry instance is returned on subsequent calls, which is efficient and maintains consistency across an application.</p> <p>Returns:</p> Type Description <code>TransformerRegistry</code> <p>A TransformerRegistry instance with transformers registered for: - Scalar types (int, float, complex, bool, str) - Sequences (list, tuple, Sequence ABC) - Sets (set, frozenset) - Mappings (dict, Mapping ABC)</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. If you need an isolated registry, create a new TransformerRegistry instance directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; # Registry is ready to use with common Python types\n&gt;&gt;&gt; registry.transform([1, 2, 3], str)\n['1', '2', '3']\n&gt;&gt;&gt; registry.transform({\"a\": 1, \"b\": 2}, lambda x: x * 10)\n{'a': 10, 'b': 20}\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.recursive_apply","title":"coola.recursive.recursive_apply","text":"<pre><code>recursive_apply(\n    data: Any,\n    func: Callable[[Any], Any],\n    registry: TransformerRegistry | None = None,\n) -&gt; Any\n</code></pre> <p>Recursively apply a function to all items in nested data.</p> <p>This is the main public interface that maintains compatibility with the original implementation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data (can be nested)</p> required <code>func</code> <code>Callable[[Any], Any]</code> <p>Function to apply to each leaf value</p> required <code>registry</code> <code>TransformerRegistry | None</code> <p>Registry to resolve transformers for nested data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Transformed data with same structure as input</p> Example <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; recursive_apply({\"a\": 1, \"b\": \"abc\"}, str)\n{'a': '1', 'b': 'abc'}\n&gt;&gt;&gt; recursive_apply([1, [2, 3], {\"x\": 4}], lambda x: x * 2)\n[2, [4, 6], {'x': 8}]\n</code></pre>"},{"location":"refs/recursive/#coola.recursive.register_transformers","title":"coola.recursive.register_transformers","text":"<pre><code>register_transformers(\n    mapping: Mapping[type, BaseTransformer[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom transformers to the default global registry.</p> <p>This allows users to add support for custom types without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseTransformer[Any]]</code> <p>Dictionary mapping types to transformer instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False, raises error if any type already registered</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from coola.recursive import register_transformers, BaseTransformer\n&gt;&gt;&gt; class MyType:\n...     def __init__(self, value):\n...         self.value = value\n...\n&gt;&gt;&gt; class MyTransformer(BaseTransformer):\n...     def transform(self, data, func, registry):\n...         return MyType(func(data.value))\n...\n&gt;&gt;&gt; register_transformers({MyType: MyTransformer()})\n</code></pre>"},{"location":"refs/reducer/","title":"Reducer","text":""},{"location":"refs/reducer/#coola.reducer","title":"coola.reducer","text":"<p>Contain the reducer implementations.</p>"},{"location":"refs/reducer/#coola.reducer.BaseBasicReducer","title":"coola.reducer.BaseBasicReducer","text":"<p>               Bases: <code>BaseReducer[T]</code></p> <p>Extension of <code>BaseReducer</code> to check if the input sequence is empty before to call the reduction methods.</p>"},{"location":"refs/reducer/#coola.reducer.BaseReducer","title":"coola.reducer.BaseReducer","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a reducer.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.max","title":"coola.reducer.BaseReducer.max  <code>abstractmethod</code>","text":"<pre><code>max(values: T) -&gt; int | float\n</code></pre> <p>Compute the maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The maximum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.mean","title":"coola.reducer.BaseReducer.mean  <code>abstractmethod</code>","text":"<pre><code>mean(values: T) -&gt; float\n</code></pre> <p>Compute the mean value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.mean([-2, -1, 0, 1, 2])\n0.0\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.median","title":"coola.reducer.BaseReducer.median  <code>abstractmethod</code>","text":"<pre><code>median(values: T) -&gt; int | float\n</code></pre> <p>Compute the median value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The median value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.min","title":"coola.reducer.BaseReducer.min  <code>abstractmethod</code>","text":"<pre><code>min(values: T) -&gt; int | float\n</code></pre> <p>Compute the minimum value.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>int | float</code> <p>The minimum value.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.min([-2, -1, 0, 1, 2])\n-2\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.quantile","title":"coola.reducer.BaseReducer.quantile  <code>abstractmethod</code>","text":"<pre><code>quantile(\n    values: T, quantiles: Sequence[float]\n) -&gt; list[float]\n</code></pre> <p>Compute the quantiles.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <code>quantiles</code> <code>sequence of float</code> <p>The quantile values in the range <code>[0, 1]</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The quantiles.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.quantile([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (0.2, 0.5, 0.9))\n[2.0, 5.0, 9.0]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.sort","title":"coola.reducer.BaseReducer.sort  <code>abstractmethod</code>","text":"<pre><code>sort(\n    values: T, descending: bool = False\n) -&gt; list[int | float]\n</code></pre> <p>Sorts the values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <code>descending</code> <code>bool</code> <p>The sorting order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int | float]</code> <p>The sorted values.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0], descending=True)\n[3, 2, 1, 0, -2]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.BaseReducer.std","title":"coola.reducer.BaseReducer.std  <code>abstractmethod</code>","text":"<pre><code>std(values: T) -&gt; float\n</code></pre> <p>Compute the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>The values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation.</p> <p>Raises:</p> Type Description <code>EmptySequenceError</code> <p>if the input sequence is empty.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.std([-2, -1, 0, 1, 2])\n1.581138...\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.EmptySequenceError","title":"coola.reducer.EmptySequenceError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise when the sequence is empty because it is not possible to reduce an empty sequence.</p>"},{"location":"refs/reducer/#coola.reducer.NativeReducer","title":"coola.reducer.NativeReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a native reducer.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import NativeReducer\n&gt;&gt;&gt; reducer = NativeReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.NumpyReducer","title":"coola.reducer.NumpyReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a reducer based on NumPy functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>numpy</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import NumpyReducer\n&gt;&gt;&gt; reducer = NumpyReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0.0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.TorchReducer","title":"coola.reducer.TorchReducer","text":"<p>               Bases: <code>BaseBasicReducer[T]</code></p> <p>Implement a reducer based on torch functions.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import TorchReducer\n&gt;&gt;&gt; reducer = TorchReducer()\n&gt;&gt;&gt; reducer.max([-2, -1, 0, 1, 2])\n2\n&gt;&gt;&gt; reducer.median([-2, -1, 0, 1, 2])\n0\n&gt;&gt;&gt; reducer.sort([2, 1, -2, 3, 0])\n[-2, 0, 1, 2, 3]\n</code></pre>"},{"location":"refs/reducer/#coola.reducer.auto_reducer","title":"coola.reducer.auto_reducer","text":"<pre><code>auto_reducer() -&gt; BaseReducer[Sequence[float]]\n</code></pre> <p>Find the \"best\" reducer to used based on the installed packages.</p> <p>The \"best\" reducer is found by using the following rules:     - If <code>torch</code> is available, use <code>TorchReducer</code>     - If <code>numpy</code> is available, use <code>NumpyReducer</code>     - Otherwise, use <code>BasicReducer</code></p> <p>Returns:</p> Type Description <code>BaseReducer[Sequence[float]]</code> <p>The \"best\" reducer.</p> Example <pre><code>&gt;&gt;&gt; from coola.reducer import auto_reducer\n&gt;&gt;&gt; reducer = auto_reducer()\n</code></pre>"},{"location":"refs/registry/","title":"Registry","text":""},{"location":"refs/registry/#coola.registry","title":"coola.registry","text":"<p>Experimental package with registry implementations.</p>"},{"location":"refs/registry/#coola.registry.Registry","title":"coola.registry.Registry","text":"<p>               Bases: <code>Generic[K, V]</code></p> <p>A thread-safe generic key-value registry for storing and managing typed mappings.</p> <p>The Registry class provides a type-safe container for registering and retrieving values by key. It supports all standard dictionary operations through operator overloading and provides additional methods for safe registration and querying. All operations are protected by a lock to ensure thread safety in concurrent environments.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[K, V] | None</code> <p>An optional dictionary to initialize the registry with. If provided, a copy is made to prevent external modifications. Defaults to None, which creates an empty registry.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>dict[K, V]</code> <p>Internal dictionary storing the key-value pairs.</p> <code>_lock</code> <code>RLock</code> <p>Threading lock for synchronizing access to the registry.</p> Example <p>Basic usage with registration and retrieval:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register(\"key1\", 42)\n&gt;&gt;&gt; registry.get(\"key1\")\n42\n&gt;&gt;&gt; registry\nRegistry(\n  (key1): 42\n)\n</code></pre> <p>Using dictionary-style operations:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry[\"key2\"] = 100\n&gt;&gt;&gt; \"key2\" in registry\nTrue\n&gt;&gt;&gt; del registry[\"key2\"]\n</code></pre> <p>Initializing with existing data:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int](initial_state={\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; len(registry)\n2\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.clear","title":"coola.registry.Registry.clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all entries from the registry.</p> <p>This method empties the registry, leaving it in the same state as a newly created empty registry. This operation cannot be undone.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; len(registry)\n0\n&gt;&gt;&gt; registry.has(\"key1\")\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.equal","title":"coola.registry.Registry.equal","text":"<pre><code>equal(other: object, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry1 = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry2 = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry3 = Registry[str, int]({\"key1\": 42})\n&gt;&gt;&gt; registry1.equal(registry2)\nTrue\n&gt;&gt;&gt; registry1.equal(registry3)\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.get","title":"coola.registry.Registry.get","text":"<pre><code>get(key: K, default: V | None = None) -&gt; V | None\n</code></pre> <p>Retrieve the value associated with a key.</p> <p>This method performs a lookup in the registry and returns the corresponding value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key whose value should be retrieved.</p> required <code>default</code> <code>V | None</code> <p>Value to return if the key does not exist.</p> <code>None</code> <p>Returns:</p> Type Description <code>V | None</code> <p>The value associated with the specified key.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry.get(\"key1\")\n42\n&gt;&gt;&gt; registry.get(\"missing\")\nNone\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.has","title":"coola.registry.Registry.has","text":"<pre><code>has(key: K) -&gt; bool\n</code></pre> <p>Check whether a key is registered in the registry.</p> <p>This method provides a safe way to test for key existence without risking a KeyError exception.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to check for existence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exists in the registry, False otherwise.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry.has(\"key1\")\nTrue\n&gt;&gt;&gt; registry.has(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.items","title":"coola.registry.Registry.items","text":"<pre><code>items() -&gt; ItemsView[K, V]\n</code></pre> <p>Return key-value pairs.</p> <p>Returns:</p> Type Description <code>ItemsView[K, V]</code> <p>The key-value pairs.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int](initial_state={\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; registry.items()\ndict_items([('a', 1), ('b', 2)])\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.keys","title":"coola.registry.Registry.keys","text":"<pre><code>keys() -&gt; KeysView[K]\n</code></pre> <p>Return registered keys.</p> <p>Returns:</p> Type Description <code>KeysView[K]</code> <p>The registered keys.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int](initial_state={\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; registry.keys()\ndict_keys(['a', 'b'])\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.register","title":"coola.registry.Registry.register","text":"<pre><code>register(\n    key: K, value: V, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register a new key-value pair in the registry.</p> <p>By default, this method raises an error if you try to register a key that already exists. This prevents accidental overwriting of values. Set exist_ok=True to allow overwriting.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to register. Must be hashable.</p> required <code>value</code> <code>V</code> <p>The value to associate with the key.</p> required <code>exist_ok</code> <code>bool</code> <p>Controls behavior when the key already exists. If False (default), raises RuntimeError for duplicate keys. If True, silently overwrites the existing value.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the key is already registered and exist_ok is False. The error message provides guidance on how to resolve the conflict.</p> Example <p>Basic registration:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register(\"key1\", 42)\n&gt;&gt;&gt; registry.get(\"key1\")\n42\n</code></pre> <p>Attempting to register a duplicate key:</p> <pre><code>&gt;&gt;&gt; registry.register(\"key1\", 100)  # doctest: +SKIP\nRuntimeError: A value is already registered for 'key1'...\n</code></pre> <p>Overwriting with exist_ok:</p> <pre><code>&gt;&gt;&gt; registry.register(\"key1\", 100, exist_ok=True)\n&gt;&gt;&gt; registry.get(\"key1\")\n100\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.register_many","title":"coola.registry.Registry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[K, V], exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register multiple key-value pairs in a single operation.</p> <p>This is a convenience method for bulk registration. It iterates through the provided mapping and registers each key-value pair. All registrations follow the same exist_ok policy. The operation is atomic when exist_ok is False - if any key already exists, no changes are made.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[K, V]</code> <p>A dictionary or mapping containing the key-value pairs to register. The keys and values must match the registry's type parameters.</p> required <code>exist_ok</code> <code>bool</code> <p>Controls behavior when any key already exists. If False (default), raises error on the first duplicate key. If True, overwrites all existing values without error.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If exist_ok is False and any key in the mapping is already registered. The error occurs on the first duplicate encountered, and no partial registration occurs.</p> Example <p>Registering multiple entries at once:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register_many({\"key1\": 42, \"key2\": 100, \"key3\": 7})\n&gt;&gt;&gt; registry.get(\"key1\")\n42\n&gt;&gt;&gt; registry.get(\"key2\")\n100\n&gt;&gt;&gt; len(registry)\n3\n</code></pre> <p>Bulk update with exist_ok:</p> <pre><code>&gt;&gt;&gt; registry.register_many({\"key1\": 1, \"key4\": 4}, exist_ok=True)\n&gt;&gt;&gt; registry.get(\"key1\")\n1\n&gt;&gt;&gt; registry.get(\"key4\")\n4\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.unregister","title":"coola.registry.Registry.unregister","text":"<pre><code>unregister(key: K) -&gt; V\n</code></pre> <p>Remove a key-value pair from the registry and return the value.</p> <p>This method removes the specified key from the registry and returns the value that was associated with it. This allows you to retrieve the value one last time before it's removed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to unregister and remove from the registry.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The value that was associated with the key before removal.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not registered. The error message includes the key that was not found.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry.has(\"key1\")\nTrue\n&gt;&gt;&gt; value = registry.unregister(\"key1\")\n&gt;&gt;&gt; value\n42\n&gt;&gt;&gt; registry.has(\"key1\")\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.Registry.values","title":"coola.registry.Registry.values","text":"<pre><code>values() -&gt; ValuesView[V]\n</code></pre> <p>Return registered values.</p> <p>Returns:</p> Type Description <code>ValuesView[V]</code> <p>The registered values.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int](initial_state={\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; registry.values()\ndict_values([1, 2])\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry","title":"coola.registry.TypeRegistry","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A thread-safe type-based registry for storing and retrieving values.</p> <p>The TypeRegistry class provides a thread-safe container for mapping Python types to values. It supports standard dictionary operations through operator overloading and provides methods for safe registration and querying.</p> <p>The registry uses the Method Resolution Order (MRO) for type lookup through the <code>resolve()</code> method. When resolving a type, it automatically selects the most specific registered type, walking up the inheritance hierarchy if needed. This makes it ideal for type-based dispatching systems.</p> <p>The registry includes an internal cache for type resolution to optimize performance when repeatedly resolving the same types.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[type, T] | None</code> <p>An optional dictionary to initialize the registry with. If provided, a copy is made to prevent external modifications. Defaults to None, which creates an empty registry.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>dict[type, T]</code> <p>Internal dictionary storing the type-value pairs.</p> <code>_cache</code> <code>dict[type, T]</code> <p>Cached version of type resolution lookups for performance.</p> <code>_lock</code> <code>RLock</code> <p>Threading lock for synchronizing access to both state and cache.</p> Example <p>Basic usage with registration and retrieval:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(int, \"I am an integer\")\n&gt;&gt;&gt; registry.get(int)\n'I am an integer'\n&gt;&gt;&gt; registry\nTypeRegistry(\n  (&lt;class 'int'&gt;): I am an integer\n)\n</code></pre> <p>Using dictionary-style operations:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry[str] = \"I am a string\"\n&gt;&gt;&gt; str in registry\nTrue\n&gt;&gt;&gt; registry[str]\n'I am a string'\n&gt;&gt;&gt; del registry[str]\n&gt;&gt;&gt; str in registry\nFalse\n</code></pre> <p>Initializing with existing data:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int](initial_state={str: 100, float: 200})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.get(str)\n100\n</code></pre> <p>Using resolve() with inheritance (MRO lookup):</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(object, \"I am an object\")\n&gt;&gt;&gt; registry.register(int, \"I am an integer\")\n&gt;&gt;&gt; # Direct match\n&gt;&gt;&gt; registry.resolve(int)\n'I am an integer'\n&gt;&gt;&gt; # Falls back to parent type via MRO\n&gt;&gt;&gt; registry.resolve(bool)  # bool inherits from int\n'I am an integer'\n&gt;&gt;&gt; # Falls back to object\n&gt;&gt;&gt; registry.resolve(str)\n'I am an object'\n</code></pre> <p>Bulk registration:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register_many({int: \"integer\", float: \"float\", str: \"string\"})\n&gt;&gt;&gt; len(registry)\n3\n&gt;&gt;&gt; registry.get(float)\n'float'\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.clear","title":"coola.registry.TypeRegistry.clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all entries from the registry.</p> <p>This method empties the registry, leaving it in the same state as a newly created empty registry. This operation cannot be undone.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; len(registry)\n0\n&gt;&gt;&gt; registry.has(int)\nFalse\n&gt;&gt;&gt; registry.has(float)\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.equal","title":"coola.registry.TypeRegistry.equal","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two registries are equal.</p> <p>Two registries are considered equal if they contain the same type-value mappings. The comparison is order-independent since dictionaries are unordered collections.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code> values will be considered equal when comparing values.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two registries are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry1 = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; registry2 = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; registry3 = TypeRegistry[str]({int: \"I am an integer\"})\n&gt;&gt;&gt; registry1.equal(registry2)\nTrue\n&gt;&gt;&gt; registry1.equal(registry3)\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.get","title":"coola.registry.TypeRegistry.get","text":"<pre><code>get(dtype: type, default: T | None = None) -&gt; T\n</code></pre> <p>Retrieve the value associated with a type.</p> <p>This method performs a direct lookup in the registry and returns the corresponding value. If the type doesn't exist, a KeyError is raised with a descriptive message. For inheritance-based lookup, use the <code>resolve()</code> method instead.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The type whose value should be retrieved.</p> required <code>default</code> <code>T | None</code> <p>Value to return if the key does not exist.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The value associated with the specified type.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register(str, 42)\n&gt;&gt;&gt; registry.get(str)\n42\n&gt;&gt;&gt; registry.get(int)  # doctest: +SKIP\nKeyError: \"Key &lt;class 'int'&gt; is not registered\"\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.has","title":"coola.registry.TypeRegistry.has","text":"<pre><code>has(dtype: type) -&gt; bool\n</code></pre> <p>Check whether a type is registered in the registry.</p> <p>This method provides a safe way to test for type existence without risking a KeyError exception. It only checks for direct type matches; it does not check parent types via MRO.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The type to check for existence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the type exists in the registry, False otherwise.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register(str, 42)\n&gt;&gt;&gt; registry.has(str)\nTrue\n&gt;&gt;&gt; registry.has(int)\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.items","title":"coola.registry.TypeRegistry.items","text":"<pre><code>items() -&gt; ItemsView[type, T]\n</code></pre> <p>Return key-value pairs.</p> <p>Returns:</p> Type Description <code>ItemsView[type, T]</code> <p>The key-value pairs.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; registry.items()\ndict_items([(&lt;class 'int'&gt;, 'I am an integer'), (&lt;class 'float'&gt;, 'I am a float')])\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.keys","title":"coola.registry.TypeRegistry.keys","text":"<pre><code>keys() -&gt; KeysView[type]\n</code></pre> <p>Return registered keys.</p> <p>Returns:</p> Type Description <code>KeysView[type]</code> <p>The registered keys.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; registry.keys()\ndict_keys([&lt;class 'int'&gt;, &lt;class 'float'&gt;])\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.register","title":"coola.registry.TypeRegistry.register","text":"<pre><code>register(\n    dtype: type, value: T, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register a new type-value pair in the registry.</p> <p>By default, this method raises an error if you try to register a type that already exists. This prevents accidental overwriting of values. Set exist_ok=True to allow overwriting.</p> <p>Registering a new type clears the internal resolution cache to ensure that subsequent <code>resolve()</code> calls use the updated registry state.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The type to register. Must be a Python type object.</p> required <code>value</code> <code>T</code> <p>The value to associate with the type.</p> required <code>exist_ok</code> <code>bool</code> <p>Controls behavior when the type already exists. If False (default), raises RuntimeError for duplicate types. If True, silently overwrites the existing value.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the type is already registered and exist_ok is False. The error message provides guidance on how to resolve the conflict.</p> Example <p>Basic registration:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register(str, 42)\n&gt;&gt;&gt; registry.get(str)\n42\n</code></pre> <p>Attempting to register a duplicate type:</p> <pre><code>&gt;&gt;&gt; registry.register(str, 100)  # doctest: +SKIP\nRuntimeError: A value is already registered for '&lt;class 'str'&gt;'...\n</code></pre> <p>Overwriting with exist_ok:</p> <pre><code>&gt;&gt;&gt; registry.register(str, 100, exist_ok=True)\n&gt;&gt;&gt; registry.get(str)\n100\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.register_many","title":"coola.registry.TypeRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[type, T], exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register multiple type-value pairs in a single operation.</p> <p>This is a convenience method for bulk registration. It iterates through the provided mapping and registers each type-value pair. All registrations follow the same exist_ok policy. The operation is atomic when exist_ok is False - if any type already exists, no changes are made.</p> <p>Registering new types clears the internal resolution cache to ensure that subsequent <code>resolve()</code> calls use the updated registry state.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, T]</code> <p>A dictionary or mapping containing the type-value pairs to register. The keys must be Python type objects and values must match the registry's type parameter.</p> required <code>exist_ok</code> <code>bool</code> <p>Controls behavior when any type already exists. If False (default), raises error on the first duplicate type. If True, overwrites all existing values without error.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If exist_ok is False and any type in the mapping is already registered. The error occurs before any registration is performed, ensuring no partial updates.</p> Example <p>Registering multiple entries at once:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register_many({str: 42, float: 100, list: 7})\n&gt;&gt;&gt; registry.get(str)\n42\n&gt;&gt;&gt; registry.get(float)\n100\n&gt;&gt;&gt; len(registry)\n3\n</code></pre> <p>Bulk update with exist_ok:</p> <pre><code>&gt;&gt;&gt; registry.register_many({str: 1, dict: 4}, exist_ok=True)\n&gt;&gt;&gt; registry.get(str)\n1\n&gt;&gt;&gt; registry.get(dict)\n4\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.resolve","title":"coola.registry.TypeRegistry.resolve","text":"<pre><code>resolve(dtype: type) -&gt; T\n</code></pre> <p>Resolve a type to its associated value using MRO lookup.</p> <p>This method finds the most appropriate value for a given type by walking the Method Resolution Order (MRO). It first checks for a direct match, then searches through parent types in MRO order to find the most specific registered type.</p> <p>Results are cached internally to optimize performance for repeated lookups of the same type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The type to resolve.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value associated with the type or its nearest registered</p> <code>T</code> <p>parent type in the MRO.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no matching type is found in the registry, including parent types in the MRO.</p> Example <p>Basic resolution with inheritance:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(object, \"base\")\n&gt;&gt;&gt; registry.register(int, \"integer\")\n&gt;&gt;&gt; # Direct match\n&gt;&gt;&gt; registry.resolve(int)\n'integer'\n&gt;&gt;&gt; # bool inherits from int, so resolves to int's value\n&gt;&gt;&gt; registry.resolve(bool)\n'integer'\n&gt;&gt;&gt; # str inherits from object, so resolves to object's value\n&gt;&gt;&gt; registry.resolve(str)\n'base'\n</code></pre> <p>Resolution with custom classes:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; class Animal:\n...     pass\n...\n&gt;&gt;&gt; class Dog(Animal):\n...     pass\n...\n&gt;&gt;&gt; class Poodle(Dog):\n...     pass\n...\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(Animal, \"animal\")\n&gt;&gt;&gt; registry.register(Dog, \"dog\")\n&gt;&gt;&gt; registry.resolve(Dog)\n'dog'\n&gt;&gt;&gt; registry.resolve(Poodle)  # Resolves to parent Dog\n'dog'\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.unregister","title":"coola.registry.TypeRegistry.unregister","text":"<pre><code>unregister(dtype: type) -&gt; T\n</code></pre> <p>Remove a type-value pair from the registry and return the value.</p> <p>This method removes the specified type from the registry and returns the value that was associated with it. This allows you to retrieve the value one last time before it's removed.</p> <p>Unregistering a type clears the internal resolution cache to ensure that subsequent <code>resolve()</code> calls reflect the updated registry state.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The type to unregister and remove from the registry.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value that was associated with the type before removal.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the type is not registered. The error message includes the type that was not found.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]({int: \"I am an integer\"})\n&gt;&gt;&gt; registry.has(int)\nTrue\n&gt;&gt;&gt; value = registry.unregister(int)\n&gt;&gt;&gt; value\n'I am an integer'\n&gt;&gt;&gt; registry.has(int)\nFalse\n</code></pre>"},{"location":"refs/registry/#coola.registry.TypeRegistry.values","title":"coola.registry.TypeRegistry.values","text":"<pre><code>values() -&gt; ValuesView[T]\n</code></pre> <p>Return registered values.</p> <p>Returns:</p> Type Description <code>ValuesView[T]</code> <p>The registered values.</p> Example <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]({int: \"I am an integer\", float: \"I am a float\"})\n&gt;&gt;&gt; registry.values()\ndict_values(['I am an integer', 'I am a float'])\n</code></pre>"},{"location":"refs/summary/","title":"Summary","text":""},{"location":"refs/summary/#coola.summary","title":"coola.summary","text":"<p>Contain functionalities to compute a text summary of nested data based on the type of data.</p>"},{"location":"refs/summary/#coola.summary.BaseCollectionSummarizer","title":"coola.summary.BaseCollectionSummarizer","text":"<p>               Bases: <code>BaseSummarizer[T]</code></p> <p>Base class for summarizing collection-based data structures.</p> <p>This class provides the foundation for summarizing various collection types with configurable formatting options. It handles item limiting and indentation for readable output.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>The maximum number of items to display in the summary. If set to a negative value (e.g., -1), all items in the collection will be shown without truncation. Defaults to 5.</p> <code>5</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces to use for indentation in the formatted output. This affects the visual structure of nested summaries. Defaults to 2.</p> <code>2</code> <p>Attributes:</p> Name Type Description <code>_max_items</code> <p>Stores the maximum number of items to display.</p> <code>_num_spaces</code> <p>Stores the number of spaces for indentation.</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, MappingSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer()})\n&gt;&gt;&gt; summarizer = MappingSummarizer()\n&gt;&gt;&gt; output = summarizer.summarize({\"key1\": 1.2, \"key2\": \"abc\", \"key3\": 42}, registry)\n&gt;&gt;&gt; print(output)\n&lt;class 'dict'&gt; (length=3)\n  (key1): 1.2\n  (key2): abc\n  (key3): 42\n</code></pre>"},{"location":"refs/summary/#coola.summary.BaseSummarizer","title":"coola.summary.BaseSummarizer","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for implementing data summarizers.</p> <p>A summarizer converts Python objects into formatted string representations, with support for nested structures and configurable depth limits. This is useful for debugging, logging, and displaying complex data in a readable format.</p> <p>The class is generic over type T, allowing concrete implementations to specialize for specific data types while maintaining type safety.</p> Notes <p>Concrete implementations must override the <code>summary</code> method to define how data should be formatted and displayed.</p> <p>The depth mechanism allows for progressive disclosure of nested structures, preventing overwhelming output for deeply nested data.</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; summarizer = DefaultSummarizer()\n&gt;&gt;&gt; print(summarizer.summarize(1, registry))\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/summary/#coola.summary.BaseSummarizer.equal","title":"coola.summary.BaseSummarizer.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: object) -&gt; bool\n</code></pre> <p>Check equality between this summarizer and another object.</p> <p>Two summarizers are considered equal if they are of the exact same type and have identical configuration parameters.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The object to compare with this summarizer.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, DefaultSummarizer, MappingSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; summarizer1 = DefaultSummarizer()\n&gt;&gt;&gt; summarizer2 = DefaultSummarizer()\n&gt;&gt;&gt; summarizer3 = MappingSummarizer()\n&gt;&gt;&gt; summarizer1.equal(summarizer2)\nTrue\n&gt;&gt;&gt; summarizer1.equal(summarizer3)\nFalse\n</code></pre>"},{"location":"refs/summary/#coola.summary.BaseSummarizer.summarize","title":"coola.summary.BaseSummarizer.summarize  <code>abstractmethod</code>","text":"<pre><code>summarize(\n    data: T,\n    registry: SummarizerRegistry,\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Generate a formatted string summary of the provided data.</p> <p>This method creates a human-readable representation of the input data, with support for nested structures up to a specified depth. When the current depth exceeds max_depth, nested structures are typically shown in a compact form without further expansion.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data object to summarize. Can be any Python object, though behavior depends on the concrete implementation.</p> required <code>registry</code> <code>SummarizerRegistry</code> <p>The summarizer registry used to look up summarizers for nested data structures of different types.</p> required <code>depth</code> <code>int</code> <p>The current nesting level in the data structure. Used internally during recursive summarization. Typically starts at 0 for top-level calls. Must be non-negative.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum nesting level to expand when summarizing. Structures deeper than this level are shown in compact form. Must be non-negative. Default is 1, which expands only the top level of nested structures.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string representation of the data. The exact format</p> <code>str</code> <p>depends on the concrete implementation, but typically includes</p> <code>str</code> <p>type information, size/length metadata, and indented content for</p> <code>str</code> <p>nested structures.</p> Notes <ul> <li>The depth parameter is primarily for internal use during recursion.   Most external callers should use the default value of 0.</li> <li>Setting max_depth=0 typically shows only top-level information   without expanding any nested structures.</li> <li>Higher max_depth values provide more detail but can produce   very long output for deeply nested data.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; summarizer = DefaultSummarizer()\n&gt;&gt;&gt; print(summarizer.summarize(1, registry))\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/summary/#coola.summary.DefaultSummarizer","title":"coola.summary.DefaultSummarizer","text":"<p>               Bases: <code>BaseSummarizer[object]</code></p> <p>Implement the default summarizer.</p> <p>Parameters:</p> Name Type Description Default <code>max_characters</code> <code>int</code> <p>The maximum number of characters to show. If a negative value is provided, all the characters are shown.</p> <code>-1</code> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; summarizer = DefaultSummarizer()\n&gt;&gt;&gt; print(summarizer.summarize(1, registry))\n&lt;class 'int'&gt; 1\n</code></pre>"},{"location":"refs/summary/#coola.summary.MappingSummarizer","title":"coola.summary.MappingSummarizer","text":"<p>               Bases: <code>BaseCollectionSummarizer[Mapping[Any, Any]]</code></p> <p>Summarizer for mapping-based data structures like dictionaries.</p> <p>This class formats mapping types (dict, OrderedDict, etc.) into readable summaries that display the type, length, and key-value pairs with proper indentation. It respects the max_items limit and handles nested structures through the registry system. This class creates a multi-line summary showing the mapping's type, length, and contents. It handles depth limiting to prevent excessively deep nested summaries and truncates the output when the number of items exceeds max_items.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>The maximum number of key-value pairs to display. If negative, shows all pairs. Defaults to 5.</p> <code>5</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces for indenting each level. Defaults to 2.</p> <code>2</code> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, MappingSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer()})\n&gt;&gt;&gt; summarizer = MappingSummarizer()\n&gt;&gt;&gt; output = summarizer.summarize({\"key1\": 1.2, \"key2\": \"abc\", \"key3\": 42}, registry)\n&gt;&gt;&gt; print(output)\n&lt;class 'dict'&gt; (length=3)\n  (key1): 1.2\n  (key2): abc\n  (key3): 42\n</code></pre>"},{"location":"refs/summary/#coola.summary.NDArraySummarizer","title":"coola.summary.NDArraySummarizer","text":"<p>               Bases: <code>BaseSummarizer[ndarray]</code></p> <p>Implement a summarizer for <code>numpy.ndarray</code> objects.</p> <p>This summarizer generates compact string representations of NumPy arrays. By default, it displays metadata (type, shape, dtype) rather than array values, making it suitable for logging and debugging large arrays. Optionally, it can show the full array representation.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, returns the default array string representation (same as <code>repr(array)</code>), displaying actual values. If <code>False</code> (default), returns only metadata in a compact format: <code>&lt;class&gt; | shape=&lt;shape&gt; | dtype=&lt;dtype&gt;</code>. Default: <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If NumPy is not installed or available.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.summary import SummarizerRegistry, NDArraySummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n\n&gt;&gt;&gt; # Default behavior: show metadata only\n&gt;&gt;&gt; summarizer = NDArraySummarizer()\n&gt;&gt;&gt; print(summarizer.summarize(np.arange(11), registry))\n&lt;class 'numpy.ndarray'&gt; | shape=(11,) | dtype=int64\n\n&gt;&gt;&gt; # Works with arrays of any shape and dtype\n&gt;&gt;&gt; print(summarizer.summarize(np.ones((2, 3, 4)), registry))\n&lt;class 'numpy.ndarray'&gt; | shape=(2, 3, 4) | dtype=float64\n\n&gt;&gt;&gt; # Show full array data\n&gt;&gt;&gt; summarizer = NDArraySummarizer(show_data=True)\n&gt;&gt;&gt; print(summarizer.summarize(np.arange(11), registry))\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])\n</code></pre>"},{"location":"refs/summary/#coola.summary.SequenceSummarizer","title":"coola.summary.SequenceSummarizer","text":"<p>               Bases: <code>BaseCollectionSummarizer[Sequence[Any]]</code></p> <p>Summarizer for sequence-based data structures like lists and tuples.</p> <p>This class formats sequence types (list, tuple, etc.) into readable summaries that display the type, length, and indexed items with proper indentation. It respects the max_items limit and handles nested structures through the registry system.</p> <p>This class creates a multi-line summary showing the sequence's type, length, and contents. It handles depth limiting to prevent excessively deep nested summaries and truncates the output when the number of items exceeds max_items.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>The maximum number of items to display. If negative, shows all items. Defaults to 5.</p> <code>5</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces for indenting each level. Defaults to 2.</p> <code>2</code> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer()})\n&gt;&gt;&gt; summarizer = SequenceSummarizer()\n&gt;&gt;&gt; output = summarizer.summarize([1, 2, 3], registry)\n&gt;&gt;&gt; print(output)\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre>"},{"location":"refs/summary/#coola.summary.SetSummarizer","title":"coola.summary.SetSummarizer","text":"<p>               Bases: <code>BaseCollectionSummarizer[Set[Any]]</code></p> <p>Summarizer for set-based data structures.</p> <p>This class formats set types (set, frozenset, etc.) into readable summaries that display the type, length, and items with proper indentation. It respects the max_items limit and handles nested structures through the registry system.</p> <p>This class creates a multi-line summary showing the set's type, length, and contents. It handles depth limiting to prevent excessively deep nested summaries and truncates the output when the number of items exceeds max_items.</p> <p>Parameters:</p> Name Type Description Default <code>max_items</code> <code>int</code> <p>The maximum number of items to display. If negative, shows all items. Defaults to 5.</p> <code>5</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces for indenting each level. Defaults to 2.</p> <code>2</code> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SetSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer()})\n&gt;&gt;&gt; summarizer = SetSummarizer()\n&gt;&gt;&gt; output = summarizer.summarize({1}, registry)\n&gt;&gt;&gt; print(output)\n&lt;class 'set'&gt; (length=1)\n  (0): 1\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry","title":"coola.summary.SummarizerRegistry","text":"<p>Registry that manages and dispatches summarizers based on data type.</p> <p>This registry maintains a mapping from Python types to summarizer instances and uses the Method Resolution Order (MRO) for type lookup. When summarizing data, it automatically selects the most specific registered summarizer for the data's type, falling back to parent types or a default summarizer if needed.</p> <p>The registry includes an LRU cache for type lookups to optimize performance in applications that repeatedly summarize similar data structures.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>dict[type, BaseSummarizer[Any]] | None</code> <p>Optional initial mapping of types to summarizers. If provided, the state is copied to prevent external mutations.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_state</code> <code>TypeRegistry[BaseSummarizer]</code> <p>Internal mapping of registered types to summarizers</p> Example <p>Basic usage with a sequence summarizer:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer(), list: SequenceSummarizer()})\n&gt;&gt;&gt; registry\nSummarizerRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'object'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'list'&gt;): SequenceSummarizer(max_items=5, num_spaces=2)\n    )\n)\n&gt;&gt;&gt; print(registry.summarize([1, 2, 3]))\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre> <p>Registering custom summarizers:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({object: DefaultSummarizer()})\n&gt;&gt;&gt; registry.register(tuple, SequenceSummarizer())\n&gt;&gt;&gt; print(registry.summarize((1, 2, 3)))\n&lt;class 'tuple'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre> <p>Working with nested structures:</p> <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; print(registry.summarize({\"a\": [1, 2], \"b\": [3, 4]}))\n&lt;class 'dict'&gt; (length=2)\n  (a): [1, 2]\n  (b): [3, 4]\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry.find_summarizer","title":"coola.summary.SummarizerRegistry.find_summarizer","text":"<pre><code>find_summarizer(data_type: type) -&gt; BaseSummarizer[Any]\n</code></pre> <p>Find the appropriate summarizer for a given type.</p> <p>Uses the Method Resolution Order (MRO) to find the most specific registered summarizer. For example, if you register a summarizer for Sequence but not for list, lists will use the Sequence summarizer.</p> <p>Results are cached using an LRU cache (256 entries) for performance, as summarizer lookup is a hot path in recursive summarizations.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to find a summarizer for</p> required <p>Returns:</p> Type Description <code>BaseSummarizer[Any]</code> <p>The most specific registered summarizer for this type, a parent</p> <code>BaseSummarizer[Any]</code> <p>type's summarizer via MRO, or the default summarizer</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; summarizer = registry.find_summarizer(list)\n&gt;&gt;&gt; summarizer\nSequenceSummarizer(max_items=5, num_spaces=2)\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry.has_summarizer","title":"coola.summary.SummarizerRegistry.has_summarizer","text":"<pre><code>has_summarizer(data_type: type) -&gt; bool\n</code></pre> <p>Check if a summarizer is explicitly registered for the given type.</p> <p>Note that this only checks for direct registration. Even if this returns False, find_summarizer() may still return a summarizer via MRO lookup or the default summarizer.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The type to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a summarizer is explicitly registered for this type,</p> <code>bool</code> <p>False otherwise</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry({list: SequenceSummarizer()})\n&gt;&gt;&gt; registry.has_summarizer(list)\nTrue\n&gt;&gt;&gt; registry.has_summarizer(tuple)\nFalse\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry.register","title":"coola.summary.SummarizerRegistry.register","text":"<pre><code>register(\n    data_type: type,\n    summarizer: BaseSummarizer[Any],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register a summarizer for a given data type.</p> <p>This method associates a summarizer instance with a specific Python type. When data of this type is summarized, the registered summarizer will be used. The cache is automatically cleared after registration to ensure consistency.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The Python type to register (e.g., list, dict, custom classes)</p> required <code>summarizer</code> <code>BaseSummarizer[Any]</code> <p>The summarizer instance that handles this type</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if the type is already registered. If True, overwrites the existing registration silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the type is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer())\n&gt;&gt;&gt; registry.has_summarizer(list)\nTrue\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry.register_many","title":"coola.summary.SummarizerRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[type, BaseSummarizer[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple summarizers at once.</p> <p>This is a convenience method for bulk registration that internally calls register() for each type-summarizer pair.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseSummarizer[Any]]</code> <p>Dictionary mapping Python types to summarizer instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if any type is already registered. If True, overwrites existing registrations silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any type is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, MappingSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register_many(\n...     {\n...         list: SequenceSummarizer(),\n...         dict: MappingSummarizer(),\n...     }\n... )\n&gt;&gt;&gt; registry\nSummarizerRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'list'&gt;): SequenceSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'dict'&gt;): MappingSummarizer(max_items=5, num_spaces=2)\n    )\n)\n</code></pre>"},{"location":"refs/summary/#coola.summary.SummarizerRegistry.summarize","title":"coola.summary.SummarizerRegistry.summarize","text":"<pre><code>summarize(\n    data: Any, depth: int = 0, max_depth: int = 1\n) -&gt; str\n</code></pre> <p>Generate a formatted string summary of the provided data.</p> <p>This method creates a human-readable representation of the input data, with support for nested structures up to a specified depth. When the current depth exceeds max_depth, nested structures are typically shown in a compact form without further expansion.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data object to summarize. Can be any Python object, though behavior depends on the registered summarizers.</p> required <code>depth</code> <code>int</code> <p>The current nesting level in the data structure. Used internally during recursive summarization. Typically starts at 0 for top-level calls. Must be non-negative.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum nesting level to expand when summarizing. Structures deeper than this level are shown in compact form. Must be non-negative. Default is 1, which expands only the top level of nested structures.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string representation of the data. The exact format</p> <code>str</code> <p>depends on the registered summarizer, but typically includes</p> <code>str</code> <p>type information, size/length metadata, and indented content for</p> <code>str</code> <p>nested structures.</p> Notes <ul> <li>The depth parameter is primarily for internal use during recursion.   Most external callers should use the default value of 0.</li> <li>Setting max_depth=0 typically shows only top-level information   without expanding any nested structures.</li> <li>Higher max_depth values provide more detail but can produce   very long output for deeply nested data.</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n\n&gt;&gt;&gt; # Simple value\n&gt;&gt;&gt; print(registry.summarize(1))\n&lt;class 'int'&gt; 1\n\n&gt;&gt;&gt; # List with default depth (expands first level only)\n&gt;&gt;&gt; print(registry.summarize([\"abc\", \"def\"]))\n&lt;class 'list'&gt; (length=2)\n  (0): abc\n  (1): def\n\n&gt;&gt;&gt; # Nested list, default max_depth=1 (inner list not expanded)\n&gt;&gt;&gt; print(registry.summarize([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n\n&gt;&gt;&gt; # Nested list with max_depth=2 (expands both levels)\n&gt;&gt;&gt; print(registry.summarize([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n&lt;class 'list'&gt; (length=2)\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n\n&gt;&gt;&gt; # Control depth for very nested structures\n&gt;&gt;&gt; deeply_nested = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n&gt;&gt;&gt; print(registry.summarize(deeply_nested))\n&lt;class 'list'&gt; (length=2)\n  (0): [[1, 2], [3, 4]]\n  (1): [[5, 6], [7, 8]]\n</code></pre>"},{"location":"refs/summary/#coola.summary.TensorSummarizer","title":"coola.summary.TensorSummarizer","text":"<p>               Bases: <code>BaseSummarizer[Tensor]</code></p> <p>Implement a summarizer for <code>torch.Tensor</code> objects.</p> <p>This summarizer generates compact string representations of PyTorch tensors. By default, it displays metadata (type, shape, dtype, device) rather than tensor values, making it suitable for logging and debugging large tensors. Optionally, it can show the full tensor representation.</p> <p>Parameters:</p> Name Type Description Default <code>show_data</code> <code>bool</code> <p>If <code>True</code>, returns the default tensor string representation (same as <code>repr(tensor)</code>), displaying actual values. If <code>False</code> (default), returns only metadata in a compact format: <code>&lt;class&gt; | shape=&lt;shape&gt; | dtype=&lt;dtype&gt; | device=&lt;device&gt;</code>. Default: <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If PyTorch is not installed or available.</p> Example <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.summary import SummarizerRegistry, TensorSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n\n&gt;&gt;&gt; # Default behavior: show metadata only\n&gt;&gt;&gt; summarizer = TensorSummarizer()\n&gt;&gt;&gt; print(summarizer.summarize(torch.arange(11), registry))  # doctest: +ELLIPSIS\n&lt;class 'torch.Tensor'&gt; | shape=torch.Size([11]) | dtype=torch.int64 | device=cpu | requires_grad=False\n\n&gt;&gt;&gt; # Works with tensors of any shape and dtype\n&gt;&gt;&gt; print(summarizer.summarize(torch.ones(2, 3, 4), registry))  # doctest: +ELLIPSIS\n&lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3, 4]) | dtype=torch.float32 | device=cpu | requires_grad=False\n\n&gt;&gt;&gt; # Show full tensor data\n&gt;&gt;&gt; summarizer = TensorSummarizer(show_data=True)\n&gt;&gt;&gt; print(summarizer.summarize(torch.arange(11), registry))  # doctest: +ELLIPSIS\ntensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])\n</code></pre>"},{"location":"refs/summary/#coola.summary.get_default_registry","title":"coola.summary.get_default_registry","text":"<pre><code>get_default_registry() -&gt; SummarizerRegistry\n</code></pre> <p>Get or create the default global registry with common Python types.</p> <p>Returns a singleton registry instance that is pre-configured with summarizers for Python's built-in types including sequences (list, tuple), mappings (dict), sets, and scalar types (int, float, str, bool).</p> <p>This function uses a singleton pattern to ensure the same registry instance is returned on subsequent calls, which is efficient and maintains consistency across an application.</p> <p>Returns:</p> Type Description <code>SummarizerRegistry</code> <p>A SummarizerRegistry instance with summarizers registered for: - Scalar types (int, float, complex, bool, str) - Sequences (list, tuple, Sequence ABC) - Sets (set, frozenset) - Mappings (dict, Mapping ABC)</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. If you need an isolated registry, create a new SummarizerRegistry instance directly.</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; # Registry is ready to use with common Python types\n&gt;&gt;&gt; print(registry.summarize([1, 2, 3]))\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n&gt;&gt;&gt; print(registry.summarize({\"a\": 1, \"b\": 2}))\n&lt;class 'dict'&gt; (length=2)\n  (a): 1\n  (b): 2\n</code></pre>"},{"location":"refs/summary/#coola.summary.register_summarizers","title":"coola.summary.register_summarizers","text":"<pre><code>register_summarizers(\n    mapping: Mapping[type, BaseSummarizer[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom summarizers to the default global registry.</p> <p>This allows users to add support for custom types without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[type, BaseSummarizer[Any]]</code> <p>Dictionary mapping types to summarizer instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False, raises error if any type already registered</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from coola.summary import register_summarizers, BaseSummarizer, SummarizerRegistry\n&gt;&gt;&gt; class MyType:\n...     def __init__(self, value):\n...         self.value = value\n...\n&gt;&gt;&gt; class MySummarizer(BaseSummarizer[MyType]):\n...     def equal(self, other: object) -&gt; bool:\n...         return type(object) is type(self)\n...     def summarize(\n...         self,\n...         data: MyType,\n...         registry: SummarizerRegistry,\n...         depth: int = 0,\n...         max_depth: int = 1,\n...     ) -&gt; str:\n...         return f\"&lt;MyType&gt; value={data.value}\"\n...\n&gt;&gt;&gt; register_summarizers({MyType: MySummarizer()})\n</code></pre>"},{"location":"refs/summary/#coola.summary.summarize","title":"coola.summary.summarize","text":"<pre><code>summarize(\n    data: object,\n    max_depth: int = 1,\n    registry: SummarizerRegistry | None = None,\n) -&gt; str\n</code></pre> <p>Create a summary string representation of nested data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>object</code> <p>Input data (can be nested)</p> required <code>max_depth</code> <code>int</code> <p>The maximum nesting level to expand when summarizing. Structures deeper than this level are shown in compact form. Must be non-negative. Default is 1, which expands only the top level of nested structures.</p> <code>1</code> <code>registry</code> <code>SummarizerRegistry | None</code> <p>Registry to resolve summarizers for nested data. If None, uses the default registry.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>String summary of the data</p> Example <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize({\"a\": 1, \"b\": \"abc\"}))\n&lt;class 'dict'&gt; (length=2)\n  (a): 1\n  (b): abc\n</code></pre>"},{"location":"refs/testers/","title":"Testers","text":""},{"location":"refs/testers/#coola.equality.testers","title":"coola.equality.testers","text":"<p>Contain the testers to check if two objects are equal or not.</p>"},{"location":"refs/testers/#coola.equality.testers.BaseEqualityTester","title":"coola.equality.testers.BaseEqualityTester","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an equality tester.</p>"},{"location":"refs/testers/#coola.equality.testers.BaseEqualityTester.equal","title":"coola.equality.testers.BaseEqualityTester.equal  <code>abstractmethod</code>","text":"<pre><code>equal(\n    actual: Any, expected: Any, config: EqualityConfig\n) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Any</code> <p>The actual input.</p> required <code>expected</code> <code>Any</code> <p>The expected input.</p> required <code>config</code> <code>EqualityConfig</code> <p>The equality configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester()\n&gt;&gt;&gt; config = EqualityConfig(tester=tester)\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.zeros(2)], [np.ones((2, 3)), np.zeros(2)], config)\nTrue\n&gt;&gt;&gt; tester.equal([np.ones((2, 3)), np.ones(2)], [np.ones((2, 3)), np.zeros(2)], config)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester","title":"coola.equality.testers.EqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement the default equality tester.</p>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.add_comparator","title":"coola.equality.testers.EqualityTester.add_comparator  <code>classmethod</code>","text":"<pre><code>add_comparator(\n    data_type: type[T],\n    comparator: BaseEqualityComparator[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator[T]</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a comparator is already registered for the data type and <code>exist_ok=False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import SequenceEqualityComparator\n&gt;&gt;&gt; EqualityTester.add_comparator(list, SequenceEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.find_comparator","title":"coola.equality.testers.EqualityTester.find_comparator  <code>classmethod</code>","text":"<pre><code>find_comparator(\n    data_type: type[T],\n) -&gt; BaseEqualityComparator[T]\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator[T]</code> <p>The equality comparator associated to the data type.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; EqualityTester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.has_comparator","title":"coola.equality.testers.EqualityTester.has_comparator  <code>classmethod</code>","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.has_comparator(list)\nTrue\n&gt;&gt;&gt; EqualityTester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.EqualityTester.local_copy","title":"coola.equality.testers.EqualityTester.local_copy  <code>classmethod</code>","text":"<pre><code>local_copy() -&gt; LocalEqualityTester\n</code></pre> <p>Return a copy of <code>EqualityTester</code> that can easily be customized without changind <code>EqualityTester</code>.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A \"local\" copy of <code>EqualityTester</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester\nLocalEqualityTester(...)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester","title":"coola.equality.testers.LocalEqualityTester","text":"<p>               Bases: <code>BaseEqualityTester</code></p> <p>Implement an equality tester that can be easily customized.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[type[object], BaseEqualityComparator[Any]] | None</code> <p>The initial registry with the equality comparators.</p> <code>None</code>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.add_comparator","title":"coola.equality.testers.LocalEqualityTester.add_comparator","text":"<pre><code>add_comparator(\n    data_type: type[T],\n    comparator: BaseEqualityComparator[T],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an equality comparator for a given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type for this test.</p> required <code>comparator</code> <code>BaseEqualityComparator[T]</code> <p>The comparator used to test the equality of the specified type.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the data type already exists. This parameter should be set to <code>True</code> to overwrite the comparator for a type.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an comparator is already registered for the data type and <code>exist_ok=False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; from coola.equality.comparators import DefaultEqualityComparator\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator())\n&gt;&gt;&gt; tester.add_comparator(str, DefaultEqualityComparator(), exist_ok=True)\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.clone","title":"coola.equality.testers.LocalEqualityTester.clone","text":"<pre><code>clone() -&gt; LocalEqualityTester\n</code></pre> <p>Clones the current tester.</p> <p>Returns:</p> Type Description <code>LocalEqualityTester</code> <p>A deep copy of the current tester.</p> Example <p>```pycon</p> <p>from coola.equality.testers import EqualityTester tester = EqualityTester.local_copy() tester_cloned = tester.clone()</p> <pre><code>```\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.find_comparator","title":"coola.equality.testers.LocalEqualityTester.find_comparator","text":"<pre><code>find_comparator(\n    data_type: type[T],\n) -&gt; BaseEqualityComparator[T]\n</code></pre> <p>Find the equality comparator associated to an object.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type[T]</code> <p>The data type to get.</p> required <p>Returns:</p> Type Description <code>BaseEqualityComparator[T]</code> <p>The equality comparator associated to the data type.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.find_comparator(list)\nSequenceEqualityComparator()\n&gt;&gt;&gt; tester.find_comparator(str)\nDefaultEqualityComparator()\n</code></pre>"},{"location":"refs/testers/#coola.equality.testers.LocalEqualityTester.has_comparator","title":"coola.equality.testers.LocalEqualityTester.has_comparator","text":"<pre><code>has_comparator(data_type: type) -&gt; bool\n</code></pre> <p>Indicate if an equality comparator is registered for the given data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The data type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an equality comparator is registered, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.has_comparator(list)\nTrue\n&gt;&gt;&gt; tester.has_comparator(str)\nFalse\n</code></pre>"},{"location":"refs/testing/","title":"Testing","text":""},{"location":"refs/testing/#coola.testing","title":"coola.testing","text":"<p>Define some testing utilities.</p>"},{"location":"refs/testing/#coola.testing.fixtures","title":"coola.testing.fixtures","text":"<p>Define some pytest fixtures for testing.</p> <p><code>pytest</code> is required to use these fixtures.</p>"},{"location":"refs/utils/","title":"Utils","text":""},{"location":"refs/utils/#coola.utils","title":"coola.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#coola.utils.check_numpy","title":"coola.utils.check_numpy","text":"<pre><code>check_numpy() -&gt; None\n</code></pre> <p>Check if the <code>numpy</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>numpy</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_numpy\n&gt;&gt;&gt; check_numpy()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_pandas","title":"coola.utils.check_pandas","text":"<pre><code>check_pandas() -&gt; None\n</code></pre> <p>Check if the <code>pandas</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pandas</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_pandas\n&gt;&gt;&gt; check_pandas()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_polars","title":"coola.utils.check_polars","text":"<pre><code>check_polars() -&gt; None\n</code></pre> <p>Check if the <code>polars</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>polars</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_polars\n&gt;&gt;&gt; check_polars()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_torch","title":"coola.utils.check_torch","text":"<pre><code>check_torch() -&gt; None\n</code></pre> <p>Check if the <code>torch</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>torch</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_torch\n&gt;&gt;&gt; check_torch()\n</code></pre>"},{"location":"refs/utils/#coola.utils.check_xarray","title":"coola.utils.check_xarray","text":"<pre><code>check_xarray() -&gt; None\n</code></pre> <p>Check if the <code>xarray</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>xarray</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_xarray\n&gt;&gt;&gt; check_xarray()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_jax_available","title":"coola.utils.is_jax_available  <code>cached</code>","text":"<pre><code>is_jax_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>jax</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>jax</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_jax_available\n&gt;&gt;&gt; is_jax_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_numpy_available","title":"coola.utils.is_numpy_available  <code>cached</code>","text":"<pre><code>is_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>numpy</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>numpy</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_numpy_available\n&gt;&gt;&gt; is_numpy_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_pandas_available","title":"coola.utils.is_pandas_available  <code>cached</code>","text":"<pre><code>is_pandas_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pandas</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pandas</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_pandas_available\n&gt;&gt;&gt; is_pandas_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_polars_available","title":"coola.utils.is_polars_available  <code>cached</code>","text":"<pre><code>is_polars_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>polars</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>polars</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_polars_available\n&gt;&gt;&gt; is_polars_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_torch_available","title":"coola.utils.is_torch_available  <code>cached</code>","text":"<pre><code>is_torch_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>torch</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>torch</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_torch_available\n&gt;&gt;&gt; is_torch_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.is_xarray_available","title":"coola.utils.is_xarray_available  <code>cached</code>","text":"<pre><code>is_xarray_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>xarray</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>xarray</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_xarray_available\n&gt;&gt;&gt; is_xarray_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.module_available","title":"coola.utils.module_available  <code>cached</code>","text":"<pre><code>module_available(name: str) -&gt; bool\n</code></pre> <p>Indicate if a module is available or not.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The module name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the module is available, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import module_available\n&gt;&gt;&gt; module_available(\"os\")\nTrue\n&gt;&gt;&gt; module_available(\"os.missing\")\nFalse\n&gt;&gt;&gt; module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/utils/#coola.utils.package_available","title":"coola.utils.package_available  <code>cached</code>","text":"<pre><code>package_available(name: str) -&gt; bool\n</code></pre> <p>Indicate if a package is available or not.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import package_available\n&gt;&gt;&gt; package_available(\"os\")\nTrue\n&gt;&gt;&gt; package_available(\"missing_package\")\nFalse\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_indent","title":"coola.utils.repr_indent","text":"<pre><code>repr_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>repr</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_mapping","title":"coola.utils.repr_mapping","text":"<pre><code>repr_mapping(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_mapping\n&gt;&gt;&gt; print(repr_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.repr_sequence","title":"coola.utils.repr_sequence","text":"<pre><code>repr_sequence(\n    sequence: Sequence[Any], num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_indent","title":"coola.utils.str_indent","text":"<pre><code>str_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>str</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_indent\n&gt;&gt;&gt; print(str_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_mapping","title":"coola.utils.str_mapping","text":"<pre><code>str_mapping(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_mapping\n&gt;&gt;&gt; print(str_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.str_sequence","title":"coola.utils.str_sequence","text":"<pre><code>str_sequence(\n    sequence: Sequence[Any], num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_sequence\n&gt;&gt;&gt; print(str_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.array","title":"coola.utils.array","text":"<p>Implement some utility functions for <code>numpy.ndarray</code>s.</p>"},{"location":"refs/utils/#coola.utils.array.to_array","title":"coola.utils.array.to_array","text":"<pre><code>to_array(\n    data: Sequence[int | float] | Tensor | ndarray,\n) -&gt; ndarray\n</code></pre> <p>Convert the input to a <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[int | float] | Tensor | ndarray</code> <p>The data to convert to a NumPy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A NumPy array.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.array import to_array\n&gt;&gt;&gt; x = to_array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; x = to_array(torch.tensor([1, 2, 3, 4, 5]))\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n</code></pre>"},{"location":"refs/utils/#coola.utils.env_vars","title":"coola.utils.env_vars","text":"<p>Implement some utility functions to manage environment variables.</p>"},{"location":"refs/utils/#coola.utils.env_vars.temp_env_vars","title":"coola.utils.env_vars.temp_env_vars","text":"<pre><code>temp_env_vars(\n    env_vars: dict[str, Any],\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Context manager to temporarily set or modify environment variables.</p> <p>This context manager allows you to temporarily change environment variables within a specific scope. All changes are automatically reverted when exiting the context, even if an exception occurs.</p> <p>Parameters:</p> Name Type Description Default <code>env_vars</code> <code>dict[str, Any]</code> <p>Environment variables to set as keyword arguments. Keys are variable names, values are the values to set. Values are automatically converted to strings.</p> required Behavior <ul> <li>If a variable already exists, its original value is saved and restored</li> <li>If a variable doesn't exist, it's created temporarily and removed on exit</li> <li>All operations are guaranteed to execute via try/finally</li> <li>Thread-safe for the current process (but note that os.environ affects   the entire process, not just the current thread)</li> </ul> Example <pre><code>&gt;&gt;&gt; from coola.utils.env_vars import temp_env_vars\n&gt;&gt;&gt; # Temporarily override an existing variable\n&gt;&gt;&gt; os.environ[\"HOME\"] = \"/original/home\"\n&gt;&gt;&gt; with temp_env_vars({\"HOME\": \"/tmp/home\"}):\n...     print(os.environ[\"HOME\"])  # '/tmp/home'\n...\n&gt;&gt;&gt; print(os.environ[\"HOME\"])  # '/original/home'\n&gt;&gt;&gt; # Temporarily create new variables\n&gt;&gt;&gt; with temp_env_vars({\"API_KEY\": \"secret123\", \"DEBUG\": \"true\"}):\n...     print(os.environ[\"API_KEY\"])  # 'secret123'\n...     print(os.environ[\"DEBUG\"])  # 'true'\n...\n&gt;&gt;&gt; print(os.environ.get(\"API_KEY\"))  # None (removed)\n</code></pre> Notes <p>Changes to os.environ affect the entire Python process, not just the current thread. Use with caution in multi-threaded applications.</p>"},{"location":"refs/utils/#coola.utils.format","title":"coola.utils.format","text":"<p>Implement some utility functions to compute string representations of objects.</p>"},{"location":"refs/utils/#coola.utils.format.find_best_byte_unit","title":"coola.utils.format.find_best_byte_unit","text":"<pre><code>find_best_byte_unit(size: int) -&gt; str\n</code></pre> <p>Return the best byte unit given the byte size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The size in bytes.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The best unit. The supported units are: <code>'B'</code>, <code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>, <code>'TB'</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import find_best_byte_unit\n&gt;&gt;&gt; find_best_byte_unit(2)\n'B'\n&gt;&gt;&gt; find_best_byte_unit(2048)\n'KB'\n&gt;&gt;&gt; find_best_byte_unit(2097152)\n'MB'\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.repr_indent","title":"coola.utils.format.repr_indent","text":"<pre><code>repr_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>repr</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.repr_mapping","title":"coola.utils.format.repr_mapping","text":"<pre><code>repr_mapping(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_mapping\n&gt;&gt;&gt; print(repr_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.repr_mapping_line","title":"coola.utils.format.repr_mapping_line","text":"<pre><code>repr_mapping_line(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    separator: str = \", \",\n) -&gt; str\n</code></pre> <p>Compute a single line string representation of the given mapping.</p> <p>This function is designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>separator</code> <code>str</code> <p>The separator to use between each key-value pair.</p> <code>', '</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_mapping_line\n&gt;&gt;&gt; repr_mapping_line({\"key1\": \"abc\", \"key2\": \"meow\", \"key3\": 42})\nkey1='abc', key2='meow', key3=42\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.repr_sequence","title":"coola.utils.format.repr_sequence","text":"<pre><code>repr_sequence(\n    sequence: Sequence[Any], num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_indent\n&gt;&gt;&gt; print(repr_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.repr_sequence_line","title":"coola.utils.format.repr_sequence_line","text":"<pre><code>repr_sequence_line(\n    sequence: Sequence[Any], separator: str = \", \"\n) -&gt; str\n</code></pre> <p>Compute a single line string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>separator</code> <code>str</code> <p>The separator to use between each item.</p> <code>', '</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import repr_sequence_line\n&gt;&gt;&gt; repr_sequence_line([\"abc\", \"meow\", 42])\n'abc', 'meow', 42\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_human_byte_size","title":"coola.utils.format.str_human_byte_size","text":"<pre><code>str_human_byte_size(\n    size: int, unit: str | None = None\n) -&gt; str\n</code></pre> <p>Get a human-readable representation of the byte size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The size in bytes.</p> required <code>unit</code> <code>str | None</code> <p>The unit to use to show the byte size. If <code>None</code>, the best unit is found automatically. The supported units are: <code>'B'</code>, <code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>, <code>'TB'</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The byte size in a human-readable format.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_human_byte_size\n&gt;&gt;&gt; str_human_byte_size(2)\n'2.00 B'\n&gt;&gt;&gt; str_human_byte_size(2048)\n'2.00 KB'\n&gt;&gt;&gt; str_human_byte_size(2097152)\n'2.00 MB'\n&gt;&gt;&gt; str_human_byte_size(2048, unit=\"B\")\n'2,048.00 B'\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_indent","title":"coola.utils.format.str_indent","text":"<pre><code>str_indent(original: Any, num_spaces: int = 2) -&gt; str\n</code></pre> <p>Add indentations if the original string is a multi-lines string.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Any</code> <p>The original string. If the inputis not a string, it will be converted to a string with the function <code>str</code>.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The indented string.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if num_spaces is not a positive integer.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_indent\n&gt;&gt;&gt; print(str_indent(\"string1\\nstring2\\n  string3\", 4))\nstring1\nstring2\n  string3\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_mapping","title":"coola.utils.format.str_mapping","text":"<pre><code>str_mapping(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    num_spaces: int = 2,\n) -&gt; str\n</code></pre> <p>Compute a string representation of a mapping.</p> <p>This function was designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_mapping\n&gt;&gt;&gt; print(str_mapping({\"key1\": \"abc\", \"key2\": \"something\\nelse\"}))\n(key1): abc\n(key2): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_mapping_line","title":"coola.utils.format.str_mapping_line","text":"<pre><code>str_mapping_line(\n    mapping: Mapping[Any, Any],\n    sorted_keys: bool = False,\n    separator: str = \", \",\n) -&gt; str\n</code></pre> <p>Compute a single line string representation of the given mapping.</p> <p>This function is designed for flat dictionary. If you have a nested dictionary, you may consider other functions. Note that this function works for nested dict but the output may not be nice.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping.</p> required <code>sorted_keys</code> <code>bool</code> <p>If <code>True</code>, the keys in the mapping are sorted before to compute the string representation.</p> <code>False</code> <code>separator</code> <code>str</code> <p>The separator to use between each key-value pair.</p> <code>', '</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the mapping.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_mapping_line\n&gt;&gt;&gt; str_mapping_line({\"key1\": \"abc\", \"key2\": \"meow\", \"key3\": 42})\nkey1=abc, key2=meow, key3=42\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_sequence","title":"coola.utils.format.str_sequence","text":"<pre><code>str_sequence(\n    sequence: Sequence[Any], num_spaces: int = 2\n) -&gt; str\n</code></pre> <p>Compute a string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>num_spaces</code> <code>int</code> <p>The number of spaces used for the indentation.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_sequence\n&gt;&gt;&gt; print(str_sequence([\"abc\", \"something\\nelse\"]))\n(0): abc\n(1): something\n  else\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_sequence_line","title":"coola.utils.format.str_sequence_line","text":"<pre><code>str_sequence_line(\n    sequence: Sequence[Any], separator: str = \", \"\n) -&gt; str\n</code></pre> <p>Compute a single line string representation of a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence[Any]</code> <p>The sequence.</p> required <code>separator</code> <code>str</code> <p>The separator to use between each item.</p> <code>', '</code> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the sequence.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_sequence_line\n&gt;&gt;&gt; str_sequence_line([\"abc\", \"meow\", 42])\nabc, meow, 42\n</code></pre>"},{"location":"refs/utils/#coola.utils.format.str_time_human","title":"coola.utils.format.str_time_human","text":"<pre><code>str_time_human(seconds: float) -&gt; str\n</code></pre> <p>Return a number of seconds in an easier format to read <code>hh:mm:ss</code>.</p> <p>If the number of seconds is bigger than 1 day, this representation also encodes the number of days.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The number of seconds in a string format (<code>hh:mm:ss</code>).</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.format import str_time_human\n&gt;&gt;&gt; str_time_human(1.2)\n'0:00:01.200000'\n&gt;&gt;&gt; str_time_human(61.2)\n'0:01:01.200000'\n&gt;&gt;&gt; str_time_human(3661.2)\n'1:01:01.200000'\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports","title":"coola.utils.imports","text":"<p>Implement some utility functions to manage optional dependencies.</p>"},{"location":"refs/utils/#coola.utils.imports.LazyModule","title":"coola.utils.imports.LazyModule","text":"<p>               Bases: <code>ModuleType</code></p> <p>Define a proxy module that lazily imports a module.</p> <p>The module is imported the first time it is actually used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The fully-qualified module name to import.</p> required Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import LazyModule\n&gt;&gt;&gt; # Lazy version of import numpy as np\n&gt;&gt;&gt; np = LazyModule(\"numpy\")\n&gt;&gt;&gt; # The module is imported the first time it is actually used.\n&gt;&gt;&gt; np.ones((2, 3))\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_jax","title":"coola.utils.imports.check_jax","text":"<pre><code>check_jax() -&gt; None\n</code></pre> <p>Check if the <code>jax</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>jax</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_jax\n&gt;&gt;&gt; check_jax()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_numpy","title":"coola.utils.imports.check_numpy","text":"<pre><code>check_numpy() -&gt; None\n</code></pre> <p>Check if the <code>numpy</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>numpy</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_numpy\n&gt;&gt;&gt; check_numpy()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_package","title":"coola.utils.imports.check_package","text":"<pre><code>check_package(\n    package: str, command: str | None = None\n) -&gt; None\n</code></pre> <p>Check if the given package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <code>command</code> <code>str | None</code> <p>The command to install the package.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_package\n&gt;&gt;&gt; check_package(\"numpy\")\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_packaging","title":"coola.utils.imports.check_packaging","text":"<pre><code>check_packaging() -&gt; None\n</code></pre> <p>Check if the <code>packaging</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>packaging</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_packaging\n&gt;&gt;&gt; check_packaging()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_pandas","title":"coola.utils.imports.check_pandas","text":"<pre><code>check_pandas() -&gt; None\n</code></pre> <p>Check if the <code>pandas</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pandas</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_pandas\n&gt;&gt;&gt; check_pandas()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_polars","title":"coola.utils.imports.check_polars","text":"<pre><code>check_polars() -&gt; None\n</code></pre> <p>Check if the <code>polars</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>polars</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_polars\n&gt;&gt;&gt; check_polars()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_pyarrow","title":"coola.utils.imports.check_pyarrow","text":"<pre><code>check_pyarrow() -&gt; None\n</code></pre> <p>Check if the <code>pyarrow</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pyarrow</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_pyarrow\n&gt;&gt;&gt; check_pyarrow()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_torch","title":"coola.utils.imports.check_torch","text":"<pre><code>check_torch() -&gt; None\n</code></pre> <p>Check if the <code>torch</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>torch</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_torch\n&gt;&gt;&gt; check_torch()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_torch_numpy","title":"coola.utils.imports.check_torch_numpy","text":"<pre><code>check_torch_numpy() -&gt; None\n</code></pre> <p>Check if the <code>torch</code> and <code>numpy</code> packages are installed and are compatible.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if one of the packages is not installed or if they are not compatible.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_torch_numpy\n&gt;&gt;&gt; check_torch_numpy()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.check_xarray","title":"coola.utils.imports.check_xarray","text":"<pre><code>check_xarray() -&gt; None\n</code></pre> <p>Check if the <code>xarray</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>xarray</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import check_xarray\n&gt;&gt;&gt; check_xarray()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.decorator_package_available","title":"coola.utils.imports.decorator_package_available","text":"<pre><code>decorator_package_available(\n    fn: Callable[..., Any], condition: Callable[[], bool]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if a package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <code>condition</code> <code>Callable[[], bool]</code> <p>The condition to check if a package is installed or not.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if condition is true, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; from coola.utils.imports import decorator_package_available\n&gt;&gt;&gt; decorator = partial(decorator_package_available, condition=is_numpy_available)\n&gt;&gt;&gt; @decorator\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function(2)\n    44\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_jax_available","title":"coola.utils.imports.is_jax_available  <code>cached</code>","text":"<pre><code>is_jax_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>jax</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>jax</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_jax_available\n&gt;&gt;&gt; is_jax_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_numpy_available","title":"coola.utils.imports.is_numpy_available  <code>cached</code>","text":"<pre><code>is_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>numpy</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>numpy</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_numpy_available\n&gt;&gt;&gt; is_numpy_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_packaging_available","title":"coola.utils.imports.is_packaging_available  <code>cached</code>","text":"<pre><code>is_packaging_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>packaging</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>packaging</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_packaging_available\n&gt;&gt;&gt; is_packaging_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_pandas_available","title":"coola.utils.imports.is_pandas_available  <code>cached</code>","text":"<pre><code>is_pandas_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pandas</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pandas</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_pandas_available\n&gt;&gt;&gt; is_pandas_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_polars_available","title":"coola.utils.imports.is_polars_available  <code>cached</code>","text":"<pre><code>is_polars_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>polars</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>polars</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_polars_available\n&gt;&gt;&gt; is_polars_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_pyarrow_available","title":"coola.utils.imports.is_pyarrow_available  <code>cached</code>","text":"<pre><code>is_pyarrow_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pyarrow</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pyarrow</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_pyarrow_available\n&gt;&gt;&gt; is_pyarrow_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_torch_available","title":"coola.utils.imports.is_torch_available  <code>cached</code>","text":"<pre><code>is_torch_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>torch</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>torch</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_torch_available\n&gt;&gt;&gt; is_torch_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_torch_numpy_available","title":"coola.utils.imports.is_torch_numpy_available  <code>cached</code>","text":"<pre><code>is_torch_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>torch</code> and <code>numpy</code> packages are installed and are compatible.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if both packages are available and compatible, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_torch_numpy_available\n&gt;&gt;&gt; is_torch_numpy_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.is_xarray_available","title":"coola.utils.imports.is_xarray_available  <code>cached</code>","text":"<pre><code>is_xarray_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>xarray</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>xarray</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import is_xarray_available\n&gt;&gt;&gt; is_xarray_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.jax_available","title":"coola.utils.imports.jax_available","text":"<pre><code>jax_available(fn: Callable[..., Any]) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>jax</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>jax</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import jax_available\n&gt;&gt;&gt; @jax_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.lazy_import","title":"coola.utils.imports.lazy_import","text":"<pre><code>lazy_import(name: str) -&gt; LazyModule\n</code></pre> <p>Return a proxy of the module/package to lazily import.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The fully-qualified module name to import.</p> required <p>Returns:</p> Type Description <code>LazyModule</code> <p>A proxy module that lazily imports a module the first time it is actually used.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import lazy_import\n&gt;&gt;&gt; # Lazy version of import numpy as np\n&gt;&gt;&gt; np = lazy_import(\"numpy\")\n&gt;&gt;&gt; # The module is imported the first time it is actually used.\n&gt;&gt;&gt; np.ones((2, 3))\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.module_available","title":"coola.utils.imports.module_available  <code>cached</code>","text":"<pre><code>module_available(name: str) -&gt; bool\n</code></pre> <p>Indicate if a module is available or not.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The module name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the module is available, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import module_available\n&gt;&gt;&gt; module_available(\"os\")\nTrue\n&gt;&gt;&gt; module_available(\"os.missing\")\nFalse\n&gt;&gt;&gt; module_available(\"missing.module\")\nFalse\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.numpy_available","title":"coola.utils.imports.numpy_available","text":"<pre><code>numpy_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>numpy</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>numpy</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import numpy_available\n&gt;&gt;&gt; @numpy_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.package_available","title":"coola.utils.imports.package_available  <code>cached</code>","text":"<pre><code>package_available(name: str) -&gt; bool\n</code></pre> <p>Indicate if a package is available or not.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The package name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is available, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import package_available\n&gt;&gt;&gt; package_available(\"os\")\nTrue\n&gt;&gt;&gt; package_available(\"missing_package\")\nFalse\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.packaging_available","title":"coola.utils.imports.packaging_available","text":"<pre><code>packaging_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>packaging</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>packaging</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import packaging_available\n&gt;&gt;&gt; @packaging_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.pandas_available","title":"coola.utils.imports.pandas_available","text":"<pre><code>pandas_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>pandas</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>pandas</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import pandas_available\n&gt;&gt;&gt; @pandas_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.polars_available","title":"coola.utils.imports.polars_available","text":"<pre><code>polars_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>polars</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>polars</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import polars_available\n&gt;&gt;&gt; @polars_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.pyarrow_available","title":"coola.utils.imports.pyarrow_available","text":"<pre><code>pyarrow_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>pyarrow</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>pyarrow</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import pyarrow_available\n&gt;&gt;&gt; @pyarrow_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.raise_error_jax_missing","title":"coola.utils.imports.raise_error_jax_missing","text":"<pre><code>raise_error_jax_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>jax</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_numpy_missing","title":"coola.utils.imports.raise_error_numpy_missing","text":"<pre><code>raise_error_numpy_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>numpy</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_packaging_missing","title":"coola.utils.imports.raise_error_packaging_missing","text":"<pre><code>raise_error_packaging_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>packaging</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_pandas_missing","title":"coola.utils.imports.raise_error_pandas_missing","text":"<pre><code>raise_error_pandas_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>pandas</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_polars_missing","title":"coola.utils.imports.raise_error_polars_missing","text":"<pre><code>raise_error_polars_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>polars</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_pyarrow_missing","title":"coola.utils.imports.raise_error_pyarrow_missing","text":"<pre><code>raise_error_pyarrow_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>pyarrow</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_torch_missing","title":"coola.utils.imports.raise_error_torch_missing","text":"<pre><code>raise_error_torch_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>torch</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.raise_error_xarray_missing","title":"coola.utils.imports.raise_error_xarray_missing","text":"<pre><code>raise_error_xarray_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>xarray</code> package is missing.</p>"},{"location":"refs/utils/#coola.utils.imports.torch_available","title":"coola.utils.imports.torch_available","text":"<pre><code>torch_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>torch</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>torch</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import torch_available\n&gt;&gt;&gt; @torch_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.torch_numpy_available","title":"coola.utils.imports.torch_numpy_available","text":"<pre><code>torch_numpy_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>torch</code> and <code>numpy</code> packages are installed and are compatible.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>torch</code> and <code>numpy</code> packages are installed and are compatible., otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import torch_numpy_available\n&gt;&gt;&gt; @torch_numpy_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.imports.xarray_available","title":"coola.utils.imports.xarray_available","text":"<pre><code>xarray_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>xarray</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>xarray</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.imports import xarray_available\n&gt;&gt;&gt; @xarray_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#coola.utils.introspection","title":"coola.utils.introspection","text":"<p>Utilities for introspecting Python objects and retrieving their fully qualified names.</p>"},{"location":"refs/utils/#coola.utils.introspection.get_fully_qualified_name","title":"coola.utils.introspection.get_fully_qualified_name","text":"<pre><code>get_fully_qualified_name(obj: Any) -&gt; str\n</code></pre> <p>Return the fully qualified name of a Python object.</p> <p>Supports functions, classes, methods, and instances. For instances, returns the fully qualified class name.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object whose name is to be computed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The fully qualified name.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.introspection import get_fully_qualified_name\n&gt;&gt;&gt; import collections\n&gt;&gt;&gt; get_fully_qualified_name(collections.Counter)\n'collections.Counter'\n&gt;&gt;&gt; class MyClass:\n...     pass\n...\n&gt;&gt;&gt; get_fully_qualified_name(MyClass)\n'....MyClass'\n&gt;&gt;&gt; get_fully_qualified_name(map)\n'builtins.map'\n</code></pre>"},{"location":"refs/utils/#coola.utils.mapping","title":"coola.utils.mapping","text":"<p>Contain utility functions for mappings.</p>"},{"location":"refs/utils/#coola.utils.mapping.sort_by_keys","title":"coola.utils.mapping.sort_by_keys","text":"<pre><code>sort_by_keys(mapping: Mapping[Any, Any]) -&gt; dict[Any, Any]\n</code></pre> <p>Sort a dictionary by keys.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The dictionary to sort.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[Any, Any]</code> <p>The sorted dictionary.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.mapping import sort_by_keys\n&gt;&gt;&gt; sort_by_keys({\"dog\": 1, \"cat\": 5, \"fish\": 2})\n{'cat': 5, 'dog': 1, 'fish': 2}\n</code></pre>"},{"location":"refs/utils/#coola.utils.mapping.sort_by_values","title":"coola.utils.mapping.sort_by_values","text":"<pre><code>sort_by_values(\n    mapping: Mapping[Any, Any],\n) -&gt; dict[Any, Any]\n</code></pre> <p>Sort a dictionary by keys.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The dictionary to sort.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[Any, Any]</code> <p>The sorted dictionary.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.mapping import sort_by_values\n&gt;&gt;&gt; sort_by_values({\"dog\": 1, \"cat\": 5, \"fish\": 2})\n{'dog': 1, 'fish': 2, 'cat': 5}\n</code></pre>"},{"location":"refs/utils/#coola.utils.path","title":"coola.utils.path","text":"<p>Contain path utility functions.</p>"},{"location":"refs/utils/#coola.utils.path.sanitize_path","title":"coola.utils.path.sanitize_path","text":"<pre><code>sanitize_path(path: Path | str) -&gt; Path\n</code></pre> <p>Sanitize the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to sanitize. The path can be a string or a <code>pathlib.Path</code> object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The sanitized path as a <code>pathlib.Path</code> object.</p> Example <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from coola.utils.path import sanitize_path\n&gt;&gt;&gt; sanitize_path(\"something\")\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(\"\")\nPosixPath('...')\n&gt;&gt;&gt; sanitize_path(Path(\"something\"))\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(Path(\"something/./../\"))\nPosixPath('...')\n</code></pre>"},{"location":"refs/utils/#coola.utils.path.working_directory","title":"coola.utils.path.working_directory","text":"<pre><code>working_directory(path: Path) -&gt; Generator[None]\n</code></pre> <p>Context manager to change the working directory to the given path, and then changes it back to its previous value on exit.</p> <p>source: https://gist.github.com/nottrobin/3d675653244f8814838a</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the temporary working directory.</p> required Example <pre><code>&gt;&gt;&gt; from coola.utils.path import working_directory\n&gt;&gt;&gt; with working_directory(Path(\"src\")):\n...     x = 1\n...\n</code></pre>"},{"location":"refs/utils/#coola.utils.stats","title":"coola.utils.stats","text":"<p>Implement some utility functions to compute statistics.</p>"},{"location":"refs/utils/#coola.utils.stats.quantile","title":"coola.utils.stats.quantile","text":"<pre><code>quantile(\n    values: Sequence[float | int],\n    quantiles: Sequence[float],\n) -&gt; list[float]\n</code></pre> <p>Compute the quantiles with the linear method.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[float | int]</code> <p>The values.</p> required <code>quantiles</code> <code>Sequence[float]</code> <p>The quantile values in the range <code>[0, 1]</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The quantiles.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.stats import quantile\n&gt;&gt;&gt; quantile([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (0.2, 0.5, 0.9))\n[2.0, 5.0, 9.0]\n</code></pre>"},{"location":"refs/utils/#coola.utils.tensor","title":"coola.utils.tensor","text":"<p>Implement some utility functions for <code>torch.Tensor</code>s.</p>"},{"location":"refs/utils/#coola.utils.tensor.get_available_devices","title":"coola.utils.tensor.get_available_devices  <code>cached</code>","text":"<pre><code>get_available_devices() -&gt; tuple[str, ...]\n</code></pre> <p>Get the available PyTorch devices on the machine.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The available devices.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.tensor import get_available_devices\n&gt;&gt;&gt; get_available_devices()\n('cpu'...)\n</code></pre>"},{"location":"refs/utils/#coola.utils.tensor.is_cuda_available","title":"coola.utils.tensor.is_cuda_available  <code>cached</code>","text":"<pre><code>is_cuda_available() -&gt; bool\n</code></pre> <p>Indicate if CUDA is currently available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if CUDA is currently available.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.tensor import is_cuda_available\n&gt;&gt;&gt; is_cuda_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.tensor.is_mps_available","title":"coola.utils.tensor.is_mps_available  <code>cached</code>","text":"<pre><code>is_mps_available() -&gt; bool\n</code></pre> <p>Indicate if MPS is currently available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if MPS is currently available.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.tensor import is_mps_available\n&gt;&gt;&gt; is_mps_available()\n</code></pre>"},{"location":"refs/utils/#coola.utils.tensor.to_tensor","title":"coola.utils.tensor.to_tensor","text":"<pre><code>to_tensor(\n    data: Sequence[int | float] | Tensor | ndarray,\n) -&gt; Tensor\n</code></pre> <p>Convert the input to a <code>torch.Tensor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[int | float] | Tensor | ndarray</code> <p>The data to convert to a tensor.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.tensor import to_tensor\n&gt;&gt;&gt; x = to_tensor([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x\ntensor([1, 2, 3, 4, 5])\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; x = to_tensor(np.array([1, 2, 3, 4, 5]))\n&gt;&gt;&gt; x\ntensor([1, 2, 3, 4, 5])\n</code></pre>"},{"location":"refs/utils/#coola.utils.version","title":"coola.utils.version","text":"<p>Contain functions to manage package versions.</p>"},{"location":"refs/utils/#coola.utils.version.compare_version","title":"coola.utils.version.compare_version","text":"<pre><code>compare_version(\n    package: str, op: Callable, version: str\n) -&gt; bool\n</code></pre> <p>Compare a package version to a given version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package to check.</p> required <code>op</code> <code>Callable</code> <p>The comparison operator.</p> required <code>version</code> <code>str</code> <p>The version to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The comparison status.</p> Example <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from coola.utils.version import compare_version\n&gt;&gt;&gt; compare_version(\"pytest\", op=operator.ge, version=\"7.3.0\")\nTrue\n</code></pre>"},{"location":"refs/utils/#coola.utils.version.get_package_version","title":"coola.utils.version.get_package_version  <code>cached</code>","text":"<pre><code>get_package_version(package: str) -&gt; Version | None\n</code></pre> <p>Get the package version.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The package name.</p> required <p>Returns:</p> Type Description <code>Version | None</code> <p>The package version.</p> Example <pre><code>&gt;&gt;&gt; from coola.utils.version import get_package_version\n&gt;&gt;&gt; get_package_version(\"pytest\")\n&lt;Version('...')&gt;\n</code></pre>"},{"location":"uguide/customization/","title":"Customization","text":"<p>Both <code>objects_are_equal</code> and <code>objects_are_allclose</code> functions can be easily customized.</p>"},{"location":"uguide/customization/#how-to-implement-a-custom-baseequalitytester","title":"How to implement a custom <code>BaseEqualityTester</code>","text":"<p>Internally, the <code>objects_are_equal</code> function uses a <code>BaseEqualityTester</code> object to check if two objects are equal. <code>coola</code> comes with a default <code>BaseEqualityTester</code> named <code>EqualityTester</code>, but it is possible to implement a custom <code>BaseEqualityTester</code> to check if two objects are equal. The following example shows how to use a custom <code>BaseEqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; from coola.equality import EqualityConfig\n&gt;&gt;&gt; from coola.equality.testers import BaseEqualityTester\n&gt;&gt;&gt; class MyCustomEqualityTester(BaseEqualityTester):\n...     def equal(self, actual: Any, expected: Any, config: EqualityConfig) -&gt; bool:\n...         return actual is expected\n...\n&gt;&gt;&gt; objects_are_equal([1, 2, 3], (1, 2, 3), tester=MyCustomEqualityTester())\nFalse\n</code></pre> <p>Implementing a new <code>BaseEqualityTester</code> allows to customize the behavior of <code>objects_are_equal</code>.</p>"},{"location":"uguide/customization/#how-to-customize-equalitytester","title":"How to customize <code>EqualityTester</code>","text":"<p>Implementing a new <code>BaseEqualityTester</code> can be a lot of work, so it is not always a practical solution. For example if you want to support a new type, you do not want to reimplement everything. Instead of implementing a new <code>BaseEqualityTester</code>, it is possible to customize the default <code>EqualityTester</code>.</p>"},{"location":"uguide/customization/#overview","title":"Overview","text":"<p><code>EqualityTester</code> has a registry of equality comparators with their associated types. An equality comparator is an object that follows the <code>BaseEqualityComparator</code> interface. <code>EqualityTester</code> uses the Method Resolution Order (MRO) of the first object to find the equality comparator to use. It uses the most specific equality comparator. For example, <code>EqualityTester</code> has an equality comparator registered for <code>object</code> and another one <code>list</code>. If the first element to compare is a <code>list</code>, <code>EqualityTester</code> will use the equality comparator associated to <code>list</code> to compare the two objects. You can use the following code to see the registered equality comparators with their associated types.</p> <pre><code>&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; EqualityTester.registry\n{&lt;class 'object'&gt;: DefaultEqualityComparator(),\n &lt;class 'collections.abc.Mapping'&gt;: MappingEqualityComparator(),\n &lt;class 'collections.abc.Sequence'&gt;: SequenceEqualityComparator(),\n &lt;class 'collections.deque'&gt;: SequenceEqualityComparator(),\n &lt;class 'dict'&gt;: MappingEqualityComparator(),\n &lt;class 'list'&gt;: SequenceEqualityComparator(),\n &lt;class 'tuple'&gt;: SequenceEqualityComparator(),\n ...}\n</code></pre> <p>An equality comparator (<code>DefaultEqualityOperator</code>) is registered for <code>object</code> type, so this equality comparator is considered like the default equality comparator. For example, it will be used to compare <code>int</code> or <code>float</code> or <code>str</code> because there is no specific equality comparator for these types. Note that the same equality comparator can be used for multiple types. For example, by default, the same equality comparator is used for <code>list</code>, <code>tuple</code>, and <code>collections.abc.Sequence</code>. The following sections explain how to customize this registry.</p>"},{"location":"uguide/customization/#add-an-equality-comparator","title":"Add an equality comparator","text":"<p>It is possible to add a new equality comparator to the <code>EqualityTester</code>. The following example shows how to define a new behavior for strings. Instead of checking if two strings are the same (default behavior), the new behavior is that two strings are equal if the first string is a part of the second string. It is a two-steps process to add a new equality comparator to <code>EqualityTester</code>. First, you need to implement a new <code>BaseEqualityComparator</code> with the expected behavior for the specific type (<code>str</code> for this example). Then, you need to add the <code>BaseEqualityComparator</code> to <code>EqualityTester</code>.</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; from coola.equality.comparators import BaseEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import BaseEqualityTester, EqualityTester\n&gt;&gt;&gt; # Step 1: implementation of a new equality comparator\n&gt;&gt;&gt; class MyCustomStrEqualityOperator(BaseEqualityComparator):\n...     def clone(self) -&gt; \"MyCustomStrEqualityOperator\":\n...         return self.__class__()\n...     def equal(self, actual: str, expected: Any, config: EqualityConfig) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return actual in expected\n...\n&gt;&gt;&gt; # Step 2: add the new equality comparator to EqualityTester\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(str, MyCustomStrEqualityOperator())\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcde\", tester=tester)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"cba\", tester=tester)\nFalse\n&gt;&gt;&gt; tester.registry[str]\nMyCustomStrEqualityOperator()\n</code></pre> <p>Once registered, the new equality comparator is used automatically when you use the <code>objects_are_equal</code> function. You can use the <code>registry</code> attribute to check the registered equality comparators. You should see the new added equality comparator (last line for this example).</p>"},{"location":"uguide/customization/#update-the-equality-comparator-for-a-given-type","title":"Update the equality comparator for a given type","text":"<p>The previous section explains how to add a new equality comparator to <code>EqualityTester</code>. This section explains how to update the equality comparator for a specific type. To update an equality comparator for a given type, you need to add the argument <code>exist_ok=True</code> when the new equality comparator is added.</p> <pre><code>&gt;&gt;&gt; from collections.abc import Mapping\n&gt;&gt;&gt; from coola.equality.comparators import BaseEqualityComparator\n&gt;&gt;&gt; from coola.equality.testers import EqualityTester\n&gt;&gt;&gt; class MyCustomMappingEqualityComparator(BaseEqualityComparator):\n...     def clone(self) -&gt; \"MyCustomMappingEqualityComparator\":\n...         return self.__class__()\n...     def equal(self, actual: Mapping, expected: Any, config: EqualityConfig) -&gt; bool:\n...         # You can add code to check the type and to log a message to indicate\n...         # the difference between the objects if any. To keep this example\n...         # simple, this part is skipped.\n...         return actual is expected\n...\n&gt;&gt;&gt; tester = EqualityTester.local_copy()\n&gt;&gt;&gt; tester.add_comparator(\n...     Mapping,\n...     MyCustomMappingEqualityComparator(),\n...     exist_ok=True,\n... )\n&gt;&gt;&gt; tester.registry[Mapping]\nMyCustomMappingEqualityComparator()\n</code></pre>"},{"location":"uguide/examples/","title":"Code Examples","text":"<p>This page provides practical examples of using <code>coola</code> in real-world scenarios.</p>"},{"location":"uguide/examples/#basic-examples","title":"Basic Examples","text":""},{"location":"uguide/examples/#comparing-configuration-dictionaries","title":"Comparing Configuration Dictionaries","text":"<pre><code>import yaml\nfrom coola import objects_are_equal\n\n# Load configuration files\nwith open(\"config1.yaml\") as f:\n    config1 = yaml.safe_load(f)\n\nwith open(\"config2.yaml\") as f:\n    config2 = yaml.safe_load(f)\n\n# Compare configurations\nif objects_are_equal(config1, config2, show_difference=True):\n    print(\"Configurations are identical\")\nelse:\n    print(\"Configurations differ\")\n</code></pre>"},{"location":"uguide/examples/#validating-model-outputs","title":"Validating Model Outputs","text":"<pre><code>import torch\nfrom coola import objects_are_allclose\n\n\ndef test_model_inference():\n    model = load_model()\n    test_input = torch.randn(1, 3, 224, 224)\n\n    # Get actual output\n    actual_output = model(test_input)\n\n    # Load expected output\n    expected_output = torch.load(\"expected_output.pt\")\n\n    # Compare with tolerance\n    assert objects_are_allclose(\n        actual_output, expected_output, atol=1e-5, rtol=1e-4, show_difference=True\n    ), \"Model output differs from expected\"\n</code></pre>"},{"location":"uguide/examples/#machine-learning-examples","title":"Machine Learning Examples","text":""},{"location":"uguide/examples/#comparing-training-checkpoints","title":"Comparing Training Checkpoints","text":"<pre><code>import torch\nfrom coola import objects_are_equal\n\n\ndef compare_checkpoints(checkpoint1_path, checkpoint2_path):\n    \"\"\"Compare two PyTorch checkpoint files.\"\"\"\n    checkpoint1 = torch.load(checkpoint1_path)\n    checkpoint2 = torch.load(checkpoint2_path)\n\n    # Compare model state dicts\n    if not objects_are_equal(\n        checkpoint1[\"model_state_dict\"], checkpoint2[\"model_state_dict\"]\n    ):\n        print(\"Model state dicts differ\")\n        return False\n\n    # Compare optimizer state dicts\n    if not objects_are_equal(\n        checkpoint1[\"optimizer_state_dict\"], checkpoint2[\"optimizer_state_dict\"]\n    ):\n        print(\"Optimizer state dicts differ\")\n        return False\n\n    # Compare other metadata\n    metadata_keys = [\"epoch\", \"loss\", \"accuracy\"]\n    for key in metadata_keys:\n        if key in checkpoint1 and key in checkpoint2:\n            if checkpoint1[key] != checkpoint2[key]:\n                print(f\"Metadata '{key}' differs\")\n                return False\n\n    return True\n</code></pre>"},{"location":"uguide/examples/#validating-data-preprocessing","title":"Validating Data Preprocessing","text":"<pre><code>import numpy as np\nfrom coola import objects_are_allclose\n\n\ndef test_preprocessing_pipeline():\n    \"\"\"Test that preprocessing is deterministic.\"\"\"\n    # Sample data\n    raw_data = load_raw_data()\n\n    # Process twice\n    processed_1 = preprocessing_pipeline(raw_data, seed=42)\n    processed_2 = preprocessing_pipeline(raw_data, seed=42)\n\n    # Should be identical when using same seed\n    assert objects_are_allclose(\n        processed_1, processed_2, equal_nan=True\n    ), \"Preprocessing is not deterministic\"\n</code></pre>"},{"location":"uguide/examples/#comparing-model-predictions","title":"Comparing Model Predictions","text":"<pre><code>import torch\nfrom coola import objects_are_allclose\n\n\ndef compare_model_versions(model_v1, model_v2, test_data):\n    \"\"\"Compare predictions from two model versions.\"\"\"\n    model_v1.eval()\n    model_v2.eval()\n\n    differences = []\n\n    with torch.no_grad():\n        for batch_idx, (inputs, targets) in enumerate(test_data):\n            pred_v1 = model_v1(inputs)\n            pred_v2 = model_v2(inputs)\n\n            # Check if predictions are close\n            if not objects_are_allclose(pred_v1, pred_v2, atol=1e-4):\n                differences.append(\n                    {\n                        \"batch_idx\": batch_idx,\n                        \"max_diff\": (pred_v1 - pred_v2).abs().max().item(),\n                    }\n                )\n\n    return differences\n</code></pre>"},{"location":"uguide/examples/#data-science-examples","title":"Data Science Examples","text":""},{"location":"uguide/examples/#comparing-dataframes","title":"Comparing DataFrames","text":"<pre><code>import pandas as pd\nfrom coola import objects_are_equal\n\n\ndef compare_dataframes(df1, df2, ignore_index=False):\n    \"\"\"Compare two pandas DataFrames.\"\"\"\n    if ignore_index:\n        df1 = df1.reset_index(drop=True)\n        df2 = df2.reset_index(drop=True)\n\n    return objects_are_equal(df1, df2, show_difference=True)\n\n\n# Example usage\ndf1 = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\ndf2 = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\nif compare_dataframes(df1, df2):\n    print(\"DataFrames are equal\")\n</code></pre>"},{"location":"uguide/examples/#validating-data-transformations","title":"Validating Data Transformations","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom coola import objects_are_allclose\n\n\ndef test_data_transformation():\n    \"\"\"Test that data transformation preserves statistical properties.\"\"\"\n    original = pd.DataFrame({\"values\": np.random.randn(1000)})\n\n    # Transform data\n    transformed = transform_data(original)\n\n    # Transform back\n    restored = inverse_transform_data(transformed)\n\n    # Check if original and restored are close\n    assert objects_are_allclose(\n        original.values, restored.values, atol=1e-6, rtol=1e-5\n    ), \"Transformation is not reversible\"\n</code></pre>"},{"location":"uguide/examples/#comparing-time-series-data","title":"Comparing Time Series Data","text":"<pre><code>import pandas as pd\nimport numpy as np\nfrom coola import objects_are_allclose\n\n\ndef compare_time_series(series1, series2, tolerance=1e-6):\n    \"\"\"Compare two time series with tolerance for floating-point errors.\"\"\"\n    # Ensure same index\n    if not series1.index.equals(series2.index):\n        print(\"Time series have different indices\")\n        return False\n\n    # Compare values with tolerance\n    return objects_are_allclose(\n        series1.values,\n        series2.values,\n        atol=tolerance,\n        equal_nan=True,  # Treat NaN as equal\n    )\n</code></pre>"},{"location":"uguide/examples/#testing-examples","title":"Testing Examples","text":""},{"location":"uguide/examples/#pytest-integration","title":"pytest Integration","text":"<pre><code>import pytest\nimport torch\nfrom coola import objects_are_equal, objects_are_allclose\n\n\n@pytest.fixture\ndef sample_tensor():\n    return torch.randn(10, 10)\n\n\ndef test_tensor_transformation(sample_tensor):\n    \"\"\"Test that transformation produces expected output.\"\"\"\n    result = my_transformation(sample_tensor)\n    expected = load_expected_result(\"transformation_output.pt\")\n\n    assert objects_are_allclose(result, expected, atol=1e-6, show_difference=True)\n\n\ndef test_data_equality(sample_tensor):\n    \"\"\"Test data equality with coola.\"\"\"\n    processed = process_data(sample_tensor)\n\n    # Load expected structure\n    expected = {\n        \"data\": torch.zeros(10, 10),\n        \"metadata\": {\"shape\": (10, 10), \"dtype\": \"float32\"},\n    }\n\n    assert objects_are_equal(processed, expected, show_difference=True)\n</code></pre>"},{"location":"uguide/examples/#unittest-integration","title":"Unittest Integration","text":"<pre><code>import unittest\nimport numpy as np\nfrom coola import objects_are_equal, objects_are_allclose\n\n\nclass TestDataProcessing(unittest.TestCase):\n    def setUp(self):\n        self.test_data = np.random.randn(100, 100)\n\n    def test_data_normalization(self):\n        \"\"\"Test data normalization.\"\"\"\n        normalized = normalize_data(self.test_data)\n\n        # Check that mean is close to 0 and std is close to 1\n        self.assertTrue(objects_are_allclose(normalized.mean(), 0.0, atol=1e-6))\n        self.assertTrue(objects_are_allclose(normalized.std(), 1.0, atol=1e-6))\n\n    def test_data_structure(self):\n        \"\"\"Test that data structure matches expected.\"\"\"\n        result = create_data_structure(self.test_data)\n        expected = {\n            \"data\": self.test_data,\n            \"mean\": self.test_data.mean(),\n            \"std\": self.test_data.std(),\n        }\n\n        self.assertTrue(objects_are_equal(result, expected, show_difference=True))\n</code></pre>"},{"location":"uguide/examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"uguide/examples/#custom-comparator-for-custom-classes","title":"Custom Comparator for Custom Classes","text":"<pre><code>from typing import Any\nfrom coola import objects_are_equal\nfrom coola.equality import EqualityConfig\nfrom coola.equality.comparators import BaseEqualityComparator\nfrom coola.equality.testers import EqualityTester\n\n\nclass Vector3D:\n    \"\"\"A simple 3D vector class.\"\"\"\n\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n\nclass Vector3DComparator(BaseEqualityComparator):\n    \"\"\"Custom comparator for Vector3D objects.\"\"\"\n\n    def clone(self):\n        return self.__class__()\n\n    def equal(self, actual: Vector3D, expected: Any, config: EqualityConfig) -&gt; bool:\n        if not isinstance(expected, Vector3D):\n            if config.show_difference:\n                print(f\"Types differ: {type(actual)} vs {type(expected)}\")\n            return False\n\n        # Compare components\n        equal = (\n            actual.x == expected.x and actual.y == expected.y and actual.z == expected.z\n        )\n\n        if not equal and config.show_difference:\n            print(\n                f\"Vectors differ: ({actual.x}, {actual.y}, {actual.z}) \"\n                f\"vs ({expected.x}, {expected.y}, {expected.z})\"\n            )\n\n        return equal\n\n\n# Register the comparator\ntester = EqualityTester.local_copy()\ntester.add_comparator(Vector3D, Vector3DComparator())\n\n# Use it\nv1 = Vector3D(1, 2, 3)\nv2 = Vector3D(1, 2, 3)\nv3 = Vector3D(1, 2, 4)\n\nprint(objects_are_equal(v1, v2, tester=tester))  # True\nprint(objects_are_equal(v1, v3, tester=tester, show_difference=True))  # False\n</code></pre>"},{"location":"uguide/examples/#comparing-nested-complex-structures","title":"Comparing Nested Complex Structures","text":"<pre><code>import torch\nimport numpy as np\nimport pandas as pd\nfrom coola import objects_are_equal\n\n\ndef compare_ml_experiment_results(result1, result2):\n    \"\"\"Compare complete ML experiment results.\"\"\"\n\n    experiment1 = {\n        \"config\": {\n            \"learning_rate\": 0.001,\n            \"batch_size\": 32,\n            \"epochs\": 100,\n            \"optimizer\": \"adam\",\n        },\n        \"metrics\": {\n            \"train\": pd.DataFrame(\n                {\"loss\": [0.5, 0.4, 0.3], \"accuracy\": [0.8, 0.85, 0.9]}\n            ),\n            \"val\": pd.DataFrame(\n                {\"loss\": [0.6, 0.5, 0.4], \"accuracy\": [0.75, 0.8, 0.85]}\n            ),\n        },\n        \"model_weights\": {\n            \"layer1\": torch.randn(100, 50),\n            \"layer2\": torch.randn(50, 10),\n        },\n        \"predictions\": {\n            \"test\": np.random.rand(100, 10),\n            \"metadata\": {\"num_samples\": 100, \"num_classes\": 10},\n        },\n    }\n\n    experiment2 = {\n        # Similar structure\n        \"config\": experiment1[\"config\"].copy(),\n        \"metrics\": {\n            \"train\": experiment1[\"metrics\"][\"train\"].copy(),\n            \"val\": experiment1[\"metrics\"][\"val\"].copy(),\n        },\n        \"model_weights\": {\n            \"layer1\": experiment1[\"model_weights\"][\"layer1\"].clone(),\n            \"layer2\": experiment1[\"model_weights\"][\"layer2\"].clone(),\n        },\n        \"predictions\": {\n            \"test\": experiment1[\"predictions\"][\"test\"].copy(),\n            \"metadata\": experiment1[\"predictions\"][\"metadata\"].copy(),\n        },\n    }\n\n    return objects_are_equal(experiment1, experiment2, show_difference=True)\n</code></pre>"},{"location":"uguide/examples/#conditional-comparison-based-on-type","title":"Conditional Comparison Based on Type","text":"<pre><code>import torch\nimport numpy as np\nfrom coola import objects_are_equal, objects_are_allclose\n\n\ndef smart_compare(obj1, obj2, numeric_tolerance=1e-6):\n    \"\"\"Smart comparison that uses appropriate method based on type.\"\"\"\n\n    # For numeric types, use allclose\n    if isinstance(obj1, (torch.Tensor, np.ndarray)):\n        return objects_are_allclose(\n            obj1, obj2, atol=numeric_tolerance, rtol=numeric_tolerance\n        )\n\n    # For dictionaries, check each value\n    if isinstance(obj1, dict) and isinstance(obj2, dict):\n        if obj1.keys() != obj2.keys():\n            return False\n\n        return all(\n            smart_compare(obj1[k], obj2[k], numeric_tolerance) for k in obj1.keys()\n        )\n\n    # For lists/tuples, check each element\n    if isinstance(obj1, (list, tuple)) and isinstance(obj2, (list, tuple)):\n        if len(obj1) != len(obj2):\n            return False\n\n        return all(smart_compare(a, b, numeric_tolerance) for a, b in zip(obj1, obj2))\n\n    # For other types, use exact equality\n    return objects_are_equal(obj1, obj2)\n</code></pre>"},{"location":"uguide/examples/#integration-examples","title":"Integration Examples","text":""},{"location":"uguide/examples/#with-logging","title":"With Logging","text":"<pre><code>import logging\nfrom coola import objects_are_equal\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\n\ndef compare_with_logging(obj1, obj2, context=\"\"):\n    \"\"\"Compare objects with detailed logging.\"\"\"\n    logger = logging.getLogger(__name__)\n\n    logger.info(f\"Starting comparison{f' for {context}' if context else ''}\")\n\n    result = objects_are_equal(obj1, obj2, show_difference=True)\n\n    if result:\n        logger.info(f\"Objects are equal{f' ({context})' if context else ''}\")\n    else:\n        logger.warning(f\"Objects differ{f' ({context})' if context else ''}\")\n\n    return result\n</code></pre>"},{"location":"uguide/examples/#with-context-managers","title":"With Context Managers","text":"<pre><code>import time\nfrom contextlib import contextmanager\nfrom coola import objects_are_equal\n\n\n@contextmanager\ndef timed_comparison(description=\"\"):\n    \"\"\"Time the comparison operation.\"\"\"\n    start = time.time()\n    print(f\"Starting comparison{f': {description}' if description else ''}...\")\n    try:\n        yield\n    finally:\n        elapsed = time.time() - start\n        print(f\"Comparison completed in {elapsed:.4f} seconds\")\n\n\n# Usage\nwith timed_comparison(\"model checkpoints\"):\n    result = objects_are_equal(checkpoint1, checkpoint2, show_difference=True)\n</code></pre>"},{"location":"uguide/examples/#best-practices","title":"Best Practices","text":""},{"location":"uguide/examples/#2-use-appropriate-tolerance-for-numerical-data","title":"2. Use Appropriate Tolerance for Numerical Data","text":"<pre><code>from coola import objects_are_allclose\n\n# For single-precision floats\nobjects_are_allclose(float32_data1, float32_data2, atol=1e-6, rtol=1e-5)\n\n# For double-precision floats\nobjects_are_allclose(float64_data1, float64_data2, atol=1e-12, rtol=1e-10)\n</code></pre>"},{"location":"uguide/examples/#3-handle-nan-values-explicitly","title":"3. Handle NaN Values Explicitly","text":"<pre><code>from coola import objects_are_allclose\n\n# Explicitly decide how to handle NaN\nresult = objects_are_allclose(\n    data1,\n    data2,\n    equal_nan=True,  # or False, depending on requirements\n    show_difference=True,\n)\n</code></pre>"},{"location":"uguide/examples/#4-compare-metadata-before-large-data","title":"4. Compare Metadata Before Large Data","text":"<pre><code>from coola import objects_are_equal\n\n\ndef efficient_compare(obj1, obj2):\n    # Quick checks first\n    if obj1.metadata != obj2.metadata:\n        return False\n\n    # Expensive comparison last\n    return objects_are_equal(obj1.data, obj2.data)\n</code></pre>"},{"location":"uguide/examples/#see-also","title":"See Also","text":"<ul> <li>Quickstart Guide - Basic usage examples</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"uguide/iterator/","title":"Iterating Over Nested Data","text":"<p> This page describes the <code>coola.iterator</code> package, which provides utilities for iterating over nested data structures using different traversal strategies.</p> <p>Prerequisites: You'll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"uguide/iterator/#overview","title":"Overview","text":"<p>The <code>coola.iterator</code> package provides functions to iterate over nested data structures (lists, dicts, tuples, sets, etc.) using two different traversal strategies:</p> <ul> <li>Depth-First Search (DFS): Traverses nested structures by going deep into each branch before   moving to the next</li> <li>Breadth-First Search (BFS): Traverses nested structures level by level</li> </ul> <p>The package also provides filtering utilities to extract only specific types from heterogeneous collections.</p>"},{"location":"uguide/iterator/#depth-first-search-dfs-iteration","title":"Depth-First Search (DFS) Iteration","text":""},{"location":"uguide/iterator/#basic-usage","title":"Basic Usage","text":"<p>The <code>dfs_iterate</code> function performs depth-first traversal of nested data structures:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; list(dfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(dfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre> <p>The function yields only the leaf values (atomic values that are not containers), excluding the containers themselves even if they're empty.</p>"},{"location":"uguide/iterator/#dfs-traversal-examples","title":"DFS Traversal Examples","text":"<p>Simple nested lists:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; list(dfs_iterate([1, 2, [3, 4, [5, 6]]]))\n[1, 2, 3, 4, 5, 6]\n</code></pre> <p>Nested dictionaries:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; data = {\"level1\": {\"level2\": {\"level3\": 42}}}\n&gt;&gt;&gt; list(dfs_iterate(data))\n[42]\n</code></pre> <p>Mixed structures:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; data = {\n...     \"list\": [1, 2, 3],\n...     \"dict\": {\"a\": 4, \"b\": 5},\n...     \"set\": {6, 7},\n...     \"value\": 8,\n... }\n&gt;&gt;&gt; sorted(dfs_iterate(data))  # sorted for consistent output\n[1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre> <p>Sets and tuples:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; list(dfs_iterate((1, (2, 3))))\n[1, 2, 3]\n&gt;&gt;&gt; list(dfs_iterate((1, (2, (3, 4)))))\n[1, 2, 3, 4]\n</code></pre>"},{"location":"uguide/iterator/#understanding-dfs-order","title":"Understanding DFS Order","text":"<p>Depth-first search goes deep into each branch before moving to the next branch:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; data = {\n...     \"branch1\": [1, [2, 3]],\n...     \"branch2\": [4, [5, 6]],\n... }\n&gt;&gt;&gt; # DFS will fully explore branch1 before moving to branch2\n&gt;&gt;&gt; list(dfs_iterate(data))  # Note: dict order may vary in Python &lt; 3.7\n[1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"uguide/iterator/#breadth-first-search-bfs-iteration","title":"Breadth-First Search (BFS) Iteration","text":""},{"location":"uguide/iterator/#basic-usage_1","title":"Basic Usage","text":"<p>The <code>bfs_iterate</code> function performs breadth-first traversal of nested data structures:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate\n&gt;&gt;&gt; list(bfs_iterate({\"a\": 1, \"b\": \"abc\"}))\n[1, 'abc']\n&gt;&gt;&gt; list(bfs_iterate([1, [2, 3], {\"x\": 4}]))\n[1, 2, 3, 4]\n</code></pre> <p>Like <code>dfs_iterate</code>, it yields only the leaf values, excluding containers.</p>"},{"location":"uguide/iterator/#bfs-traversal-examples","title":"BFS Traversal Examples","text":"<p>Nested lists:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate\n&gt;&gt;&gt; list(bfs_iterate([1, [2, [3, [4]]]]))\n[1, 2, 3, 4]\n</code></pre> <p>Multi-level structure:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate\n&gt;&gt;&gt; data = {\n...     \"level1_a\": 1,\n...     \"level1_b\": {\"level2_a\": 2, \"level2_b\": {\"level3\": 3}},\n... }\n&gt;&gt;&gt; # BFS processes level by level: 1 at level 1, then 2 at level 2, then 3 at level 3\n&gt;&gt;&gt; list(bfs_iterate(data))\n[1, 2, 3]\n</code></pre>"},{"location":"uguide/iterator/#bfs-vs-dfs","title":"BFS vs DFS","text":"<p>The main difference between BFS and DFS is the order of traversal:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate, dfs_iterate\n&gt;&gt;&gt; data = [[1, 2], [3, 4]]\n&gt;&gt;&gt; list(dfs_iterate(data))  # DFS: depth-first\n[1, 2, 3, 4]\n&gt;&gt;&gt; list(bfs_iterate(data))  # BFS: breadth-first\n[1, 2, 3, 4]\n</code></pre> <p>For this simple example, the results are the same, but for more complex nested structures, the traversal order can differ significantly. BFS processes all items at each level before moving deeper, while DFS goes as deep as possible before backtracking.</p>"},{"location":"uguide/iterator/#type-based-filtering","title":"Type-Based Filtering","text":""},{"location":"uguide/iterator/#basic-filtering","title":"Basic Filtering","text":"<p>The <code>filter_by_type</code> function filters an iterator to yield only values of specified types:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import filter_by_type\n&gt;&gt;&gt; list(filter_by_type([1, \"hello\", 2, 3.14, \"world\", 4], int))\n[1, 2, 4]\n</code></pre>"},{"location":"uguide/iterator/#filtering-multiple-types","title":"Filtering Multiple Types","text":"<p>You can filter for multiple types using a tuple:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import filter_by_type\n&gt;&gt;&gt; # Note: bool is a subclass of int\n&gt;&gt;&gt; list(filter_by_type([1, \"hello\", 2.5, True, None, [1, 2]], (int, float)))\n[1, 2.5, True]\n</code></pre>"},{"location":"uguide/iterator/#combining-with-iteration","title":"Combining with Iteration","text":"<p>You can combine type filtering with nested iteration:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate, filter_by_type\n&gt;&gt;&gt; data = {\"a\": 1, \"b\": \"hello\", \"c\": [2, \"world\", 3.14]}\n&gt;&gt;&gt; # Get all numeric values (int and float) from nested structure\n&gt;&gt;&gt; list(filter_by_type(dfs_iterate(data), (int, float)))\n[1, 2, 3.14]\n</code></pre> <p>Extract only strings:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate, filter_by_type\n&gt;&gt;&gt; data = [1, \"a\", [2, \"b\", [3, \"c\"]]]\n&gt;&gt;&gt; list(filter_by_type(dfs_iterate(data), str))\n['a', 'b', 'c']\n</code></pre> <p>Extract only integers:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import bfs_iterate, filter_by_type\n&gt;&gt;&gt; data = {\"nums\": [1, 2.5, 3], \"text\": \"hello\", \"value\": 2}\n&gt;&gt;&gt; list(filter_by_type(bfs_iterate(data), int))\n[2, 1, 3]\n</code></pre>"},{"location":"uguide/iterator/#advanced-usage","title":"Advanced Usage","text":""},{"location":"uguide/iterator/#custom-iterators","title":"Custom Iterators","text":"<p>For more control over how specific types are iterated, you can register custom iterators using the registry system.</p> <p>DFS Custom Registry:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import register_iterators, IterableIterator\n&gt;&gt;&gt; # Register custom behavior for specific types\n&gt;&gt;&gt; register_iterators({list: IterableIterator()}, exist_ok=True)\n</code></pre> <p>BFS Custom Registry:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.bfs import register_child_finders, IterableChildFinder\n&gt;&gt;&gt; # Register custom behavior for specific types\n&gt;&gt;&gt; register_child_finders({list: IterableChildFinder()}, exist_ok=True)\n</code></pre>"},{"location":"uguide/iterator/#using-custom-registry","title":"Using Custom Registry","text":"<p>You can create and use a custom registry:</p> <pre><code>&gt;&gt;&gt; from coola.iterator.dfs import IteratorRegistry, dfs_iterate\n&gt;&gt;&gt; from coola.iterator.dfs import DefaultIterator, IterableIterator\n&gt;&gt;&gt; registry = IteratorRegistry()\n&gt;&gt;&gt; registry.register(list, IterableIterator())\n&gt;&gt;&gt; registry.register(object, DefaultIterator())\n&gt;&gt;&gt; list(dfs_iterate([1, 2, 3], registry=registry))\n[1, 2, 3]\n</code></pre>"},{"location":"uguide/iterator/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/iterator/#extracting-all-values","title":"Extracting All Values","text":"<p>Extract all values from a complex configuration:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate\n&gt;&gt;&gt; config = {\n...     \"database\": {\"host\": \"localhost\", \"port\": 5432},\n...     \"cache\": {\"enabled\": True, \"ttl\": 3600},\n... }\n&gt;&gt;&gt; list(dfs_iterate(config))\n['localhost', 5432, True, 3600]\n</code></pre>"},{"location":"uguide/iterator/#counting-values","title":"Counting Values","text":"<p>Count specific types in a nested structure:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate, filter_by_type\n&gt;&gt;&gt; data = {\n...     \"scores\": [95, 87, 92],\n...     \"names\": [\"Alice\", \"Bob\", \"Charlie\"],\n... }\n&gt;&gt;&gt; len(list(filter_by_type(dfs_iterate(data), int)))\n3\n</code></pre>"},{"location":"uguide/iterator/#finding-all-strings","title":"Finding All Strings","text":"<p>Find all string values in a nested structure:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate, filter_by_type\n&gt;&gt;&gt; data = {\n...     \"user\": {\"name\": \"John\", \"age\": 30},\n...     \"posts\": [{\"title\": \"Post 1\", \"views\": 100}, {\"title\": \"Post 2\", \"views\": 200}],\n... }\n&gt;&gt;&gt; list(filter_by_type(dfs_iterate(data), str))\n['John', 'Post 1', 'Post 2']\n</code></pre>"},{"location":"uguide/iterator/#validating-data-types","title":"Validating Data Types","text":"<p>Check if all numeric values in a structure are within a range:</p> <pre><code>&gt;&gt;&gt; from coola.iterator import dfs_iterate, filter_by_type\n&gt;&gt;&gt; data = {\"values\": [10, 20, 30], \"nested\": {\"more\": [40, 50]}}\n&gt;&gt;&gt; numbers = list(filter_by_type(dfs_iterate(data), (int, float)))\n&gt;&gt;&gt; all(0 &lt;= n &lt;= 100 for n in numbers)\nTrue\n</code></pre>"},{"location":"uguide/iterator/#design-principles","title":"Design Principles","text":"<p>The <code>coola.iterator</code> package design provides:</p> <ol> <li>Multiple traversal strategies: Choose between DFS and BFS based on your needs</li> <li>Generator-based: Memory-efficient iteration without loading entire structures</li> <li>Type-aware: Built-in support for common Python types with extensibility</li> <li>Clean API: Simple functions that compose well with other Python tools</li> </ol>"},{"location":"uguide/iterator/#see-also","title":"See Also","text":"<ul> <li><code>coola.recursive</code>: For transforming nested data while preserving structure</li> <li><code>coola.registry</code>: For understanding the registry pattern used internally</li> </ul>"},{"location":"uguide/quickstart/","title":"coola quickstart","text":"<p> This page is a quick overview of the two main functions of <code>coola</code>: <code>objects_are_equal</code> and <code>objects_are_allclose</code>. These functions can be used to check if two complex/nested objects are equal or not. The motivation of the library is explained here. You should read this page if you want to learn how to use these functions. This page does not explain the internal behavior of these functions.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial. It is highly recommended to know a bit of NumPy or PyTorch.</p>"},{"location":"uguide/quickstart/#equal-or-not","title":"Equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_equal</code> that can indicate if two complex/nested objects are equal or not. It also works for simple objects like integer or string.</p>"},{"location":"uguide/quickstart/#first-example","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_equal</code> function. The objects to compare are dictionaries containing a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nTrue\n</code></pre> <p>In one line, it is possible to check two complex/nested objects are equal or not. Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function can check if two dictionaries containing PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>s are equal or not.</p>"},{"location":"uguide/quickstart/#finding-a-difference","title":"Finding a difference","text":"<p>When the objects are complex or nested, it is not obvious to know which elements are different. This function has an argument <code>show_difference</code> which shows the first difference found between the two objects. For example if you add <code>show_difference=True</code> when you compare the <code>data1</code> and <code>data2</code>, you will see at least one element that is different:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; objects_are_equal(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Log output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nactual=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nexpected=\ntensor([[0., 0., 0.],\n        [0., 0., 0.]])\nINFO:coola.comparators.equality:The mappings have a different value for the key 'torch':\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[0., 0., 0.],\n        [0., 0., 0.]]), 'numpy': array([[1., 1., 1.],\n       [1., 1., 1.]])}\n</code></pre> <p>If you do not see this output, you may need to configure <code>logging</code> to show the <code>INFO</code> level (something like <code>logging.basicConfig(level=logging.INFO)</code>). The log shows a difference between <code>data1</code> and <code>data2</code>: the PyTorch <code>Tensor</code>s in key <code>'torch'</code> of the input dictionaries. The top of the log shows the element that fails the check, and then it shows the parent element, so it is easy to know where is the identified difference. Note that it only shows the first difference, not all the differences. Two objects are different if any of these elements are different. In the previous example, only the difference for key <code>'torch'</code> is shown in the log. No log is shown if the two objects are equal and <code>show_difference=True</code>.</p>"},{"location":"uguide/quickstart/#more-examples","title":"More examples","text":"<p>The previous examples use dictionary, but it is possible to use other types like list or tuple</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = [torch.ones(2, 3), numpy.zeros((2, 3))]\n&gt;&gt;&gt; data2 = [torch.zeros(2, 3), numpy.ones((2, 3))]\n&gt;&gt;&gt; data3 = (torch.ones(2, 3), numpy.zeros((2, 3)))\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>It is also possible to test more complex objects</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abcd\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; objects_are_equal(data1, data2)\nFalse\n</code></pre> <p>Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"uguide/quickstart/#strict-type-checking","title":"Strict type checking","text":"<p> Unlike the native python equality operator <code>==</code>, the <code>objects_are_equal</code> function requires two objects to be of the same type to be equal. For example, <code>1</code> (integer) is considered different from <code>1.0</code> (float) or <code>True</code> (boolean) which is different behavior that the native python equality operator <code>==</code>. You can take a look to the following example to see some differences.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, True)\nFalse\n&gt;&gt;&gt; 1 == 1\nTrue\n&gt;&gt;&gt; 1 == 1.0\nTrue\n&gt;&gt;&gt; 1 == True\nTrue\n</code></pre> <p>Similarly, the <code>objects_are_equal</code> function considers a <code>dict</code> and <code>collections.OrderedDict</code> as different objects even if they have the same keys and values.</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"key1\": 1, \"key2\": \"abc\"}, OrderedDict({\"key1\": 1, \"key2\": \"abc\"}))\nFalse\n&gt;&gt;&gt; {\"key1\": 1, \"key2\": \"abc\"} == OrderedDict({\"key1\": 1, \"key2\": \"abc\"})\nTrue\n</code></pre>"},{"location":"uguide/quickstart/#almost-equal-or-not","title":"Almost equal or not?","text":"<p><code>coola</code> provides a function <code>objects_are_allclose</code> that can indicate if two complex/nested objects are equal within a tolerance or not. Due to numerical precision, it happens quite often that two numbers are not equal but the error is very tiny (<code>1.0</code> and <code>1.000000001</code>). The tolerance is mostly useful for numerical values. For a lot of types like string, the <code>objects_are_allclose</code> function behaves like the <code>objects_are_equal</code> function.</p>"},{"location":"uguide/quickstart/#first-example_1","title":"First example","text":"<p>The following example shows how to use the <code>objects_are_allclose</code> function. The objects to compare are dictionaries containing a PyTorch Tensor and a NumPy ndarray.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose, objects_are_equal\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.zeros(2, 3), \"numpy\": numpy.ones((2, 3))}\n&gt;&gt;&gt; data3 = {\"torch\": torch.ones(2, 3) + 1e-9, \"numpy\": numpy.zeros((2, 3)) - 1e-9}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data3)\nTrue\n&gt;&gt;&gt; objects_are_equal(data1, data3)\nFalse\n</code></pre> <p>The difference between <code>data1</code> and <code>data2</code> is large so <code>objects_are_allclose</code> returns false like <code>objects_are_equal</code>. The difference between <code>data1</code> and <code>data3</code> is tiny so <code>objects_are_allclose</code> returns true, whereas <code>objects_are_equal</code> returns false.</p>"},{"location":"uguide/quickstart/#tolerance","title":"Tolerance","text":"<p>It is possible to control the tolerance with the arguments <code>atol</code> and <code>rtol</code>. <code>atol</code> controls the absolute tolerance and <code>rtol</code> controls the relative tolerance.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(data1, data2, atol=1e-3)\nTrue\n</code></pre> <p><code>objects_are_equal</code> and <code>objects_are_allclose</code> are very similar and should behave the same when <code>atol=0.0</code> and <code>rtol=0.0</code>.</p>"},{"location":"uguide/quickstart/#finding-a-difference_1","title":"Finding a difference","text":"<p>Like <code>objects_are_equal</code>, the <code>objects_are_allclose</code> function has an argument <code>show_difference</code> which shows the first difference found between the two objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}\n&gt;&gt;&gt; data2 = {\"torch\": torch.ones(2, 3) + 1e-4, \"numpy\": numpy.zeros((2, 3)) - 1e-4}\n&gt;&gt;&gt; objects_are_allclose(data1, data2, show_difference=True)\nFalse\n</code></pre> <p>Output:</p> <pre><code>INFO:coola.comparators.torch_:torch.Tensors are different\nactual=\ntensor([[1., 1., 1.],\n        [1., 1., 1.]])\nexpected=\ntensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]])\nINFO:coola.comparators.allclose:The mappings have a different value for the key torch:\nfirst mapping  = {'torch': tensor([[1., 1., 1.],\n        [1., 1., 1.]]), 'numpy': array([[0., 0., 0.],\n       [0., 0., 0.]])}\nsecond mapping = {'torch': tensor([[1.0001, 1.0001, 1.0001],\n        [1.0001, 1.0001, 1.0001]]), 'numpy': array([[-0.0001, -0.0001, -0.0001],\n       [-0.0001, -0.0001, -0.0001]])}\n</code></pre>"},{"location":"uguide/quickstart/#more-examples_1","title":"More examples","text":"<p>Like the <code>objects_are_equal</code> function, the <code>objects_are_allclose</code> function can be used with complex/nested objects.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; data1 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3))],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; data2 = {\n...     \"list\": [torch.ones(2, 3), numpy.zeros((2, 3)) + 1e-9],\n...     \"dict\": {\"torch\": torch.arange(5), \"str\": \"abc\"},\n...     \"int\": 1,\n... }\n&gt;&gt;&gt; objects_are_allclose(data1, data2)\nTrue\n</code></pre> <p><code>objects_are_allclose</code> supports a lot of types and nested structure. Feel free to try any complex nested structure that you want. You can find the currently supported types here.</p>"},{"location":"uguide/quickstart/#not-a-number-nan","title":"Not A Number (NaN)","text":"<p>By default, <code>NaN</code> is not considered close to any other value, including <code>NaN</code>.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), 0.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> <p>By setting <code>equal_nan=True</code>, it is possible to change the above behavior and <code>NaN</code>s will be considered equal.</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre> <p>In arrays or tensors, <code>NaN</code> are sometimes to indicate some values are not valid. However, it may be interested to check if the non-<code>NaN</code> values are equal. It is possible to use the <code>equal_nan=True</code> option to compare two tensors with <code>NaN</code> values.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     torch.tensor([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n... )\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     numpy.array([0.0, 1.0, float(\"nan\")]),\n...     equal_nan=True,\n... )\nTrue\n</code></pre> <p>Output:</p> <pre><code>False\nTrue\nFalse\nTrue\n</code></pre>"},{"location":"uguide/quickstart/#connection-with-similar-tools","title":"Connection with similar tools","text":"<p><code>coola</code> is not the first tool to provide functions to compare nested objects. If you are a PyTorch user, you probably know the <code>torch.testing.assert_close</code> function. If you are a NumPy user, you probably know the  <code>numpy.testing.assert_equal</code> function. However, most of these functions work in a fix scope and are difficult to extend or customize. On the opposite side, <code>coola</code> is flexible and easy to customize.</p> <p>Let's take a look to <code>torch</code>. <code>torch.testing.assert_close</code> allows to easily compare <code>torch.Tensor</code>s objects:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(torch.ones(2, 3), torch.ones(2, 3))\n</code></pre> <p>It can also be used on mappings or sequences:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(\n...     [torch.ones(2, 3), torch.zeros(3)],\n...     [torch.ones(2, 3), torch.zeros(3)],\n... )\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3)},\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3)},\n... )\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {\n...         \"key1\": torch.ones(2, 3),\n...         \"key2\": {\"key3\": torch.zeros(3), \"key4\": [torch.arange(5)]},\n...     },\n...     {\n...         \"key1\": torch.ones(2, 3),\n...         \"key2\": {\"key3\": torch.zeros(3), \"key4\": [torch.arange(5)]},\n...     },\n... )\n</code></pre> <p>It also works on tensor like objects like NumPy arrays:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; torch.testing.assert_close(\n...     [torch.ones(2, 3), np.zeros(3)],\n...     [torch.ones(2, 3), np.zeros(3)],\n... )\n&gt;&gt;&gt; torch.testing.assert_close([torch.ones(2, 3), 42], [torch.ones(2, 3), 42])\n</code></pre> <p>However, it does not work if the data structure contains a string:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close(\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3), \"key3\": \"abc\"},\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3), \"key3\": \"abc\"},\n... )\nTraceback (most recent call last):\n...\nTypeError: No comparison pair was able to handle inputs of type &lt;class 'str'&gt; and &lt;class 'str'&gt;.\nThe failure occurred for item ['key3']\n</code></pre> <p><code>coola</code> can compare these objects:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import coola\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3), \"key3\": \"abc\"},\n...     {\"key1\": torch.ones(2, 3), \"key2\": torch.zeros(3), \"key3\": \"abc\"},\n... )\nTrue\n</code></pre> <p>Internally, <code>torch.testing.assert_close</code> tries to convert some values to tensors to compare them, which can lead to surprising results like:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; torch.testing.assert_close((1, 2, 3), [1, 2, 3])\n</code></pre> <p>The inputs have different types: the left input is a tuple, whereas the right is a list. <code>coola</code> has a strict type checking and will indicate the two inputs are different:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; import coola\n&gt;&gt;&gt; coola.objects_are_equal((1, 2, 3), [1, 2, 3])\nFalse\n</code></pre> <p> <code>numpy.testing.assert_equal</code> has different limitations. For example, it can work with strings but can handle only simple sequence and mapping objects</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; np.testing.assert_equal(\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3)},\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3)},\n... )\n&gt;&gt;&gt; np.testing.assert_equal(\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3), \"key3\": \"abc\"},\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3), \"key3\": \"abc\"},\n... )\n&gt;&gt;&gt; np.testing.assert_equal(\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n... )\nTraceback (most recent call last):\n...\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n</code></pre> <p><code>coola</code> can compare these objects:</p> <pre><code>&gt;&gt;&gt; import coola\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3)},\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3)},\n... )\nTrue\n&gt;&gt;&gt; coola.objects_are_equal(\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3), \"key3\": \"abc\"},\n...     {\"key1\": np.ones((2, 3)), \"key2\": np.zeros(3), \"key3\": \"abc\"},\n... )\nTrue\n&gt;&gt;&gt; coola.objects_are_equal(\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n...     deque([np.ones((2, 3)), np.zeros(3)]),\n... )\nTrue\n</code></pre>"},{"location":"uguide/random/","title":"Random Number Generator Management","text":"<p> This page describes the <code>coola.random</code> package, which provides a unified interface for managing random number generator (RNG) state across different libraries.</p> <p>Prerequisites: You'll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"uguide/random/#overview","title":"Overview","text":"<p>The <code>coola.random</code> package provides a unified interface for controlling random number generators (RNGs) from multiple libraries:</p> <ul> <li>Python's built-in <code>random</code> module (always available)</li> <li>NumPy's random module (if NumPy is installed)</li> <li>PyTorch's random module (if PyTorch is installed)</li> </ul> <p>This allows you to set seeds, get and restore RNG states, and manage randomness consistently across different libraries in a single call.</p>"},{"location":"uguide/random/#basic-usage","title":"Basic Usage","text":""},{"location":"uguide/random/#setting-a-random-seed","title":"Setting a Random Seed","text":"<p>Use <code>manual_seed()</code> to set the seed for all available random number generators:</p> <pre><code>&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # Now all RNGs (random, numpy, torch) are seeded with 42\n</code></pre> <p>This sets the seed for:</p> <ul> <li>Python's <code>random</code> module</li> <li>NumPy's random generator (if NumPy is available)</li> <li>PyTorch's random generator (if PyTorch is available)</li> </ul>"},{"location":"uguide/random/#using-a-random-seed-context","title":"Using a Random Seed Context","text":"<p>Use the <code>random_seed</code> context manager to temporarily set a seed and automatically restore the previous RNG state afterward:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n&gt;&gt;&gt; with random_seed(42):\n...     print(numpy.random.randn(2, 4))\n...\n[[...]]\n</code></pre> <p>The context manager ensures that:</p> <ol> <li>The RNG state is saved before setting the seed</li> <li>The specified seed is applied</li> <li>The original RNG state is restored after the context exits</li> </ol> <p>This is useful for reproducible code blocks without affecting the global RNG state.</p>"},{"location":"uguide/random/#getting-and-setting-rng-state","title":"Getting and Setting RNG State","text":"<p>You can manually save and restore the entire RNG state:</p> <pre><code>&gt;&gt;&gt; from coola.random import get_rng_state, set_rng_state\n&gt;&gt;&gt; # Save current state\n&gt;&gt;&gt; state = get_rng_state()\n&gt;&gt;&gt; # ... do some random operations ...\n&gt;&gt;&gt; # Restore previous state\n&gt;&gt;&gt; set_rng_state(state)\n</code></pre> <p>The state is a dictionary containing the state of all registered random managers:</p> <pre><code>&gt;&gt;&gt; from coola.random import get_rng_state\n&gt;&gt;&gt; state = get_rng_state()\n&gt;&gt;&gt; state.keys()\ndict_keys(['random', 'numpy', 'torch'])\n</code></pre>"},{"location":"uguide/random/#library-specific-seeds","title":"Library-Specific Seeds","text":""},{"location":"uguide/random/#pythons-random-module","title":"Python's Random Module","text":"<p>Set the seed only for Python's <code>random</code> module:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from coola.random.random import RandomRandomManager\n&gt;&gt;&gt; manager = RandomRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n&gt;&gt;&gt; val = random.randint(1, 100)\n</code></pre>"},{"location":"uguide/random/#numpy","title":"NumPy","text":"<p>Set the seed only for NumPy's random module:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.random import numpy_seed\n&gt;&gt;&gt; with numpy_seed(42):\n...     np.random.rand(3)\n...\narray([...])\n</code></pre> <p>Or use the NumPy random manager directly:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.random.numpy import NumpyRandomManager\n&gt;&gt;&gt; manager = NumpyRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n&gt;&gt;&gt; np.random.rand(3)\narray([...])\n</code></pre>"},{"location":"uguide/random/#pytorch","title":"PyTorch","text":"<p>Set the seed only for PyTorch's random module:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import torch_seed\n&gt;&gt;&gt; with torch_seed(42):\n...     torch.rand(3)\n...\ntensor([...])\n</code></pre> <p>Or use the PyTorch random manager directly:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random.torch import TorchRandomManager\n&gt;&gt;&gt; manager = TorchRandomManager()\n&gt;&gt;&gt; manager.manual_seed(42)\n&gt;&gt;&gt; torch.rand(3)\ntensor([...])\n</code></pre>"},{"location":"uguide/random/#advanced-usage","title":"Advanced Usage","text":""},{"location":"uguide/random/#working-with-the-registry","title":"Working with the Registry","text":"<p>The default registry manages all available random managers:</p> <pre><code>&gt;&gt;&gt; from coola.random import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry\nRandomManagerRegistry(\n  (state): Registry(\n      (random): RandomRandomManager()\n      (numpy): NumpyRandomManager()\n      (torch): TorchRandomManager()\n    )\n)\n</code></pre>"},{"location":"uguide/random/#registering-custom-managers","title":"Registering Custom Managers","text":"<p>You can register custom random managers to support additional libraries:</p> <pre><code>&gt;&gt;&gt; from coola.random import register_managers, RandomRandomManager\n&gt;&gt;&gt; # Register a custom manager\n&gt;&gt;&gt; register_managers({\"custom\": RandomRandomManager()})  # doctest: +SKIP\n</code></pre> <p>To create a custom manager, extend <code>BaseRandomManager</code>:</p> <pre><code>&gt;&gt;&gt; from coola.random import BaseRandomManager\n&gt;&gt;&gt; class MyRandomManager(BaseRandomManager):\n...     def get_rng_state(self):\n...         # Return current RNG state\n...         return {}\n...     def set_rng_state(self, state):\n...         # Restore RNG state\n...         pass\n...     def manual_seed(self, seed):\n...         # Set seed\n...         pass\n...\n</code></pre>"},{"location":"uguide/random/#using-custom-registry","title":"Using Custom Registry","text":"<p>You can create and use a custom registry:</p> <pre><code>&gt;&gt;&gt; from coola.random import RandomManagerRegistry, RandomRandomManager\n&gt;&gt;&gt; registry = RandomManagerRegistry()\n&gt;&gt;&gt; registry.register(\"random\", RandomRandomManager())\n&gt;&gt;&gt; registry.manual_seed(42)\n</code></pre>"},{"location":"uguide/random/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/random/#reproducible-experiments","title":"Reproducible Experiments","text":"<p>Ensure reproducibility in scientific experiments:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # All random operations are now reproducible\n&gt;&gt;&gt; np.random.rand(3)\narray([...])\n&gt;&gt;&gt; torch.rand(3)\ntensor([...])\n</code></pre>"},{"location":"uguide/random/#reproducible-code-blocks","title":"Reproducible Code Blocks","text":"<p>Make a specific code block reproducible without affecting the global state:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; # Generate some random data\n&gt;&gt;&gt; data1 = np.random.rand(5)\n&gt;&gt;&gt; # This block is reproducible\n&gt;&gt;&gt; with random_seed(123):\n...     reproducible_data = np.random.rand(5)\n...\n&gt;&gt;&gt; # Continue with original RNG state\n&gt;&gt;&gt; data2 = np.random.rand(5)\n</code></pre> <p>Internally, the context manager saves and restores RNG state before and after the block. It is equivalent to this code.</p> <pre><code>&gt;&gt;&gt; from coola.random import get_rng_state, set_rng_state, manual_seed\n&gt;&gt;&gt; # Save initial state\n&gt;&gt;&gt; initial_state = get_rng_state()\n&gt;&gt;&gt; # Run test with specific seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # ... make code reproducible. ...\n&gt;&gt;&gt; # Restore initial state\n&gt;&gt;&gt; set_rng_state(initial_state)\n</code></pre>"},{"location":"uguide/random/#cross-library-seeding","title":"Cross-Library Seeding","text":"<p>Seed all libraries at once for consistent results:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; # Seed all libraries with one call\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # All libraries use the same seed\n&gt;&gt;&gt; val1 = random.random()\n&gt;&gt;&gt; val2 = np.random.rand()\n&gt;&gt;&gt; val3 = torch.rand(1).item()\n</code></pre>"},{"location":"uguide/random/#temporary-seed-changes","title":"Temporary Seed Changes","text":"<p>Temporarily change seed for a specific operation:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; # Normal operations\n&gt;&gt;&gt; normal_data = np.random.rand(3)\n&gt;&gt;&gt; # Use specific seed for initialization\n&gt;&gt;&gt; with random_seed(999):\n...     initialization = np.random.randn(10, 10)\n...\n&gt;&gt;&gt; # Continue with normal operations\n&gt;&gt;&gt; more_data = np.random.rand(3)\n</code></pre>"},{"location":"uguide/random/#available-random-managers","title":"Available Random Managers","text":"<p>The <code>coola.random</code> package provides the following random managers:</p> <ul> <li><code>RandomRandomManager</code>: For Python's built-in <code>random</code> module (always registered)</li> <li><code>NumpyRandomManager</code>: For NumPy's random module (registered if NumPy is available)</li> <li><code>TorchRandomManager</code>: For PyTorch's random module (registered if PyTorch is available)</li> </ul> <p>Each manager implements the <code>BaseRandomManager</code> interface with three methods:</p> <ul> <li><code>manual_seed(seed)</code>: Set the random seed</li> <li><code>get_rng_state()</code>: Get the current RNG state</li> <li><code>set_rng_state(state)</code>: Restore a previous RNG state</li> </ul>"},{"location":"uguide/random/#design-principles","title":"Design Principles","text":"<p>The <code>coola.random</code> package design provides:</p> <ol> <li>Unified interface: Control multiple RNG libraries with a single API</li> <li>Automatic detection: Automatically registers managers for available libraries</li> <li>State management: Save and restore complete RNG state across all libraries</li> <li>Context managers: Temporarily set seeds without affecting global state</li> <li>Extensibility: Easy to add support for new random number generators</li> </ol>"},{"location":"uguide/random/#best-practices","title":"Best Practices","text":""},{"location":"uguide/random/#always-use-context-managers-when-possible","title":"Always Use Context Managers When Possible","text":"<p>Prefer <code>random_seed()</code> context manager over <code>manual_seed()</code> for localized reproducibility:</p> <pre><code>&gt;&gt;&gt; from coola.random import random_seed\n&gt;&gt;&gt; # Good: State is automatically restored\n&gt;&gt;&gt; with random_seed(42):\n...     # reproducible code\n...     pass\n...\n</code></pre> <p>Instead of:</p> <pre><code>&gt;&gt;&gt; from coola.random import manual_seed, get_rng_state, set_rng_state\n&gt;&gt;&gt; # Not ideal: Manual state management\n&gt;&gt;&gt; state = get_rng_state()\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # reproducible code\n&gt;&gt;&gt; set_rng_state(state)\n</code></pre>"},{"location":"uguide/random/#set-seeds-at-the-beginning","title":"Set Seeds at the Beginning","text":"<p>Set seeds at the beginning of your script for full reproducibility:</p> <pre><code>&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; manual_seed(42)\n&gt;&gt;&gt; # Rest of your code...\n</code></pre>"},{"location":"uguide/random/#document-seed-usage","title":"Document Seed Usage","text":"<p>Always document when and why you're setting seeds:</p> <pre><code>&gt;&gt;&gt; from coola.random import manual_seed\n&gt;&gt;&gt; # Set seed for reproducible results in experiments\n&gt;&gt;&gt; manual_seed(42)\n</code></pre>"},{"location":"uguide/random/#see-also","title":"See Also","text":"<ul> <li>Python's <code>random</code> module</li> <li>NumPy's Random sampling</li> <li>PyTorch's Reproducibility</li> <li><code>coola.registry</code>: For understanding the registry pattern used internally</li> </ul>"},{"location":"uguide/recursive/","title":"Recursive Data Transformation","text":"<p> This page describes the <code>coola.recursive</code> package, which provides utilities for recursively applying transformations to nested data structures using a Depth-First Search (DFS) pattern.</p> <p>Prerequisites: You'll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"uguide/recursive/#overview","title":"Overview","text":"<p>The <code>coola.recursive</code> package allows you to apply a function to all leaf values in nested data structures (lists, dicts, tuples, sets, etc.) while preserving the original structure. It provides:</p> <ol> <li>Memory-efficient generator-based traversal</li> <li>Clean separation between transformation logic and type dispatch</li> <li>Easy extensibility via registry pattern</li> <li>Support for custom types</li> </ol>"},{"location":"uguide/recursive/#basic-usage","title":"Basic Usage","text":""},{"location":"uguide/recursive/#transforming-nested-data","title":"Transforming Nested Data","text":"<p>The main function is <code>recursive_apply</code>, which recursively applies a function to all items in nested data:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; recursive_apply({\"a\": 1, \"b\": \"abc\"}, str)\n{'a': '1', 'b': 'abc'}\n&gt;&gt;&gt; recursive_apply([1, [2, 3], {\"x\": 4}], lambda x: x * 2)\n[2, [4, 6], {'x': 8}]\n</code></pre> <p>The function traverses the data structure and applies the transformation function to each leaf value (i.e., non-container values like numbers and strings).</p>"},{"location":"uguide/recursive/#more-examples","title":"More Examples","text":"<p>You can use <code>recursive_apply</code> with different data structures:</p> <p>Nested lists and tuples:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; recursive_apply([1, 2, [3, 4, [5, 6]]], lambda x: x + 10)\n[11, 12, [13, 14, [15, 16]]]\n&gt;&gt;&gt; recursive_apply((1, (2, 3)), str)\n('1', ('2', '3'))\n</code></pre> <p>Nested dictionaries:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; data = {\"level1\": {\"level2\": {\"level3\": 42}}}\n&gt;&gt;&gt; recursive_apply(data, lambda x: x * 2)\n{'level1': {'level2': {'level3': 84}}}\n</code></pre> <pre><code>**Mixed nested structures:**\n\n```pycon\n\n&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; data = {\n...     \"list\": [1, 2, 3],\n...     \"dict\": {\"a\": 4, \"b\": 5},\n...     \"value\": 8,\n... }\n&gt;&gt;&gt; recursive_apply(data, lambda x: x + 100)\n{'list': [101, 102, 103], 'dict': {'a': 104, 'b': 105}, 'value': 108}\n</code></pre>"},{"location":"uguide/recursive/#advanced-usage","title":"Advanced Usage","text":""},{"location":"uguide/recursive/#custom-transformers","title":"Custom Transformers","text":"<p>For more control over how specific types are transformed, you can create custom transformers by extending <code>BaseTransformer</code>:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import BaseTransformer, TransformerRegistry\n&gt;&gt;&gt; class MyType:\n...     def __init__(self, value):\n...         self.value = value\n...     def __repr__(self):\n...         return f\"MyType({self.value})\"\n...\n&gt;&gt;&gt; class MyTransformer(BaseTransformer):\n...     def transform(self, data, func, registry):\n...         return MyType(func(data.value))\n...\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; registry.register(MyType, MyTransformer())\n</code></pre>"},{"location":"uguide/recursive/#using-custom-registry","title":"Using Custom Registry","text":"<p>You can create and use a custom registry for more control:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import TransformerRegistry, recursive_apply\n&gt;&gt;&gt; from coola.recursive import SequenceTransformer, DefaultTransformer\n&gt;&gt;&gt; registry = TransformerRegistry()\n&gt;&gt;&gt; registry.register(list, SequenceTransformer())\n&gt;&gt;&gt; registry.register(object, DefaultTransformer())\n&gt;&gt;&gt; recursive_apply([1, 2, 3], lambda x: x * 10, registry=registry)\n[10, 20, 30]\n</code></pre>"},{"location":"uguide/recursive/#available-transformers","title":"Available Transformers","text":"<p>The <code>coola.recursive</code> package provides several built-in transformers:</p> <ul> <li><code>DefaultTransformer</code>: For scalar/leaf values (no recursion)</li> <li><code>SequenceTransformer</code>: For sequences (list, tuple) - recursive transformation preserving order</li> <li><code>MappingTransformer</code>: For mappings (dict) - recursive transformation of keys and values</li> <li><code>SetTransformer</code>: For sets - recursive transformation without order</li> <li><code>ConditionalTransformer</code>: For conditional transformation based on predicates</li> </ul>"},{"location":"uguide/recursive/#registry-system","title":"Registry System","text":""},{"location":"uguide/recursive/#getting-the-default-registry","title":"Getting the Default Registry","text":"<p>The package maintains a singleton default registry with transformers for common Python types:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry.transform([1, 2, 3], str)\n['1', '2', '3']\n&gt;&gt;&gt; registry.transform({\"a\": 1, \"b\": 2}, lambda x: x * 10)\n{'a': 10, 'b': 20}\n</code></pre> <p>The default registry includes transformers for: - Scalar types: <code>int</code>, <code>float</code>, <code>complex</code>, <code>bool</code>, <code>str</code> - Sequences: <code>list</code>, <code>tuple</code>, <code>Sequence</code> (ABC) - Sets: <code>set</code>, <code>frozenset</code> - Mappings: <code>dict</code>, <code>Mapping</code> (ABC)</p>"},{"location":"uguide/recursive/#registering-custom-types","title":"Registering Custom Types","text":"<p>You can extend the default registry to support custom types:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import register_transformers, BaseTransformer\n&gt;&gt;&gt; class Point:\n...     def __init__(self, x, y):\n...         self.x = x\n...         self.y = y\n...\n&gt;&gt;&gt; class PointTransformer(BaseTransformer):\n...     def transform(self, data, func, registry):\n...         return Point(func(data.x), func(data.y))\n...\n&gt;&gt;&gt; register_transformers({Point: PointTransformer()})  # doctest: +SKIP\n</code></pre>"},{"location":"uguide/recursive/#design-principles","title":"Design Principles","text":"<p>The <code>coola.recursive</code> package design is inspired by the DFS pattern and provides:</p> <ol> <li>Memory-efficient traversal: Uses generators to avoid loading entire structures into memory</li> <li>Type dispatch: Automatically selects the right transformer based on data type</li> <li>Extensibility: Easy to add support for new types via the registry pattern</li> </ol>"},{"location":"uguide/recursive/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/recursive/#data-type-conversion","title":"Data Type Conversion","text":"<p>Convert all numeric values in a nested structure to strings:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; data = {\"metrics\": [1.5, 2.3, 3.7], \"count\": 42}\n&gt;&gt;&gt; recursive_apply(data, str)\n{'metrics': ['1.5', '2.3', '3.7'], 'count': '42'}\n</code></pre>"},{"location":"uguide/recursive/#value-scaling","title":"Value Scaling","text":"<p>Scale all numeric values in a configuration:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; config = {\n...     \"learning_rate\": 0.001,\n...     \"layers\": [64, 128, 256],\n...     \"dropout\": 0.5,\n... }\n&gt;&gt;&gt; recursive_apply(config, lambda x: x * 10 if isinstance(x, (int, float)) else x)\n{'learning_rate': 0.01, 'layers': [640, 1280, 2560], 'dropout': 5.0}\n</code></pre>"},{"location":"uguide/recursive/#data-normalization","title":"Data Normalization","text":"<p>Normalize all values to a specific range:</p> <pre><code>&gt;&gt;&gt; from coola.recursive import recursive_apply\n&gt;&gt;&gt; data = {\"a\": 100, \"b\": [200, 300], \"c\": {\"d\": 400}}\n&gt;&gt;&gt; recursive_apply(data, lambda x: x / 100)\n{'a': 1.0, 'b': [2.0, 3.0], 'c': {'d': 4.0}}\n</code></pre>"},{"location":"uguide/recursive/#see-also","title":"See Also","text":"<ul> <li><code>coola.iterator</code>: For iterating over nested data without transformation</li> <li><code>coola.registry</code>: For understanding the registry pattern used internally</li> </ul>"},{"location":"uguide/registry/","title":"Registry System","text":"<p> This page describes the <code>coola.registry</code> package, which provides thread-safe registry implementations for storing and managing typed mappings.</p> <p>Prerequisites: You'll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"uguide/registry/#overview","title":"Overview","text":"<p>The <code>coola.registry</code> package provides two types of registries for managing key-value mappings:</p> <ul> <li><code>Registry</code>: A generic key-value registry for any hashable keys</li> <li><code>TypeRegistry</code>: A specialized type-based registry with Method Resolution Order (MRO) support</li> </ul> <p>Both registries are thread-safe and support standard dictionary operations through operator overloading.</p>"},{"location":"uguide/registry/#registry-generic-key-value","title":"Registry (Generic Key-Value)","text":""},{"location":"uguide/registry/#basic-usage","title":"Basic Usage","text":"<p>The <code>Registry</code> class provides a thread-safe container for storing and retrieving values by key:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register(\"key1\", 42)\n&gt;&gt;&gt; registry.get(\"key1\")\n42\n</code></pre>"},{"location":"uguide/registry/#dictionary-style-operations","title":"Dictionary-Style Operations","text":"<p>The registry supports standard dictionary operations:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry[\"key1\"] = 100\n&gt;&gt;&gt; \"key1\" in registry\nTrue\n&gt;&gt;&gt; registry[\"key1\"]\n100\n&gt;&gt;&gt; del registry[\"key1\"]\n&gt;&gt;&gt; \"key1\" in registry\nFalse\n</code></pre>"},{"location":"uguide/registry/#initialization-with-data","title":"Initialization with Data","text":"<p>You can initialize a registry with existing data:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.get(\"a\")\n1\n</code></pre>"},{"location":"uguide/registry/#safe-registration","title":"Safe Registration","text":"<p>By default, registering a duplicate key raises an error to prevent accidental overwriting:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register(\"key1\", 42)\n&gt;&gt;&gt; registry.register(\"key1\", 100)  # doctest: +SKIP\nTraceback (most recent call last):\n...\nRuntimeError: A value is already registered for 'key1'...\n</code></pre> <p>To allow overwriting, use <code>exist_ok=True</code>:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register(\"key1\", 42)\n&gt;&gt;&gt; registry.register(\"key1\", 100, exist_ok=True)\n&gt;&gt;&gt; registry.get(\"key1\")\n100\n</code></pre>"},{"location":"uguide/registry/#bulk-registration","title":"Bulk Registration","text":"<p>Register multiple key-value pairs at once:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; registry.register_many({\"key1\": 42, \"key2\": 100, \"key3\": 7})\n&gt;&gt;&gt; len(registry)\n3\n&gt;&gt;&gt; registry.get(\"key2\")\n100\n</code></pre> <p>Bulk updates with <code>exist_ok</code>:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 1})\n&gt;&gt;&gt; registry.register_many({\"key1\": 10, \"key4\": 4}, exist_ok=True)\n&gt;&gt;&gt; registry.get(\"key1\")\n10\n&gt;&gt;&gt; registry.get(\"key4\")\n4\n</code></pre>"},{"location":"uguide/registry/#unregistering-keys","title":"Unregistering Keys","text":"<p>Remove a key and get its value:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry.has(\"key1\")\nTrue\n&gt;&gt;&gt; value = registry.unregister(\"key1\")\n&gt;&gt;&gt; value\n42\n&gt;&gt;&gt; registry.has(\"key1\")\nFalse\n</code></pre>"},{"location":"uguide/registry/#clearing-registry","title":"Clearing Registry","text":"<p>Remove all entries from the registry:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.clear()\n&gt;&gt;&gt; len(registry)\n0\n</code></pre>"},{"location":"uguide/registry/#iterating-over-registry","title":"Iterating Over Registry","text":"<p>Access keys, values, and items:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry = Registry[str, int]({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; list(registry.keys())\n['a', 'b']\n&gt;&gt;&gt; list(registry.values())\n[1, 2]\n&gt;&gt;&gt; list(registry.items())\n[('a', 1), ('b', 2)]\n</code></pre>"},{"location":"uguide/registry/#equality-checking","title":"Equality Checking","text":"<p>Compare two registries:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; registry1 = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry2 = Registry[str, int]({\"key1\": 42, \"key2\": 100})\n&gt;&gt;&gt; registry3 = Registry[str, int]({\"key1\": 42})\n&gt;&gt;&gt; registry1.equal(registry2)\nTrue\n&gt;&gt;&gt; registry1.equal(registry3)\nFalse\n</code></pre>"},{"location":"uguide/registry/#typeregistry-type-based","title":"TypeRegistry (Type-Based)","text":""},{"location":"uguide/registry/#basic-usage_1","title":"Basic Usage","text":"<p>The <code>TypeRegistry</code> class provides a thread-safe container for mapping Python types to values:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(int, \"I am an integer\")\n&gt;&gt;&gt; registry.get(int)\n'I am an integer'\n</code></pre>"},{"location":"uguide/registry/#type-resolution-with-mro","title":"Type Resolution with MRO","text":"<p>The key feature of <code>TypeRegistry</code> is its <code>resolve()</code> method, which uses the Method Resolution Order (MRO) to find the most appropriate value for a type:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(object, \"I am an object\")\n&gt;&gt;&gt; registry.register(int, \"I am an integer\")\n&gt;&gt;&gt; # Direct match\n&gt;&gt;&gt; registry.resolve(int)\n'I am an integer'\n&gt;&gt;&gt; # Falls back to parent type via MRO (bool inherits from int)\n&gt;&gt;&gt; registry.resolve(bool)\n'I am an integer'\n&gt;&gt;&gt; # Falls back to object\n&gt;&gt;&gt; registry.resolve(str)\n'I am an object'\n</code></pre>"},{"location":"uguide/registry/#dictionary-style-operations_1","title":"Dictionary-Style Operations","text":"<p>Like <code>Registry</code>, <code>TypeRegistry</code> supports standard dictionary operations:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry[str] = \"I am a string\"\n&gt;&gt;&gt; str in registry\nTrue\n&gt;&gt;&gt; registry[str]\n'I am a string'\n&gt;&gt;&gt; del registry[str]\n</code></pre>"},{"location":"uguide/registry/#initialization-with-types","title":"Initialization with Types","text":"<p>Initialize with type mappings:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]({str: 100, float: 200})\n&gt;&gt;&gt; len(registry)\n2\n&gt;&gt;&gt; registry.get(str)\n100\n</code></pre>"},{"location":"uguide/registry/#safe-type-registration","title":"Safe Type Registration","text":"<p>Prevent accidental overwriting of type mappings:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register(str, 42)\n&gt;&gt;&gt; registry.register(str, 100)  # doctest: +SKIP\nTraceback (most recent call last):\n...\nRuntimeError: A value is already registered for &lt;class 'str'&gt;...\n</code></pre> <p>Allow overwriting with <code>exist_ok=True</code>:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[int]()\n&gt;&gt;&gt; registry.register(str, 42)\n&gt;&gt;&gt; registry.register(str, 100, exist_ok=True)\n&gt;&gt;&gt; registry.get(str)\n100\n</code></pre>"},{"location":"uguide/registry/#bulk-type-registration","title":"Bulk Type Registration","text":"<p>Register multiple types at once:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register_many({int: \"integer\", float: \"float\", str: \"string\"})\n&gt;&gt;&gt; len(registry)\n3\n&gt;&gt;&gt; registry.get(float)\n'float'\n</code></pre>"},{"location":"uguide/registry/#inheritance-based-lookup","title":"Inheritance-Based Lookup","text":"<p>The <code>resolve()</code> method walks the MRO to find the most specific registered type:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; class Animal:\n...     pass\n...\n&gt;&gt;&gt; class Dog(Animal):\n...     pass\n...\n&gt;&gt;&gt; class Poodle(Dog):\n...     pass\n...\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(Animal, \"animal\")\n&gt;&gt;&gt; registry.register(Dog, \"dog\")\n&gt;&gt;&gt; registry.resolve(Dog)\n'dog'\n&gt;&gt;&gt; registry.resolve(Poodle)  # Resolves to parent Dog\n'dog'\n</code></pre>"},{"location":"uguide/registry/#performance-optimization","title":"Performance Optimization","text":"<p>The <code>TypeRegistry</code> uses an internal cache for type resolution to optimize performance:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; registry = TypeRegistry[str]()\n&gt;&gt;&gt; registry.register(object, \"base\")\n&gt;&gt;&gt; registry.register(int, \"integer\")\n&gt;&gt;&gt; # First resolve() populates cache\n&gt;&gt;&gt; registry.resolve(bool)\n'integer'\n&gt;&gt;&gt; # Subsequent resolves use cached result\n&gt;&gt;&gt; registry.resolve(bool)\n'integer'\n</code></pre> <p>The cache is automatically cleared when you register or unregister types to ensure consistency.</p>"},{"location":"uguide/registry/#thread-safety","title":"Thread Safety","text":"<p>Both <code>Registry</code> and <code>TypeRegistry</code> are thread-safe, using reentrant locks (<code>threading.RLock</code>) to protect concurrent access:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; registry = Registry[str, int]()\n&gt;&gt;&gt; def worker(key, value):\n...     registry.register(key, value, exist_ok=True)\n...\n&gt;&gt;&gt; threads = [threading.Thread(target=worker, args=(f\"key{i}\", i)) for i in range(10)]\n&gt;&gt;&gt; for t in threads:\n...     t.start()\n...\n&gt;&gt;&gt; for t in threads:\n...     t.join()\n...\n&gt;&gt;&gt; len(registry) == 10\nTrue\n</code></pre>"},{"location":"uguide/registry/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/registry/#plugin-system","title":"Plugin System","text":"<p>Use a registry to manage plugins:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; plugin_registry = Registry[str, type]()\n&gt;&gt;&gt; class JSONParser:\n...     pass\n...\n&gt;&gt;&gt; class XMLParser:\n...     pass\n...\n&gt;&gt;&gt; plugin_registry.register(\"json\", JSONParser)\n&gt;&gt;&gt; plugin_registry.register(\"xml\", XMLParser)\n&gt;&gt;&gt; parser_class = plugin_registry.get(\"json\")\n&gt;&gt;&gt; parser_class.__name__\n'JSONParser'\n</code></pre>"},{"location":"uguide/registry/#type-dispatch","title":"Type Dispatch","text":"<p>Use a type registry for dispatching based on type:</p> <pre><code>&gt;&gt;&gt; from coola.registry import TypeRegistry\n&gt;&gt;&gt; handlers = TypeRegistry[str]()\n&gt;&gt;&gt; handlers.register(int, \"handle_int\")\n&gt;&gt;&gt; handlers.register(str, \"handle_str\")\n&gt;&gt;&gt; handlers.register(list, \"handle_list\")\n&gt;&gt;&gt; handlers.resolve(int)\n'handle_int'\n&gt;&gt;&gt; handlers.resolve(bool)  # bool inherits from int\n'handle_int'\n</code></pre>"},{"location":"uguide/registry/#factory-pattern","title":"Factory Pattern","text":"<p>Use a registry to implement a factory pattern:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; factory = Registry[str, type]()\n&gt;&gt;&gt; class Circle:\n...     pass\n...\n&gt;&gt;&gt; class Square:\n...     pass\n...\n&gt;&gt;&gt; factory.register(\"circle\", Circle)\n&gt;&gt;&gt; factory.register(\"square\", Square)\n&gt;&gt;&gt; shape_class = factory.get(\"circle\")\n&gt;&gt;&gt; shape_class.__name__\n'Circle'\n</code></pre>"},{"location":"uguide/registry/#configuration-management","title":"Configuration Management","text":"<p>Store configuration handlers:</p> <pre><code>&gt;&gt;&gt; from coola.registry import Registry\n&gt;&gt;&gt; config_handlers = Registry[str, callable]()\n&gt;&gt;&gt; config_handlers.register(\"database\", lambda: {\"host\": \"localhost\"})\n&gt;&gt;&gt; config_handlers.register(\"cache\", lambda: {\"enabled\": True})\n&gt;&gt;&gt; db_config = config_handlers.get(\"database\")()\n&gt;&gt;&gt; db_config\n{'host': 'localhost'}\n</code></pre>"},{"location":"uguide/registry/#design-principles","title":"Design Principles","text":"<p>The <code>coola.registry</code> package design provides:</p> <ol> <li>Thread safety: All operations are protected by locks for concurrent access</li> <li>Type safety: Generic typing support for type hints and IDE support</li> <li>Flexibility: Support for both generic key-value and type-based registries</li> <li>Performance: Caching in <code>TypeRegistry</code> for efficient type resolution</li> <li>Standard interface: Dictionary-like operations for familiar API</li> </ol>"},{"location":"uguide/registry/#comparison-registry-vs-typeregistry","title":"Comparison: Registry vs TypeRegistry","text":"Feature Registry TypeRegistry Key type Any hashable Python types only MRO lookup No Yes (via <code>resolve()</code>) Caching No Yes (for type resolution) Use case Generic key-value storage Type-based dispatch"},{"location":"uguide/registry/#see-also","title":"See Also","text":"<ul> <li><code>coola.recursive</code>: Uses <code>TransformerRegistry</code> (a <code>TypeRegistry</code>) internally</li> <li><code>coola.iterator</code>: Uses registry pattern for iterator dispatch</li> <li><code>coola.random</code>: Uses <code>Registry</code> to manage random managers</li> </ul>"},{"location":"uguide/summary/","title":"Summarizing Nested Data","text":"<p> This page describes the <code>coola.summary</code> package, which provides utilities for creating human-readable text summaries of complex and nested data structures.</p> <p>Prerequisites: You'll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"uguide/summary/#overview","title":"Overview","text":"<p>The <code>coola.summary</code> package provides a type-based system for generating formatted string representations of Python objects, with special support for nested data structures. Unlike Python's built-in <code>repr()</code> or <code>str()</code>, this package offers:</p> <ul> <li>Configurable depth control: Limit how deep nested structures are expanded</li> <li>Type-specific formatting: Different types are formatted according to their structure</li> <li>Truncation support: Limit the number of items shown in collections</li> <li>Extensibility: Register custom summarizers for your own types</li> <li>Automatic type dispatch: Automatically selects the right summarizer based on type</li> </ul> <p>This is particularly useful for debugging, logging, and displaying complex data in a readable format without being overwhelmed by deeply nested or large structures.</p>"},{"location":"uguide/summary/#basic-usage","title":"Basic Usage","text":""},{"location":"uguide/summary/#the-summarize-function","title":"The <code>summarize()</code> Function","text":"<p>The simplest way to create a summary is using the <code>summarize()</code> function:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize({\"a\": 1, \"b\": \"abc\"}))\n&lt;class 'dict'&gt; (length=2)\n  (a): 1\n  (b): abc\n</code></pre> <p>The function automatically detects the type of data and formats it appropriately.</p>"},{"location":"uguide/summary/#simple-values","title":"Simple Values","text":"<p>For simple scalar values, the summary shows the type and value:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize(42))\n&lt;class 'int'&gt; 42\n&gt;&gt;&gt; print(summarize(3.14159))\n&lt;class 'float'&gt; 3.14159\n&gt;&gt;&gt; print(summarize(\"hello\"))\n&lt;class 'str'&gt; hello\n&gt;&gt;&gt; print(summarize(True))\n&lt;class 'bool'&gt; True\n</code></pre>"},{"location":"uguide/summary/#lists-and-tuples","title":"Lists and Tuples","text":"<p>Sequences are displayed with their type, length, and indexed items:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize([1, 2, 3, 4, 5]))\n&lt;class 'list'&gt; (length=5)\n  (0): 1\n  (1): 2\n  (2): 3\n  (3): 4\n  (4): 5\n</code></pre> <p>Tuples work the same way:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize((10, 20, 30)))\n&lt;class 'tuple'&gt; (length=3)\n  (0): 10\n  (1): 20\n  (2): 30\n</code></pre>"},{"location":"uguide/summary/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries show their type, length, and key-value pairs:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize({\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"}))\n&lt;class 'dict'&gt; (length=3)\n  (name): Alice\n  (age): 30\n  (city): NYC\n</code></pre>"},{"location":"uguide/summary/#sets","title":"Sets","text":"<p>Sets display their type, length, and elements:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize({1, 2, 3, 4, 5}))\n&lt;class 'set'&gt; (length=5)\n  (0): 1\n  (1): 2\n  (2): 3\n  (3): 4\n  (4): 5\n</code></pre> <p>Note: Sets are unordered, so the element order in the summary may vary.</p>"},{"location":"uguide/summary/#working-with-nested-structures","title":"Working with Nested Structures","text":""},{"location":"uguide/summary/#depth-control","title":"Depth Control","text":"<p>The most important feature of <code>coola.summary</code> is controlling how deeply nested structures are expanded using the <code>max_depth</code> parameter:</p> <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; nested_data = {\"level1\": {\"level2\": {\"level3\": [1, 2, 3]}}}\n&gt;&gt;&gt; registry = get_default_registry()\n</code></pre> <p>max_depth=0: Shows the raw string representation (no expansion):</p> <pre><code>&gt;&gt;&gt; print(registry.summarize(nested_data, max_depth=0))\n{'level1': {'level2': {'level3': [1, 2, 3]}}}\n</code></pre> <p>max_depth=1: Expands only the top level:</p> <pre><code>&gt;&gt;&gt; print(registry.summarize(nested_data, max_depth=1))\n&lt;class 'dict'&gt; (length=1)\n  (level1): {'level2': {'level3': [1, 2, 3]}}\n</code></pre> <p>max_depth=2: Expands two levels deep:</p> <pre><code>&gt;&gt;&gt; print(registry.summarize(nested_data, max_depth=2))\n&lt;class 'dict'&gt; (length=1)\n  (level1): &lt;class 'dict'&gt; (length=1)\n      (level2): {'level3': [1, 2, 3]}\n</code></pre> <p>max_depth=3: Expands three levels deep:</p> <pre><code>&gt;&gt;&gt; print(registry.summarize(nested_data, max_depth=3))\n&lt;class 'dict'&gt; (length=1)\n  (level1): &lt;class 'dict'&gt; (length=1)\n      (level2): &lt;class 'dict'&gt; (length=1)\n          (level3): [1, 2, 3]\n</code></pre>"},{"location":"uguide/summary/#complex-nested-examples","title":"Complex Nested Examples","text":"<p>Nested lists and dictionaries:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; data = {\n...     \"users\": [\n...         {\"name\": \"Alice\", \"scores\": [95, 87, 92]},\n...         {\"name\": \"Bob\", \"scores\": [88, 91, 85]},\n...     ],\n...     \"metadata\": {\"count\": 2, \"version\": \"1.0\"},\n... }\n&gt;&gt;&gt; print(summarize(data))\n&lt;class 'dict'&gt; (length=2)\n  (users): [{'name': 'Alice', 'scores': [95, 87, 92]}, {'name': 'Bob', 'scores': [88, 91, 85]}]\n  (metadata): {'count': 2, 'version': '1.0'}\n</code></pre> <p>Mixed types:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; mixed = {\n...     \"int\": 42,\n...     \"float\": 3.14,\n...     \"string\": \"hello\",\n...     \"list\": [1, 2, 3],\n...     \"tuple\": (4, 5, 6),\n...     \"dict\": {\"nested\": \"value\"},\n... }\n&gt;&gt;&gt; print(summarize(mixed))\n&lt;class 'dict'&gt; (length=6)\n  (int): 42\n  (float): 3.14\n  (string): hello\n  (list): [1, 2, 3]\n  (tuple): (4, 5, 6)\n  ...\n</code></pre>"},{"location":"uguide/summary/#controlling-output-size","title":"Controlling Output Size","text":""},{"location":"uguide/summary/#limiting-items-in-collections","title":"Limiting Items in Collections","text":"<p>By default, collections show a maximum of 5 items. Longer collections are truncated with <code>...</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; long_list = list(range(20))\n&gt;&gt;&gt; print(summarize(long_list))\n&lt;class 'list'&gt; (length=20)\n  (0): 0\n  (1): 1\n  (2): 2\n  (3): 3\n  (4): 4\n  ...\n</code></pre>"},{"location":"uguide/summary/#custom-max_items","title":"Custom max_items","text":"<p>You can customize the number of items shown using custom summarizers:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer(max_items=3))\n&gt;&gt;&gt; long_list = list(range(10))\n&gt;&gt;&gt; print(registry.summarize(long_list))\n&lt;class 'list'&gt; (length=10)\n  (0): 0\n  (1): 1\n  (2): 2\n  ...\n</code></pre> <p>To show all items, set <code>max_items=-1</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer(max_items=-1))\n&gt;&gt;&gt; print(registry.summarize(list(range(10))))\n&lt;class 'list'&gt; (length=10)\n  (0): 0\n  (1): 1\n  (2): 2\n  (3): 3\n  (4): 4\n  (5): 5\n  (6): 6\n  (7): 7\n  (8): 8\n  (9): 9\n</code></pre>"},{"location":"uguide/summary/#truncating-long-strings","title":"Truncating Long Strings","text":"<p>For very long strings or values, you can use <code>DefaultSummarizer</code> with <code>max_characters</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, DefaultSummarizer\n&gt;&gt;&gt; long_string = (\n...     \"This is a very long string that should be truncated when max_characters is set\"\n... )\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer(max_characters=30))\n&gt;&gt;&gt; print(registry.summarize(long_string))\n&lt;class 'str'&gt; This is a very long string tha...\n</code></pre>"},{"location":"uguide/summary/#customizing-indentation","title":"Customizing Indentation","text":"<p>The <code>num_spaces</code> parameter controls indentation for nested structures:</p> <pre><code>&gt;&gt;&gt; from coola.summary import (\n...     SummarizerRegistry,\n...     MappingSummarizer,\n...     SequenceSummarizer,\n...     DefaultSummarizer,\n... )\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": {\"nested\": \"value\"}}\n&gt;&gt;&gt; # Default: 2 spaces\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer(num_spaces=2))\n&gt;&gt;&gt; registry.register(dict, MappingSummarizer(num_spaces=2))\n&gt;&gt;&gt; print(registry.summarize(data, max_depth=3))\n&lt;class 'dict'&gt; (length=2)\n  (a): &lt;class 'list'&gt; (length=3)\n      (0): &lt;class 'int'&gt; 1\n      (1): &lt;class 'int'&gt; 2\n      (2): &lt;class 'int'&gt; 3\n  (b): &lt;class 'dict'&gt; (length=1)\n      (nested): &lt;class 'str'&gt; value\n</code></pre> <p>With 4 spaces for clearer nesting:</p> <pre><code>&gt;&gt;&gt; from coola.summary import (\n...     SummarizerRegistry,\n...     MappingSummarizer,\n...     SequenceSummarizer,\n...     DefaultSummarizer,\n... )\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer(num_spaces=4))\n&gt;&gt;&gt; registry.register(dict, MappingSummarizer(num_spaces=4))\n&gt;&gt;&gt; print(registry.summarize(data, max_depth=3))\n&lt;class 'dict'&gt; (length=2)\n    (a): &lt;class 'list'&gt; (length=3)\n            (0): &lt;class 'int'&gt; 1\n            (1): &lt;class 'int'&gt; 2\n            (2): &lt;class 'int'&gt; 3\n    (b): &lt;class 'dict'&gt; (length=1)\n            (nested): &lt;class 'str'&gt; value\n</code></pre>"},{"location":"uguide/summary/#working-with-numpy-and-pytorch","title":"Working with NumPy and PyTorch","text":""},{"location":"uguide/summary/#numpy-arrays","title":"NumPy Arrays","text":"<p>The <code>NDArraySummarizer</code> creates compact summaries of NumPy arrays:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from coola.summary import SummarizerRegistry, NDArraySummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(np.ndarray, NDArraySummarizer())\n&gt;&gt;&gt; arr = np.arange(100).reshape(10, 10)\n&gt;&gt;&gt; print(registry.summarize(arr))\n&lt;class 'numpy.ndarray'&gt; | shape=(10, 10) | dtype=int64\n</code></pre> <p>By default, only metadata is shown. To see the actual data, use <code>show_data=True</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, NDArraySummarizer, DefaultSummarizer\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(np.ndarray, NDArraySummarizer(show_data=True))\n&gt;&gt;&gt; arr = np.arange(5)\n&gt;&gt;&gt; print(registry.summarize(arr))\narray([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"uguide/summary/#pytorch-tensors","title":"PyTorch Tensors","text":"<p>The <code>TensorSummarizer</code> works similarly for PyTorch tensors:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.summary import SummarizerRegistry, TensorSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(torch.Tensor, TensorSummarizer())\n&gt;&gt;&gt; tensor = torch.randn(3, 4, 5)\n&gt;&gt;&gt; print(registry.summarize(tensor))\n&lt;class 'torch.Tensor'&gt; | shape=torch.Size([3, 4, 5]) | dtype=torch.float32 | device=cpu | requires_grad=False\n</code></pre> <p>With <code>show_data=True</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, TensorSummarizer, DefaultSummarizer\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(torch.Tensor, TensorSummarizer(show_data=True))\n&gt;&gt;&gt; tensor = torch.arange(5)\n&gt;&gt;&gt; print(registry.summarize(tensor))\ntensor([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"uguide/summary/#creating-custom-summarizers","title":"Creating Custom Summarizers","text":""},{"location":"uguide/summary/#defining-a-custom-summarizer","title":"Defining a Custom Summarizer","text":"<p>To create a custom summarizer for your own types, extend <code>BaseSummarizer</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import BaseSummarizer, SummarizerRegistry\n\n&gt;&gt;&gt; class Person:\n...     def __init__(self, name, age):\n...         self.name = name\n...         self.age = age\n...\n&gt;&gt;&gt; class PersonSummarizer(BaseSummarizer):\n...     def equal(self, other: object) -&gt; bool:\n...         return type(self) is type(other)\n...     def summarize(self, data, registry, depth=0, max_depth=1):\n...         return f\"Person(name={data.name!r}, age={data.age})\"\n...\n</code></pre>"},{"location":"uguide/summary/#registering-custom-summarizers","title":"Registering Custom Summarizers","text":"<p>Register your custom summarizer with the registry:</p> <pre><code>&gt;&gt;&gt; from coola.summary import register_summarizers\n&gt;&gt;&gt; register_summarizers({Person: PersonSummarizer()})\n&gt;&gt;&gt; person = Person(\"Alice\", 30)\n&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; print(summarize(person))\nPerson(name='Alice', age=30)\n</code></pre>"},{"location":"uguide/summary/#working-with-the-registry","title":"Working with the Registry","text":""},{"location":"uguide/summary/#understanding-the-registry","title":"Understanding the Registry","text":"<p>The <code>SummarizerRegistry</code> manages the mapping from types to summarizers:</p> <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry\nSummarizerRegistry(\n  (state): TypeRegistry(\n      (&lt;class 'object'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'str'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'int'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'float'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'complex'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'bool'&gt;): DefaultSummarizer(max_characters=-1)\n      (&lt;class 'list'&gt;): SequenceSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'tuple'&gt;): SequenceSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'collections.abc.Sequence'&gt;): SequenceSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'set'&gt;): SetSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'frozenset'&gt;): SetSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'dict'&gt;): MappingSummarizer(max_items=5, num_spaces=2)\n      (&lt;class 'collections.abc.Mapping'&gt;): MappingSummarizer(max_items=5, num_spaces=2)\n      ...\n    )\n)\n</code></pre>"},{"location":"uguide/summary/#creating-a-custom-registry","title":"Creating a Custom Registry","text":"<p>For complete control, create your own registry:</p> <pre><code>&gt;&gt;&gt; from coola.summary import SummarizerRegistry, SequenceSummarizer, DefaultSummarizer\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register(object, DefaultSummarizer())\n&gt;&gt;&gt; registry.register(list, SequenceSummarizer())\n&gt;&gt;&gt; print(registry.summarize([1, 2, 3]))\n&lt;class 'list'&gt; (length=3)\n  (0): 1\n  (1): 2\n  (2): 3\n</code></pre>"},{"location":"uguide/summary/#registering-multiple-types","title":"Registering Multiple Types","text":"<p>Use <code>register_many()</code> to register multiple types at once:</p> <pre><code>&gt;&gt;&gt; from coola.summary import (\n...     SummarizerRegistry,\n...     SequenceSummarizer,\n...     MappingSummarizer,\n...     DefaultSummarizer,\n... )\n&gt;&gt;&gt; registry = SummarizerRegistry()\n&gt;&gt;&gt; registry.register_many(\n...     {object: DefaultSummarizer(), list: SequenceSummarizer(), dict: MappingSummarizer()}\n... )\n</code></pre>"},{"location":"uguide/summary/#checking-registered-types","title":"Checking Registered Types","text":"<p>Check if a type has a registered summarizer:</p> <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; registry.has_summarizer(list)\nTrue\n&gt;&gt;&gt; registry.has_summarizer(int)\nTrue\n</code></pre>"},{"location":"uguide/summary/#common-use-cases","title":"Common Use Cases","text":""},{"location":"uguide/summary/#debugging-complex-data","title":"Debugging Complex Data","text":"<p>Quickly inspect complex data structures during debugging:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; config = {\n...     \"database\": {\n...         \"host\": \"localhost\",\n...         \"port\": 5432,\n...         \"credentials\": {\"user\": \"admin\", \"password\": \"secret\"},\n...     },\n...     \"cache\": {\"enabled\": True, \"ttl\": 3600, \"backends\": [\"redis\", \"memcached\"]},\n... }\n&gt;&gt;&gt; print(summarize(config))\n&lt;class 'dict'&gt; (length=2)\n  (database): {'host': 'localhost', 'port': 5432, 'credentials': {'user': 'admin', 'password': 'secret'}}\n  (cache): {'enabled': True, 'ttl': 3600, 'backends': ['redis', 'memcached']}\n</code></pre>"},{"location":"uguide/summary/#logging-large-tensors","title":"Logging Large Tensors","text":"<p>Log tensor shapes without filling logs with data:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; model_weights = {\n...     \"layer1\": torch.randn(1000, 1000),\n...     \"layer2\": torch.randn(1000, 500),\n...     \"bias\": torch.randn(500),\n... }\n&gt;&gt;&gt; print(summarize(model_weights, max_depth=2))\n&lt;class 'dict'&gt; (length=3)\n  (layer1): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([1000, 1000]) | dtype=torch.float32 | device=cpu | requires_grad=False\n  (layer2): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([1000, 500]) | dtype=torch.float32 | device=cpu | requires_grad=False\n  (bias): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([500]) | dtype=torch.float32 | device=cpu | requires_grad=False\n</code></pre>"},{"location":"uguide/summary/#inspecting-api-responses","title":"Inspecting API Responses","text":"<p>Summarize complex API responses:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; api_response = {\n...     \"status\": \"success\",\n...     \"data\": {\n...         \"items\": [\n...             {\"id\": 1, \"name\": \"Item 1\", \"tags\": [\"tag1\", \"tag2\"]},\n...             {\"id\": 2, \"name\": \"Item 2\", \"tags\": [\"tag3\"]},\n...             # ... potentially many more items\n...         ],\n...         \"pagination\": {\"page\": 1, \"total_pages\": 10},\n...     },\n... }\n&gt;&gt;&gt; print(summarize(api_response))\n&lt;class 'dict'&gt; (length=2)\n  (status): success\n  (data): {'items': [{'id': 1, 'name': 'Item 1', 'tags': ['tag1', 'tag2']}, {'id': 2, 'name': 'Item 2', 'tags': ['tag3']}], 'pagination': {'page': 1, 'total_pages': 10}}\n</code></pre>"},{"location":"uguide/summary/#comparing-data-structures","title":"Comparing Data Structures","text":"<p>Get a quick overview to compare different data structures. Note that with default <code>max_depth=1</code>, nested structures are shown as raw strings without truncation:</p> <pre><code>&gt;&gt;&gt; from coola.summary import summarize\n&gt;&gt;&gt; data1 = {\"users\": [1, 2, 3, 4, 5], \"version\": \"1.0\"}\n&gt;&gt;&gt; data2 = {\"users\": [1, 2, 3], \"version\": \"2.0\"}\n&gt;&gt;&gt; print(summarize(data1))\n&lt;class 'dict'&gt; (length=2)\n  (users): [1, 2, 3, 4, 5]\n  (version): 1.0\n&gt;&gt;&gt; print(summarize(data2))\n&lt;class 'dict'&gt; (length=2)\n  (users): [1, 2, 3]\n  (version): 2.0\n</code></pre> <p>For deeper inspection with truncation, increase <code>max_depth</code>:</p> <pre><code>&gt;&gt;&gt; from coola.summary import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; data = {\"users\": list(range(20)), \"version\": \"1.0\"}\n&gt;&gt;&gt; print(registry.summarize(data, max_depth=2))\n&lt;class 'dict'&gt; (length=2)\n  (users): &lt;class 'list'&gt; (length=20)\n      (0): 0\n      (1): 1\n      (2): 2\n      (3): 3\n      (4): 4\n      ...\n  (version): &lt;class 'str'&gt; 1.0\n</code></pre>"},{"location":"uguide/summary/#available-summarizers","title":"Available Summarizers","text":"<p>The <code>coola.summary</code> package provides the following built-in summarizers:</p> <ul> <li><code>DefaultSummarizer</code>: For generic objects and scalar types (int, float, str, bool, etc.)</li> <li>Configurable: <code>max_characters</code> (default: -1, no limit)</li> <li><code>SequenceSummarizer</code>: For sequences (list, tuple, Sequence ABC)</li> <li>Configurable: <code>max_items</code> (default: 5), <code>num_spaces</code> (default: 2)</li> <li><code>MappingSummarizer</code>: For mappings (dict, Mapping ABC)</li> <li>Configurable: <code>max_items</code> (default: 5), <code>num_spaces</code> (default: 2)</li> <li><code>SetSummarizer</code>: For sets (set, frozenset)</li> <li>Configurable: <code>max_items</code> (default: 5), <code>num_spaces</code> (default: 2)</li> <li><code>NDArraySummarizer</code>: For NumPy arrays (requires NumPy)</li> <li>Configurable: <code>show_data</code> (default: False)</li> <li><code>TensorSummarizer</code>: For PyTorch tensors (requires PyTorch)</li> <li>Configurable: <code>show_data</code> (default: False)</li> </ul>"},{"location":"uguide/summary/#design-principles","title":"Design Principles","text":"<p>The <code>coola.summary</code> package is designed with the following principles:</p> <ol> <li>Type-based dispatch: Automatically selects the appropriate summarizer based on data type</li> <li>Recursive summarization: Handles deeply nested structures through the registry pattern</li> <li>Configurable output: Control depth, item limits, and formatting to suit your needs</li> <li>Extensibility: Easy to add support for custom types via the registry</li> <li>Sensible defaults: Works out-of-the-box for common Python types</li> <li>Metadata focus: For large data structures (arrays, tensors), show metadata instead of data</li> </ol>"},{"location":"uguide/summary/#see-also","title":"See Also","text":"<ul> <li>Recursive Data Transformation: For transforming nested data while preserving structure</li> <li>Iterating Over Nested Data: For iterating over nested data structures</li> <li>Registry System: For understanding the registry pattern used internally</li> </ul>"},{"location":"uguide/types/","title":"Supported Types","text":"<p> This page describes what types are currently supported and what rules are used to check if two objects are equal or not.</p> <p>The current supported types are:</p> <ul> <li><code>jax.numpy.ndarray</code></li> <li><code>numpy.ndarray</code></li> <li><code>numpy.ma.MaskedArray</code></li> <li><code>pandas.DataFrame</code></li> <li><code>pandas.Series</code></li> <li><code>polars.DataFrame</code></li> <li><code>polars.Series</code></li> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> <li><code>xarray.Variable</code></li> </ul> <p><code>coola</code> also provides experimental/partial support for the following types:</p> <ul> <li><code>pyarrow.Array</code> (<code>equal_nan</code>,   <code>atol</code> and <code>rtol</code> arguments are ignored)</li> <li><code>pyarrow.Table</code> (<code>equal_nan</code>,   <code>atol</code> and <code>rtol</code> arguments are ignored)</li> </ul>"},{"location":"uguide/types/#equal","title":"Equal","text":""},{"location":"uguide/types/#object","title":"<code>object</code>","text":"<p>By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>actual == expected</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(1, 1)\nTrue\n&gt;&gt;&gt; objects_are_equal(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_equal(1, 1.0)\nFalse\n&gt;&gt;&gt; objects_are_equal(True, True)\nTrue\n&gt;&gt;&gt; objects_are_equal(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"uguide/types/#collectionsabcmapping-dict","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal. The value associated to the key <code>k</code> in the first mapping has   to be equal to value associated to the key <code>k</code> in the second mapping.</li> </ul> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_equal({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"uguide/types/#collectionsabcsequence-list-tuple","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal. The <code>i</code>-th element in the first sequence has to be   equal to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_equal([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"uguide/types/#pytorch","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"uguide/types/#torchtensor","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>tensor1.equal(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_equal(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"uguide/types/#torchnnutilsrnnpackedsequence","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal if:</p> <ul> <li>The <code>data</code> attributes are equal</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_equal(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"uguide/types/#numpyndarray","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>they have the same values i.e. <code>numpy.array_equal(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_equal(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"uguide/types/#xarray","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"uguide/types/#xarraydataarray","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal if:</p> <ul> <li>they have the same data values (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"])\n... )\nTrue\n&gt;&gt;&gt; objects_are_equal(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"])\n... )\nFalse\n</code></pre>"},{"location":"uguide/types/#xarraydataset","title":"<code>xarray.Dataset</code>","text":"<p>Two xarray <code>Dataset</code>s are equal if <code>xarray.Dataset.identical</code> returns <code>True</code>. In contrast to the standard usage in numpy, NaNs are compared like numbers, two <code>Dataset</code>s are equal if both objects have NaNs in the same positions.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; ds1 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds2 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...         \"y\": xr.DataArray(\n...             np.ones((6, 3)),\n...             dims=[\"z\", \"t\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1, \"t\": [\"t1\", \"t2\", \"t3\"]},\n... )\n&gt;&gt;&gt; ds3 = xr.Dataset(\n...     {\n...         \"x\": xr.DataArray(\n...             np.arange(6),\n...             dims=[\"z\"],\n...         ),\n...     },\n...     coords={\"z\": np.arange(6) + 1},\n... )\n&gt;&gt;&gt; objects_are_equal(ds1, ds2)\nTrue\n&gt;&gt;&gt; objects_are_equal(ds1, ds3)\nFalse\n</code></pre>"},{"location":"uguide/types/#equal-within-a-tolerance-allclose","title":"Equal within a tolerance (allclose)","text":""},{"location":"uguide/types/#object_1","title":"<code>object</code>","text":"<p>The concept of equal within a tolerance does not make sense for all <code>object</code>s. In general, the tolerance is not used for <code>object</code>s. The tolerance is only used for numbers (see below). By default, two objects are equal if:</p> <ul> <li>they have the same type</li> <li>they are equal i.e. <code>actual == expected</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abc\")\nTrue\n&gt;&gt;&gt; objects_are_allclose(\"abc\", \"abcd\")\nFalse\n</code></pre>"},{"location":"uguide/types/#numbers-bool-int-float","title":"Numbers: <code>bool</code> | <code>int</code> | <code>float</code>","text":"<p>Two numbers are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>the values are equal with a tolerance</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(1, 2)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1, 2, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0)\nFalse\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1.0, 2.0, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(1, 2.0, atol=1)\nFalse\n</code></pre> <p>Note that booleans are explicitly considered as integers in Python so the tolerance can be used with booleans:</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(True, False)\nFalse\n&gt;&gt;&gt; objects_are_allclose(True, False, atol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(True, False, rtol=1)\nTrue\n</code></pre>"},{"location":"uguide/types/#collectionsabcmapping-dict_1","title":"<code>collections.abc.Mapping</code> | <code>dict</code>","text":"<p>Two <code>Mapping</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(mapping1) == len(mapping2)</code> returns <code>True</code></li> <li>they have the same set of keys i.e. <code>set(mapping1.keys()) != set(mapping2.keys())</code> returns <code>True</code></li> <li>For each key, the values are equal within a tolerance. The value associated to the key <code>k</code> in the   first mapping has to be equal within the tolerance to value associated to the key <code>k</code> in the   second mapping.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\"})\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 2, \"str\": \"abc\"}, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, OrderedDict({\"int\": 1, \"str\": \"abc\"}))\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abc\", \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"float\": 0.2})\nFalse\n&gt;&gt;&gt; objects_are_allclose({\"int\": 1, \"str\": \"abc\"}, {\"int\": 1, \"str\": \"abcd\"})\nFalse\n</code></pre>"},{"location":"uguide/types/#collectionsabcsequence-list-tuple_1","title":"<code>collections.abc.Sequence</code> | <code>list</code> | <code>tuple</code>","text":"<p>Two <code>Sequence</code>s are equal within a tolerance if:</p> <ul> <li>they have the same type</li> <li>they have the same number of elements i.e. <code>len(sequence1) == len(sequence2)</code> returns <code>True</code></li> <li>For each position, the elements are equal within a tolerance. The <code>i</code>-th element in the first   sequence has to be equal within a tolerance to the <code>i</code>-th element in the second sequence.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\"])\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 3, \"abc\"], rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], (1, 2, \"abc\"))\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abc\", 4])\nFalse\n&gt;&gt;&gt; objects_are_allclose([1, 2, \"abc\"], [1, 2, \"abcd\"])\nFalse\n</code></pre>"},{"location":"uguide/types/#pytorch_1","title":"PyTorch","text":"<p>You need to install <code>coola</code> with PyTorch to check if some PyTorch objects are equal within a tolerance or not. Please check the get started page for more information. <code>coola</code> currently support the following PyTorch objects:</p> <ul> <li><code>torch.Tensor</code></li> <li><code>torch.nn.utils.rnn.PackedSequence</code></li> </ul>"},{"location":"uguide/types/#torchtensor_1","title":"<code>torch.Tensor</code>","text":"<p>Two PyTorch <code>Tensor</code>s are equal if:</p> <ul> <li>they have the same data type i.e. <code>tensor1.dtype == tensor2.dtype</code> returns <code>True</code></li> <li>they have the same device i.e. <code>tensor1.device == tensor2.device</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>tensor1.shape == tensor2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>tensor1.allclose(tensor2)</code> returns <code>True</code></li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3))\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(2, 3, dtype=torch.long))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.zeros(2, 3))\nFalse\n&gt;&gt;&gt; objects_are_allclose(torch.ones(2, 3), torch.ones(6))\nFalse\n</code></pre>"},{"location":"uguide/types/#torchnnutilsrnnpackedsequence_1","title":"<code>torch.nn.utils.rnn.PackedSequence</code>","text":"<p>Two PyTorch <code>PackedSequence</code>s are equal within a tolerance if:</p> <ul> <li>The <code>data</code> attributes are equal within a tolerance</li> <li>The <code>batch_sizes</code> attributes are equal</li> <li>The <code>sorted_indices</code> attributes are equal</li> <li>The <code>unsorted_indices</code> attributes are equal</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn.utils.rnn import pack_padded_sequence\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float() + 1,\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     atol=2,\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).add(1).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different values\nFalse\n&gt;&gt;&gt; objects_are_allclose(\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 3], dtype=torch.long),\n...         batch_first=True,\n...     ),\n...     pack_padded_sequence(\n...         input=torch.arange(10).view(2, 5).float(),\n...         lengths=torch.tensor([5, 2], dtype=torch.long),\n...         batch_first=True,\n...     ),\n... )  # different lengths\nFalse\n</code></pre>"},{"location":"uguide/types/#numpyndarray_1","title":"<code>numpy.ndarray</code>","text":"<p>You need to install <code>coola</code> with NumPy to check if some NumPy ndarrays are equal or not. Please check the get started page for more information.</p> <p>Two NumPy <code>ndarray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data type i.e. <code>array1.dtype == array2.dtype</code> returns <code>True</code></li> <li>they have the same shape i.e. <code>array1.shape == array2.shape</code> returns <code>True</code></li> <li>the values are equal within a tolerance i.e. <code>numpy.allclose(array1, array2)</code> returns <code>True</code></li> </ul> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)))\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, atol=2)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3)) + 1, rtol=1)\nTrue\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((2, 3), dtype=int))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.zeros((2, 3)))\nFalse\n&gt;&gt;&gt; objects_are_allclose(numpy.ones((2, 3)), numpy.ones((6,)))\nFalse\n</code></pre>"},{"location":"uguide/types/#xarray_1","title":"xarray","text":"<p>You need to install <code>coola</code> with PyTorch to check if some xarray objects are equal or not. Please check the get started page for more information. <code>coola</code> currently support the following xarray objects:</p> <ul> <li><code>xarray.DataArray</code></li> <li><code>xarray.Dataset</code></li> </ul>"},{"location":"uguide/types/#xarraydataarray_1","title":"<code>xarray.DataArray</code>","text":"<p>Two xarray <code>DataArray</code>s are equal within a tolerance if:</p> <ul> <li>they have the same data values within the tolerance (attribute <code>data</code>)</li> <li>they have the same name (attribute <code>name</code>)</li> <li>they have the same dimension names (attribute <code>dims</code>)</li> <li>they have the same coordinates (attribute <code>coords</code>)</li> <li>they have the same metadata (attribute <code>attrs</code>)</li> </ul> <p>Unlike <code>xarray.DataArray.identical</code>, two <code>DataArray</code>s are not equal if both objects have NaNs in the same positions to follow the standard usage in numpy. You can use <code>objects_are_allclose</code> to compare objects with NaNs.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; from coola import objects_are_allclose\n&gt;&gt;&gt; objects_are_allclose(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.arange(6), dims=[\"z\"])\n... )\nTrue\n&gt;&gt;&gt; objects_are_allclose(\n...     xr.DataArray(np.arange(6), dims=[\"z\"]), xr.DataArray(np.zeros(6), dims=[\"z\"])\n... )\nFalse\n</code></pre>"},{"location":"upgrade/0.3/","title":"0.2 to 0.3","text":"<p>This page explains how to migrate from <code>coola</code> 0.2 to 0.3 because <code>coola</code> 0.3 introduces several non-backward compatible changes due to the redesign of the equality mechanism.</p>"},{"location":"upgrade/0.3/#objects_are_equalallclose","title":"<code>objects_are_equal/allclose</code>","text":"<p>The signature of the <code>objects_are_equal</code> and <code>objects_are_allclose</code> function were updated and only the first two arguments can be provided as positional arguments. All the other arguments had to be provided as keyword arguments. Both functions take a <code>BaseEqualityTester</code> as <code>tester</code> argument.</p>"},{"location":"upgrade/0.3/#objects_are_equal","title":"<code>objects_are_equal</code>","text":"<p><code>coola</code> 0.3 also introduces a new parameter <code>equal_nan</code> to <code>objects_are_equal</code> to indicate whether to compare NaN\u2019s as equal. To keep the behavior similar as <code>coola</code> 0.2, the default value of <code>equal_nan</code> is <code>False</code>.</p> coola 0.2 (old)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n</code></pre> coola 0.3 (new)<pre><code>&gt;&gt;&gt; from coola import objects_are_equal\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"))\nFalse\n&gt;&gt;&gt; objects_are_equal(float(\"nan\"), float(\"nan\"), equal_nan=True)\nTrue\n</code></pre>"},{"location":"upgrade/0.3/#equality-mechanism","title":"Equality mechanism","text":"<p>The equality mechanism was fully redesigned in <code>coola</code> 0.3 to merge the two existing equality mechanisms. In <code>coola</code> 0.2, there were two equality mechanisms:</p> <ul> <li>a mechanism to check if two objects are equal (mechanism behind <code>objects_are_equal</code>)</li> <li>a mechanism to check if two objects are equal within tolerance (mechanism   behind <code>objects_are_allclose</code>)</li> </ul> <p>This approach was not scalable because there were a lot of overlap and duplicate code between the two mechanisms. For each new type to support, it was necessary to implement two comparators: one inheriting from <code>BaseEqualityOperator</code> and another one inheriting from <code>BaseAllCloseOperator</code>. In the long term, fusing the two mechanisms will make the code easier to maintain and extend. The new equality mechanism combines two previous equality mechanisms in a single equality mechanism so it is necessary to implement only a single comparator for each type.</p> <p><code>BaseEqualityOperator</code> has a new interface which is similar but not directly compatible with the old interface. The new interface introduces a new data structure <code>EqualityConfig</code> to keep the interface simpler and to make the fusion easier. <code>EqualityConfig</code> stores all the parameters that controls the equality mechanism, like the absolute or relative tolerance thresholds. Below is a simplified version of the interface. Please check the code to see all the details.</p> coola 0.3 (new interface)<pre><code>from abc import ABC, abstractmethod\nfrom typing import Any, Generic, TypeVar\n\nfrom coola.equality.config import EqualityConfig\n\nT = TypeVar(\"T\")\n\n\nclass BaseEqualityComparator(ABC, Generic[T]):\n    @abstractmethod\n    def equal(self, object1: T, object2: Any, config: EqualityConfig) -&gt; bool:\n        pass\n</code></pre> <p>Note that in most of the cases, it will not be necessary to change the overall logic inside the <code>equal</code> method.</p> <p>The redesign of the equality mechanism introduces the following main changes:</p> <ul> <li>The class <code>BaseAllCloseOperator</code> has been removed as well as all its child classes.</li> <li><code>coola.comparators</code> has been removed and an equivalent package has been   added <code>coola.equality.comparators</code>. Please note that <code>coola.equality.comparators</code> is not a direct   replacement of <code>coola.comparators</code> because <code>BaseEqualityOperator</code> has new interface.</li> <li><code>coola.testers</code> has been removed and an equivalent package has been   added <code>coola.equality.testers</code>. Please note that <code>coola.equality.testers</code> is not a direct   replacement of <code>coola.testers</code> because <code>BaseEqualityOperator</code> has new interface.</li> </ul>"},{"location":"upgrade/0.4/","title":"0.3 to 0.4","text":"<p>This page explains how to migrate from <code>coola</code> 0.3 to 0.4 because <code>coola</code> 0.4 introduces several non-backward compatible changes.</p>"},{"location":"upgrade/0.4/#objects_are_equalallclose","title":"<code>objects_are_equal/allclose</code>","text":"<p>The signature of the <code>objects_are_equal</code> and <code>objects_are_allclose</code> function were updated:</p> <ul> <li><code>object1</code> was renamed to <code>actual</code></li> <li><code>object2</code> was renamed to <code>expected</code></li> </ul> <p>The same changes were made in the associated classes to be consistent:</p> <ul> <li><code>BaseEqualityComparator</code></li> <li><code>BaseEqualityHandler</code></li> <li><code>BaseEqualityTester</code></li> </ul>"}]}